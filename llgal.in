#!/usr/bin/perl -w

use strict ;

require Llgal::Config ;
require Llgal::Messages ;
require Llgal::Templates ;
require Llgal::Utils ;

use FileHandle ;
use Image::Size ;
use Image::ExifTool ;
use Cwd ;
use Locale::gettext ;
use POSIX qw (setlocale) ;
use URI::Escape ;

Getopt::Long::Configure('noignorecase', 'noautoabbrev', 'bundling') ;
STDOUT->autoflush("1") ;

# constants and globals
my $self = {
    version => "@VERSION@",
    llgal_config_dir => "@SYSCONFDIR@/llgal",
    llgal_share_dir => "@DATADIR@/llgal",
    user_share_dir => $ENV{HOME}."/.llgal",
    generic_configuration_filename => "llgalrc",
    locale_dir => "@LOCALEDIR@",

    # local llgal directory, may be modified during early configuration
    local_llgal_dir => ".llgal",
    # look in current directory "."
    destination_dir => ".",
    # no subsection by default
    # subsection_dirs => (),

    # some variable may only be modified when by system
    # or user-wide configuration files only
    early_configuration => 1,

    # show version
    version_asked => 0,
    # displays brief usage message
    help_asked => 0,
    # clean up all generated files
    clean_asked => 0,
    # clean up all generated and user modified files
    cleanall_asked => 0,
    # generate (or update) captions
    generate_captions => 0,
    # give templates to the given directory
    give_templates => undef,
    # generate a config file
    generate_config => undef,

    # level of indentation, warnings, ...
    messages => Llgal::Messages::new (),
} ;

# store command-line options upfront to write in the index <HEAD>
my @llgal_options = @ARGV ;

# parse early command line options
Llgal::Config::early_parse_cmdline_options ($self) ;

# gettext initialization
Llgal::Config::init_llgal_gettext ($self) ;

######################################################################
# various temporary globals
my $messages = $self->{messages} ;
my $destination_string ;
my $local_llgal_url ;
my $opts ;
my $opts_without_defaults ;

######################################################################
# --clean and --cleanall option

sub clean_files {
    my $cleanall = shift ;
    my $notdeleted = 0 ;
    if ($cleanall) {
	$messages->print ("Cleaning all in $destination_string\n") ;
    } else {
	$messages->print ("Cleaning in $destination_string\n") ;
    }

    opendir DIR, "$self->{destination_dir}$self->{local_llgal_dir}"
	or die "Can't open directory $self->{destination_dir}$self->{local_llgal_dir} ($!)\n" ;
    while ($_ = readdir DIR) {
	if (/^$opts->{thumbnail_image_filenameprefix}/ or /^$opts->{scaled_image_filenameprefix}/) {
	    unlink "$self->{destination_dir}$self->{local_llgal_dir}/$_" ;
	} elsif (/^$opts->{filmtile_filename}$/ or /^$opts->{index_link_image_filename}$/
		 or /^$opts->{prev_slide_link_image_filename}$/ or /^$opts->{next_slide_link_image_filename}$/
		 or /^$opts->{indextemplate_filename}$/ or /^$opts->{slidetemplate_filename}$/
		 or /^$opts->{css_filename}$/) {
	    my $original = (Llgal::Templates::find_generic_template_file ($self, $opts, $_, 0))."/".$_ ;
	    my $diff = 0 ;
	    my @output ;
	    # default is cleanall, which removes everything, as if file were not changed
	    if (!$cleanall) {
		($diff, @output) = Llgal::Utils::system_with_output
		    ("compare $_ with its original",
		     "cmp", "-s", "$self->{destination_dir}$self->{local_llgal_dir}/$_", "$original") ;
		if ($diff == -1) {
		    $messages->warning (@output) ;
		    die "Failed to execute 'cmp' to check whether $self->{destination_dir}$self->{local_llgal_dir}/$_ has been modified ($!).\n" ;
		}
		$messages->warning (@output) ;
		# on other errors, assume files are different ($diff != 0)
	    }
	    if ($diff) {
		$messages->warning ("Preserved $self->{destination_dir}$self->{local_llgal_dir}/$_ since it seems to be modified.") ;
		$notdeleted++ ;
	    } else {
		if (!unlink "$self->{destination_dir}$self->{local_llgal_dir}/$_" and ! $!{ENOENT}) {
		    $messages->warning ("Failed to remove file $self->{destination_dir}$self->{local_llgal_dir}/$_ ($!).") ;
		}
	    }
	} elsif (/^$opts->{captions_filename}$/) {
	    my $grep = 0 ;
	    my @output ;
	    # default is cleanall, which removes everything, as if the removal line was here
	    if (!$cleanall) {
		($grep, @output) = Llgal::Utils::system_with_output
		    ("check for caption removal line",
		     "grep", "-q", "$opts->{captions_removal_line}", "$self->{destination_dir}$self->{local_llgal_dir}/$_") ;
		if ($grep == -1) {
		    $messages->warning (@output) ;
		    die "Failed to execute 'grep' to check whether $self->{destination_dir}$self->{local_llgal_dir}/$_ has been modified ($!).\n" ;
		}
		$messages->warning (@output) ;
		# on other errors, assume file doesn't contain the caption removal line ($grep != 0)
	    }
	    if ($grep) {
		$messages->warning ("Preserved $self->{destination_dir}$self->{local_llgal_dir}/$_ since it seems to be modified.") ;
		$notdeleted++ ;
	    } else {
		if (!unlink "$self->{destination_dir}$self->{local_llgal_dir}/$_" and ! $!{ENOENT}) {
		    $messages->warning ("Failed to remove file $self->{destination_dir}$self->{local_llgal_dir}/$_.") ;
		}
	    }
	} else {
	    $notdeleted++ ;
	}
    }
    closedir DIR ;
    if ($notdeleted <= 2 and $cleanall) {
	if (!rmdir "$self->{destination_dir}$self->{local_llgal_dir}"  and ! $!{ENOENT}) {
	    $messages->warning ("Failed to remove directory $self->{destination_dir}$self->{local_llgal_dir} ($!).") ;
	}
    }

    opendir DIR, $self->{destination_dir} ? $self->{destination_dir} : "./" ; # destination is empty for './'
    while ($_ = readdir DIR ) {
	if (/^$opts->{index_filename}\.$opts->{www_extension}$/
	    or /^$opts->{slide_filenameprefix}.*\.$opts->{www_extension}$/) {
	    unlink "$self->{destination_dir}$_" ;
	}
    }
    closedir DIR ;
}

#####################################################################
# Main variables

# The main gallery is composed of
# - @entries (the entry list)
# - @headers and @footers

sub init_gallery {
    my $gallery = () ;
    @{$gallery->{headers}} = () ;
    @{$gallery->{footers}} = () ;
    @{$gallery->{entries}} = () ;
    %{$gallery->{user_fields}} = () ;
    return $gallery ;
}

# Entries are hashed composed of
# - type: see below
# - filename (original filename with extension)
# - url (url of the filename)
# - linktext (an associated text that may be used in a link, www-safe)
# - caption (the caption of the slide, www-safe)
# - title (title, www-safe)
# - no_thumb (1 or undef, means that the entry is listed instead of displayed as a thumbnail)
# - no_slide (1 or undef, means that the entry does not appear as any slide at all)

# - xdim, ydim, kbytes (details about the image or movie)
# - dimstring (string containing dimensions and/or size that were requested)

# - slide_filename (name of the HTML slide filename)
# - slide_url (url of the HTML slide filename)

# - thumb_xdim, thumb_ydim (details about the thumbnail image)
# - thumb_dimstring (string containing dimensions)
# - thumb_filename (name of the thumbnail image file)
# - thumb_url (url of the thumbnail image file)

# - scaled_xdim, scaled_ydim, scaled_kbytes (details about the scaled image)
# - scaled_dimstring (string containing dimensions and/or size that were requested)
# - scaled_filename (name of the scaled image file)
# - scaled_url (url of the scaled image file)

# - gallery (the whole gallery in the subdirectory pointed by this entry)

# types
my $TYPE_TEXT = 0 ;
my $TYPE_LINK = 1 ;
my $TYPE_IMAGE = 2 ;
my $TYPE_MOVIE = 3 ;
my $TYPE_FILE = 4 ;
my $TYPE_DIR = 5 ;
my $TYPE_LINE = 6 ;
my $TYPE_BREAK = 7 ;

###################################################################################
# checking files

sub check_file {
    my $filename = shift ;

    if (! -e $filename) {
	$messages->warning ("Cannot find file '$filename', skipping it.") ;
	return -1 ;
    }

    my $excluded = 0 ;
    for(my $i = 0; $i < @{$opts->{excludes}}; $i++) {
	my $entry = @{$opts->{excludes}}[$i] ;
	if ($filename =~ /^(.*\/)*$entry->{filter}$/) {
	    $excluded = $entry->{excluded}
	}
    }
    return -1
	if $excluded ;

    return 0 ;
}

sub check_image {
    my $filename = shift ;
    my ($status, @output) = Llgal::Utils::system_with_output
	( "check \"$filename\" validity",
	  "identify", $filename ) ;
    if ($status == -1) {
	$messages->warning (@output) ;
	die "Failed to check \"$filename\" validity\n" ;
    } elsif ($status) {
	# do not show actual identify output
	$messages->warning ("Bad image file '$filename', skipping it.") ;
	return -1 ;
    }
    return 0 ;
}

sub check_movie {
    # TODO
    return 0 ;
}

###################################################################################
# returns a filename that the user provided in the llgal directory
# to be used as a thumbnail or scaled image

sub find_user_thumbnail {
    my $entry = shift ;
    my $type = $entry->{type} ;
    my $filename = $entry->{filename} ;
    my $user_thumbnail_filename = "$opts->{user_thumbnail_image_filenameprefix}$opts->{thumbnail_image_filenameprefix}$filename" ;

    if ($type == $TYPE_IMAGE) {
	if (-f "$self->{destination_dir}$self->{local_llgal_dir}/$user_thumbnail_filename") {
	    return $user_thumbnail_filename ;
	}
    } else {
	foreach my $ext (split (/\|/, $opts->{image_extensions})) {
	    if (-f "$self->{destination_dir}$self->{local_llgal_dir}/$user_thumbnail_filename.$ext") {
		return "$user_thumbnail_filename.$ext" ;
	    }
	}
    }
    return "" ;
}

sub find_user_scaled {
    my $entry = shift ;
    my $type = $entry->{type} ;
    my $filename = $entry->{filename} ;
    my $user_scaled_filename = "$opts->{user_scaled_image_filenameprefix}$opts->{scaled_image_filenameprefix}$filename" ;

    if ($type == $TYPE_IMAGE) {
	if (-f "$self->{destination_dir}$self->{local_llgal_dir}/$user_scaled_filename") {
	    return $user_scaled_filename ;
	}
    } else {
	foreach my $ext (split (/\|/, $opts->{image_extensions})) {
	    if (-f "$self->{destination_dir}$self->{local_llgal_dir}/$user_scaled_filename.$ext") {
		return "$user_scaled_filename.$ext" ;
	    }
	}
    }
    return "" ;
}

###################################################################################
# extract caption from image infos

# Image comment
sub generate_caption_from_image_comment {
    my $exif_infos = shift ;
    my @texts = () ;
    # Loop until a non-empty comment list is found
    foreach my $types (split (/,/, $opts->{make_caption_from_image_comment})) {
	# types is a + separated string of types
	foreach my $type (split (/\+/, $types)) {
	    if ($type =~ /^std$/i) {
		# Standard comment such as JFIF or GIF
		my $comment = $exif_infos->{Comment} ;
		push (@texts, $comment)
		    if $comment ;
	    } elsif ($type =~ /^exif$/i) {
		# Exif comment
		my $comment = $exif_infos->{UserComment} ;
		push (@texts, $comment)
		    if $comment ;
	    } else {
		die "Unrecognized image comment type '$type'\n" ;
	    }
	}
	return @texts
	    if @texts ;
    }
    return () ;
}

# Image timestamp
sub generate_caption_from_image_timestamp {
    my $exif_infos = shift ;
    my $imagetime = $exif_infos->{DateTimeOriginal} ;
    return $imagetime;
}

# Image infos
sub generate_caption_from_image_infos {
    my $exif_infos = shift ;
    my @texts = () ;
    if ($opts->{make_caption_from_image_comment}) {
	my @comments = generate_caption_from_image_comment $exif_infos ;
	push (@texts, @comments) ;
    }
    if ($opts->{make_caption_from_image_timestamp}) {
	my $timestamp = generate_caption_from_image_timestamp $exif_infos ;
	push (@texts, $timestamp) ;
    }
    return @texts ;
}

###################################################################################
# generating safe url

sub make_safe_url_nowarn {
    return join '/', map { uri_escape $_ } (split /\//, shift) ;
}

sub make_safe_url {
    my $file = shift ;
    my $safe = make_safe_url_nowarn ($file) ;

    $messages->warning ("Non-ascii characters were escaped in filename '$file'.")
	if $safe ne $file and $file =~ /[\x80-\xFF]/ ;

    return $safe ;
}

###################################################################################
# Generate entries

sub create_file_entry {
    my $entry = () ;
    my $type = shift ;
    my $filename = shift ;
    my $linktext = shift ;
    my $caption = shift ;

    # check file
    return undef
	if check_file ("$self->{destination_dir}$filename") < 0 ;
    if ($type == $TYPE_IMAGE) {
	return undef
	    if check_image ("$self->{destination_dir}$filename") < 0 ;
    } elsif ($type == $TYPE_MOVIE) {
	return undef
	    if check_movie ("$self->{destination_dir}$filename") < 0 ;
    }

    # set the type
    $entry->{type} = $type ;

    # set the filename
    $entry->{filename} = $filename ;

    # make a safe url
    $entry->{url} = make_safe_url ($filename) ;

    # the link text (will be web-safe after caption file generation)
    if (not defined $linktext) {
	$linktext = "" ;
	if ($type == $TYPE_MOVIE) {
	    $linktext = $opts->{MVI_link_text}.$filename ;
	} elsif ($type == $TYPE_FILE) {
	    $linktext = $opts->{FIL_link_text}.$filename ;
	} elsif ($type == $TYPE_DIR) {
	    $linktext = $opts->{DIR_link_text}.$filename ;
	}
	$linktext =~ s/&/&amp;/g ;
#       $linktext =~ s/"/&\#34;/g ;
    }
    $entry->{linktext} = $linktext ;

    # for images, extract required exif infos
    if ($type == $TYPE_IMAGE) {
	my @exif_tags = () ;
	if (!$opts->{show_all_exif_tags}) {
	    @exif_tags = @{$opts->{show_exif_tags}} ;
	    @exif_tags = (@exif_tags, 'DateTimeOriginal')
		if $opts->{make_caption_from_image_timestamp} ;
	    @exif_tags = (@exif_tags, 'UserComment', 'Comment')
		if $opts->{make_caption_from_image_comment} ;
	}
	if (@exif_tags or $opts->{show_all_exif_tags}) {
	    if (not defined $opts->{exif_info}) {
		# ExifTool initialization
		$opts->{exiftool} = new Image::ExifTool;
		# Accept unknown tags, just in case...
		$opts->{exiftool}->Options(Unknown => 1) ;
		# DateFormat should be initialized with whatever the user said to --ctf
		$opts->{exiftool}->Options(DateFormat => $opts->{timestamp_format_in_caption}) ;
	    }
	    $entry->{exif_infos} = $opts->{exiftool}->ImageInfo ("$self->{destination_dir}$filename", @exif_tags) ;
	}
    }

    # the caption (will be web-safe after caption file generation)
    if (not defined $caption) {
	my @texts = () ;
	if ($opts->{make_caption_from_extension}) {
	    push (@texts, $filename) ;
	} elsif ($opts->{make_caption_from_filename}) {
	    # remove the extension
	    my @parts = split (/\./, $filename) ;
	    pop @parts ;
	    my $basename = join ('.', @parts) ;
	    push (@texts, $basename) ;
	}
	push (@texts, generate_caption_from_image_infos $entry->{exif_infos})
	    if $type == $TYPE_IMAGE ;
	$caption = join (' - ', grep {$_} @texts) ;
	$caption =~ s/&/&amp;/g ;
#	$caption =~ s/"/&\#34;/g ;
    }
    chomp $caption ;
    $entry->{caption} = $caption ;

    # title is based on the filename
    my $title = $filename ;
    $title =~ s/&/&amp;/g ;
#    $title =~ s/"/&\#34;/g ;

    # add caption to the title if asked
    $title .= ": ". $caption
	if $opts->{make_slide_title_from_caption} ;

    $entry->{title} = $title ;

    # do not generate more if we are only generating captions
    return $entry ;
}

sub fill_file_entry {
    my $entry = shift ;
    my $type = $entry->{type} ;
    my $filename = $entry->{filename} ;

    # keep real filename for later
    my $real_filename = "$self->{destination_dir}$filename" ;

    # xdim, ydim, kbytes of the image or movie
    if ($type == $TYPE_IMAGE) {
	my ($x,$y) = imgsize ("$self->{destination_dir}$filename") ;
	$entry->{xdim} = $x ;
	$entry->{ydim} = $y ;
	# initialize here so that we can use it even when scaled are not used
	$entry->{scaled_xdim} = $x ;
	$entry->{scaled_ydim} = $y ;
    }
    if ($type == $TYPE_IMAGE or $type == $TYPE_MOVIE or $type == $TYPE_FILE) {
	my $kbytes = (-s "$self->{destination_dir}$filename") >> 10 ;
	$entry->{kbytes} = $kbytes ;
	# initialize here so that we can use it even when scaled are not used
	$entry->{scaled_kbytes} = $kbytes ;
    }

    # dimstring
    if ($type == $TYPE_IMAGE) {
	if ($opts->{show_dimensions} and $opts->{show_size}) {
	    $entry->{dimstring} = "($entry->{xdim}x$entry->{ydim}, $entry->{kbytes}$opts->{show_size_unit})" ;
	} elsif ($opts->{show_size}) {
	    $entry->{dimstring} = "($entry->{kbytes}$opts->{show_size_unit})" ;
	} elsif ($opts->{show_dimensions}) {
	    $entry->{dimstring} = "($entry->{xdim}x$entry->{ydim})" ;
	} else {
	    $entry->{dimstring} = "" ;
	}
    } elsif ($type == $TYPE_MOVIE or $type == $TYPE_FILE) {
	if ($opts->{show_size}) {
	    $entry->{dimstring} = "($entry->{kbytes}$opts->{show_size_unit})" ;
	} else {
	    $entry->{dimstring} = "" ;
	}
    } else {
	$entry->{dimstring} = "" ;
    }

    # thumbnail, its url and dimensions
    my $thumb_filename = find_user_thumbnail ($entry) ;
    if ($thumb_filename) {
	# there's a user provided thumbnail, just use it

	$entry->{thumb_filename} = "$self->{local_llgal_dir}/$thumb_filename" ;
	$entry->{thumb_url} = "$local_llgal_url/". make_safe_url_nowarn ($thumb_filename) ;

	# thumbnails dimensions
	my ($x, $y) = imgsize ("$self->{destination_dir}$self->{local_llgal_dir}/$thumb_filename") ;
	if ($y > $opts->{thumbnail_height_max}) {
	    $x = $x * ($opts->{thumbnail_height_max} / $y) ;
	    $y = $opts->{thumbnail_height_max} ;
	}
	if ($opts->{thumbnail_width_max} > 0 and $x > $opts->{thumbnail_width_max}) {
	    $y = $y * ($opts->{thumbnail_width_max} / $x) ;
	    $x = $opts->{thumbnail_width_max} ;
	}

	($entry->{thumb_xdim},$entry->{thumb_ydim}) = ($x, $y) ;

	# dimstring
	if ($opts->{show_dimensions}) {
	    $entry->{thumb_dimstring} = "(${x}x${y})" ;
	} else {
	    $entry->{thumb_dimstring} = "" ;
	}

    } elsif ($type == $TYPE_IMAGE) {
	# no user provided thumbnail, generate one

	# filename and url
	$thumb_filename = "$opts->{thumbnail_image_filenameprefix}$filename" ;
	$thumb_filename =~ s/\//$opts->{path_separator_replacement}/g ;
	$entry->{thumb_filename} = "$self->{local_llgal_dir}/$thumb_filename" ;
	$entry->{thumb_url} = "$local_llgal_url/". make_safe_url_nowarn ($thumb_filename) ;

	# if the thumbnail does not exist, or is older than the image, or regeneration is forced
	my $real_thumb_filename = "$self->{destination_dir}$entry->{thumb_filename}" ;
	if ((! -e $real_thumb_filename)
	    or (-M $real_thumb_filename) > (-M $real_filename)
	    or $opts->{force_image_regeneration}) {
	    my ($status, @output) ;
	    # only scale down, never up.
	    my ($x,$y) = imgsize ($real_filename) ;
	    if ($y <= $opts->{thumbnail_height_max}
		and ($opts->{thumbnail_width_max} <= 0 or $x <= $opts->{thumbnail_width_max})) {
		# the original is not large enough, keep it
		$entry->{thumb_filename} = $entry->{filename} ;
		$entry->{thumb_url} = $entry->{url} ;
		$real_thumb_filename = $real_filename ;
	    } else {
		# scale down
		($status, @output) = Llgal::Utils::system_with_output
		    ( "create '$filename' thumbnail",
		      @{$opts->{thumbnail_create_command}}, $real_filename, $real_thumb_filename ) ;
		if ($status == -1) {
		    $messages->warning (@output) ;
		    die "Failed to create '$filename' thumbnail\n" ;
		} elsif ($status) {
		    $messages->warning ("Failed to create '$real_filename' thumbnail") ;
		    $messages->warning (@output) ;
		    return undef ;
		}
	    }
	}
	($entry->{thumb_xdim},$entry->{thumb_ydim}) = imgsize ($real_thumb_filename) ;

	# dimstring
	if ($opts->{show_dimensions}) {
	    $entry->{thumb_dimstring} = "($entry->{thumb_xdim}x$entry->{thumb_ydim})" ;
	} else {
	    $entry->{thumb_dimstring} = "" ;
	}

    } else {
	# default thumbnail dimensions
	$entry->{thumb_xdim} = $opts->{default_thumb_xdim} ;
	$entry->{thumb_ydim} = $opts->{default_thumb_ydim} ;

	# dimstring is empty
        $entry->{thumb_dimstring} = "" ;
    }

    if (!$opts->{make_no_slides}) {
	# scaled image, its url and dimensions

	my $scaled_filename = find_user_scaled ($entry) ;
	if ($scaled_filename) {
	    # there's a user provided scaled, just use it

	    $entry->{scaled_filename} = "$self->{local_llgal_dir}/$scaled_filename" ;
	    $entry->{scaled_url} = "$local_llgal_url/". make_safe_url_nowarn ($scaled_filename) ;

	    # thumbnails dimensions
	    my ($x, $y) = imgsize ("$self->{destination_dir}$self->{local_llgal_dir}/$scaled_filename") ;
	    if ($opts->{slide_height_max} > 0 and $y > $opts->{slide_height_max}) {
		$x = $x * ($opts->{slide_height_max} / $y) ;
		$y = $opts->{slide_height_max} ;
	    }
	    if ($opts->{slide_width_max} > 0 and $x > $opts->{slide_width_max}) {
		$y = $y * ($opts->{slide_width_max} / $x) ;
		$x = $opts->{slide_width_max} ;
	    }

	    ($entry->{scaled_xdim},$entry->{scaled_ydim}) = ($x, $y) ;
	    $entry->{scaled_kbytes} = (-s "$self->{destination_dir}$self->{local_llgal_dir}/$scaled_filename") >> 10 ;

	    # dimstring
	    if ($opts->{show_dimensions} and $opts->{show_size}) {
		$entry->{scaled_dimstring} = "($entry->{scaled_xdim}x$entry->{scaled_ydim}, $entry->{scaled_kbytes}$opts->{show_size_unit})" ;
	    } elsif ($opts->{show_size}) {
		$entry->{scaled_dimstring} = "($entry->{scaled_kbytes}$opts->{show_size_unit})" ;
	    } elsif ($opts->{show_dimensions}) {
		$entry->{scaled_dimstring} = "($entry->{scaled_xdim}x$entry->{scaled_ydim})" ;
	    } else {
		$entry->{scaled_dimstring} = "" ;
	    }

	} elsif ($type == $TYPE_IMAGE and ($opts->{slide_width_max} > 0 or $opts->{slide_height_max} > 0)) {
	    # no user provided scaled, generate one

	    # filename and url
	    $scaled_filename = "$opts->{scaled_image_filenameprefix}$filename" ;
	    $scaled_filename =~ s/\//$opts->{path_separator_replacement}/g ;
	    $entry->{scaled_filename} = "$self->{local_llgal_dir}/$scaled_filename" ;
	    $entry->{scaled_url} = "$local_llgal_url/". make_safe_url_nowarn ($scaled_filename) ;

	    # if the thumbnail does not exist, or is older than the image, or regeneration is forced
	    my $real_scaled_filename = "$self->{destination_dir}$entry->{scaled_filename}" ;
	    if ((! -e $real_scaled_filename)
		or (-M $real_scaled_filename) > (-M $real_filename)
		or $opts->{force_image_regeneration}) {
		my ($status, @output) ;
		# only scale down, never up.
		my ($x,$y) = imgsize ($real_filename) ;
		if (($opts->{slide_width_max} <= 0 or $x <= $opts->{slide_width_max})
		    and ($opts->{slide_height_max} <= 0 or $y <= $opts->{slide_height_max})) {
		    # the original is not large enough, keep it
		    $entry->{scaled_filename} = $entry->{filename} ;
		    $entry->{scaled_url} = $entry->{url} ;
		    $real_scaled_filename = $real_filename ;
		} else {
		    # scale down
		    ($status, @output) = Llgal::Utils::system_with_output
			( "create '$filename' scaled image",
			  @{$opts->{scaled_create_command}}, $real_filename, $real_scaled_filename ) ;
		    if ($status == -1) {
			$messages->warning (@output) ;
			die "Failed to create '$filename' scaled image\n" ;
		    } elsif ($status) {
			$messages->warning ("Failed to create '$real_filename' scaled image") ;
			$messages->warning (@output) ;
			return undef ;
		    }
		}
	    }
	    ($entry->{scaled_xdim},$entry->{scaled_ydim}) = imgsize ($real_scaled_filename) ;
	    $entry->{scaled_kbytes} = (-s $real_scaled_filename) >> 10 ;

	    # dimstring
	    if ($opts->{show_dimensions} and $opts->{show_size}) {
		$entry->{scaled_dimstring} = "($entry->{scaled_xdim}x$entry->{scaled_ydim}, $entry->{scaled_kbytes}$opts->{show_size_unit})" ;
	    } elsif ($opts->{show_size}) {
		$entry->{scaled_dimstring} = "($entry->{scaled_kbytes}$opts->{show_size_unit})" ;
	    } elsif ($opts->{show_dimensions}) {
		$entry->{scaled_dimstring} = "($entry->{scaled_xdim}x$entry->{scaled_ydim})" ;
	    } else {
		$entry->{scaled_dimstring} = "" ;
	    }

	} else {
	    $entry->{scaled_dimstring} = $entry->{dimstring} ;
	}
    }
    return $entry ;
}

sub create_nofile_entry {
    my $entry = () ;
    my $type = shift ;
    my $url = shift ;
    my $linktext = shift ;
    my $caption = shift ;

    # set the type
    $entry->{type} = $type ;

    # row break and horizontal lines need nothing
    if ($type == $TYPE_LINE or $type == $TYPE_BREAK) {
	$entry->{no_slide} = 1 ;
	$entry->{no_thumb} = 1 ;
	return $entry ;
    }

    # make a safe url
    if (defined $url) {
	$entry->{url} = make_safe_url ($url) ;
    }

    # the link text (will be web-safe after caption file generation)
    $entry->{linktext} = $linktext ;

    # the caption (will be web-safe after caption file generation)
    $caption = "" unless defined $caption ;
    $entry->{caption} = $caption ;

    # add caption to the title if asked
    my $title = "" ;
    $title = $caption
	if $opts->{make_slide_title_from_caption} ;
    $entry->{title} = $title ;

    # do not generate more if we are only generating captions
    return $entry ;
}

sub fill_nofile_entry {
    my $entry = shift ;

    # dimstring
    $entry->{dimstring} = "" ;

    # default thumbnail dimensions
    $entry->{thumb_xdim} = $opts->{default_thumb_xdim} ;
    $entry->{thumb_ydim} = $opts->{default_thumb_ydim} ;

    # dimstring is empty
    $entry->{thumb_dimstring} = "" ;

    if (!$opts->{make_no_slides}) {
	# scaled image dimensions
	$entry->{scaled_dimstring} = $entry->{dimstring} ;
    }
    return $entry ;
}

# fill entries, everything that's not required for
# captions generation, but may be done early
sub fill_entries {
    my $gallery = shift ;
    my @entries = @{$gallery->{entries}} ;
    my @final_entries = () ;

    $messages->print ("Preparing entries: ") ;
    $messages->init_percentage (scalar @entries) ;

    my $i = 0 ;
    for my $entry (@entries) {
	my $type = $entry->{type} ;
	my $final_entry ;
	if ($type == $TYPE_LINE or $type == $TYPE_BREAK) {
	    $final_entry = $entry ; # nothing to do
	} elsif ($type == $TYPE_TEXT or $type == $TYPE_LINK) {
	    $final_entry = fill_nofile_entry $entry ;
	} else {
	    $final_entry = fill_file_entry $entry ;
	}
	push @final_entries, $final_entry
	    if defined $final_entry ;
	$messages->update_percentage (($i++)+1) ;
    }
    $messages->end_percentage () ;

    @{$gallery->{entries}} = @final_entries ;
}

# generate slide number, filename and url only when the order of entries is fixed
sub finalize_entries {
    my $gallery = shift ;
    my $opts = shift ;

    my @entries = @{$gallery->{entries}} ;

    if ($opts->{list_links}) {
	map {
	    my $type = $_->{type} ;
	    if ($type == $TYPE_LINK or $type == $TYPE_DIR or $type == $TYPE_MOVIE or $type == $TYPE_FILE) {
		$_->{no_thumb} = 1 ;
		$_->{no_slide} = 1 ;
	    } elsif ($type == $TYPE_TEXT) {
		$_->{no_thumb} = 1 ;
	    }
	} @entries ;
    }

    # account slides
    my $nslides = scalar (grep { ! $_->{no_slide} } @entries) ;
    $gallery->{nslides} = $nslides ;

    # prepare numbering
    my $counter_length = length $nslides ;

    my $prev = undef ;
    my $first = undef ;
    my $indix = 0 ;
    for(my $i=0; $i < @entries; $i++) {
	my $entry = $entries[$i] ;

	# entries without a slide are not taken into account
	next if defined $entry->{no_slide} ;

	# slide counter
	$indix++;
	$entry->{counter} = $indix ;
	my $counter_with_zeros = sprintf "%0${counter_length}d", $indix ;
	$entry->{counter_with_zeros} = $counter_with_zeros ;

	my $type = $entry->{type} ;
	my $filename = $entry->{filename} ;

	# HTML slide and its url
	if (!$opts->{make_no_slides} and $type != $TYPE_LINE and $type != $TYPE_BREAK) {
	    my $slide_filename ;
	    if ($opts->{make_slide_filename_from_filename}) {
		if ($type == $TYPE_TEXT or $type == $TYPE_LINK) {
		    $slide_filename = "$opts->{slide_filenameprefix}$counter_with_zeros.$opts->{www_extension}" ;
		} elsif ($opts->{make_slide_filename_from_extension}) {
		    $slide_filename = "$opts->{slide_filenameprefix}$filename.$opts->{www_extension}" ;
		} else {
		    my @parts = split (/\./, $filename) ;
		    pop @parts ;
		    my $basename = join ('.', @parts) ;
		    $slide_filename = "$opts->{slide_filenameprefix}$basename.$opts->{www_extension}" ;
		}
	    } else {
		$slide_filename = "$opts->{slide_filenameprefix}$counter_with_zeros.$opts->{www_extension}" ;
	    }
	    $entry->{slide_filename} = $slide_filename ;
	    $entry->{slide_url} = make_safe_url_nowarn ($slide_filename) ;
	}

	# initialize to -1 for no link to prev/next slide
	$entry->{prev} = -1 ;
	$entry->{next} = -1 ;

	# link to previous entry
	if (defined $prev) {
	    $entry->{prev} = $prev;
	    $entries[$prev]->{next} = $i ;
	}
	$prev = $i ;

	# store first
	$first = $i unless defined $first ;
    }

    if (defined $first and $opts->{link_between_last_and_first_slide}) {
	# link last to first
	$entries[$prev]->{next} = $first ;
	$entries[$first]->{prev} = $prev ;
    }
}

#######################################################################
# Generating entry table from files in target directory

sub get_entries_from_directory {
    my $dir = shift ;
    my $dir_string = shift ;
    my $subdir = shift ;
    my $add_subdirs = shift ;
    my $add_others = shift ;
    my @entries = () ;

    opendir DIR, "$dir$subdir"
	or die "Can't open $dir_string$subdir ($!)\n" ;
    # get all files, except dot-starting ones and webpages
    my @filenames = map { "$subdir$_" } (grep ((!/\.$opts->{www_extension}$/i and !/^\./), readdir DIR)) ;
    closedir DIR ;

    # sort now so that slide numbering doesn't become wrong later
    if ($opts->{sort_criteria} eq "name") {
	@filenames = sort @filenames ;
    } elsif ($opts->{sort_criteria} eq "revname") {
	@filenames = sort { $b cmp $a } @filenames ;

    } elsif ($opts->{sort_criteria} eq "iname") {
	@filenames = sort { uc($a) cmp uc($b) } @filenames ;
    } elsif ($opts->{sort_criteria} eq "reviname") {
	@filenames = sort { uc($b) cmp uc($a) } @filenames ;

    } elsif ($opts->{sort_criteria} eq "date" or $opts->{sort_criteria} eq "time") {
	@filenames = sort { (-M $a) <=> (-M $b) } @filenames ;
    } elsif ($opts->{sort_criteria} eq "revdate" or $opts->{sort_criteria} eq "revtime") {
	@filenames = sort { (-M $b) <=> (-M $a) } @filenames ;

    } elsif ($opts->{sort_criteria} eq "size") {
	@filenames = sort { (-s $a) <=> (-s $b) } @filenames ;
    } elsif ($opts->{sort_criteria} eq "revsize") {
	@filenames = sort { (-s $b) <=> (-s $a) } @filenames ;

    } elsif ($opts->{sort_criteria} eq "none" or $opts->{sort_criteria} eq "") {
	# do not sort
    } else {
	die "Unknown sort criteria '$opts->{sort_criteria}'.\n" ;
    }

    $messages->print ("Listing entries".($subdir ? " in $subdir " : "").": ") ;
    $messages->init_percentage (scalar @filenames) ;

    for(my $i = 0; $i < @filenames; $i++) {
	my $filename = $filenames[$i] ;
	chomp $filename ;
	if (-d "$dir$filename") {
	    # directory
	    if ($add_subdirs) {
		my $entry = create_file_entry ($TYPE_DIR, $filename, undef, undef) ;
		push @entries, $entry
		    if defined $entry ;
	    }

	} else {
	    # file
	    my $entry = undef ;

	    if ($filename =~ /($opts->{image_extensions})$/i) {
		# image
		my $entry = create_file_entry ($TYPE_IMAGE, $filename, undef, undef) ;
		goto JUST_A_FILE
		    if not defined $entry ;
		push @entries, $entry ;

	    } elsif ($filename =~ /($opts->{movie_extensions})$/i) {
		# movie
		my $entry = create_file_entry ($TYPE_MOVIE, $filename, undef, undef) ;
		goto JUST_A_FILE
		    if not defined $entry ;
		push @entries, $entry ;

	    } else {
	      JUST_A_FILE:
		if ($add_others) {
		    # not an image, not a movie, just a file
		    my $entry = create_file_entry ($TYPE_FILE, $filename, undef, undef) ;
		    push @entries, $entry
			if defined $entry ;
		}
	    }
	}

	$messages->update_percentage ($i+1) ;
    }
    $messages->end_percentage () ;

    return @entries ;
}

sub get_entries {
    my $opts = shift ;
    my @entries = () ;
    my $dir = $self->{destination_dir} ? $self->{destination_dir} : "./" ; # destination is empty for './'
    if (defined $opts->{section_dirs} and @{$opts->{section_dirs}}) {
	foreach my $subdir (@{$opts->{section_dirs}}) {
	    # remove ending slashes
	    $subdir =~ s/\/*$//g ;
	    # separation line and title
	    push @entries, (create_nofile_entry $TYPE_LINE, undef, undef, undef)
		if $opts->{separate_sections} ;
	    push @entries, (create_nofile_entry $TYPE_TEXT, undef, $opts->{section_text}.$subdir, $opts->{section_text}.$subdir)
		if $opts->{entitle_sections} ;
	    # section entries
	    push @entries, get_entries_from_directory
		$dir,
		$destination_string,
		"$subdir/",
		($opts->{add_subdirs} or $opts->{recursive}),
		$opts->{add_all_files} ;
	}
    } else {
	@entries = get_entries_from_directory
	    $dir,
	    $destination_string,
	    "",
	    ($opts->{add_subdirs} or $opts->{recursive}),
	    $opts->{add_all_files} ;
    }
    return @entries ;
}

#######################################################################
# Check acces rights and create local subdirectory to place all llgal files

sub check_destination {

    # check destination
    die "Destination $self->{destination_dir} does not exist.\n"
	if ! -e $self->{destination_dir} ;
    die "Destination $self->{destination_dir} is not a directory.\n"
	if ! -d $self->{destination_dir} ;

    # cleanup destination
    # add a final /
    $self->{destination_dir} .= "/"
	unless $self->{destination_dir} =~ m@/$@ ;
    # remove starting ./
    $self->{destination_dir} =~ s/^(\.\/+)+// ;

    # Are we in .llgal ? just check the last part of the path by concatening
    # pwd and destination_dir even if destination_dir is an absolute path
    my $path = getcwd."/".$self->{destination_dir} ;
    if ($path =~ m@/*(?:[^/]+/+)*([^/]+)/+$@) {
	if ($1 eq $self->{local_llgal_dir}) {
	    $messages->warning ("!! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !!") ;
	    $messages->warning ("Your working directory looks like a .llgal directory. !!") ;
	    $messages->warning ("This might not be what you really want to do.         !!") ;
	    $messages->warning ("!! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !!") ;
	}
    }

    # TODO: remove this one day (maybe on march 7th 2006, since it will be 6 month ?)
    # temporary check, to be removed soon
    if ($self->{local_llgal_dir} ne ".llgal.files" and -e "$self->{destination_dir}.llgal.files") {
	$messages->warning ("!! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !!") ;
	$messages->warning ("llgal now uses '.llgal' instead '.llgal.files'. !!") ;
	$messages->warning ("You should probably update it.                  !!") ;
	$messages->warning ("!! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !!") ;
    }

    # create globals to factorize later
    $local_llgal_url = make_safe_url_nowarn ($self->{local_llgal_dir}) ;
}

sub setup_destination {

    # create globals to factorize later
    $destination_string = ($self->{destination_dir} ? "directory $self->{destination_dir}" : "current directory") ;

    # Create or check the local llgal directory
    if (! -e "$self->{destination_dir}$self->{local_llgal_dir}") {
	mkdir "$self->{destination_dir}$self->{local_llgal_dir}"
	    or die "Failed to create $self->{destination_dir}$self->{local_llgal_dir} directory ($!)" ;
    }
    die "Local llgal $self->{destination_dir}$self->{local_llgal_dir} is not a directory.\n"
	if ! -d "$self->{destination_dir}$self->{local_llgal_dir}" ;
}

#######################################################################
# Generate captions file

sub generate_captions_entries {
    my $opts = shift ;

    my @entries = get_entries $opts ;

    $messages->print ("Found ". (scalar @entries) ." entries in $destination_string\n") ;

    my @captions = () ;

    # store old values from the captions file, if it exists
    my $old_title ;

    my $old_parent_gallery_link = 0 ;
    my $old_parent_gallery_link_text ;

    my $old_prev_gallery_link = 0 ;
    my $old_prev_gallery_link_target ;
    my $old_prev_gallery_link_text ;

    my $old_next_gallery_link = 0 ;
    my $old_next_gallery_link_target ;
    my $old_next_gallery_link_text ;

    if (-e "$self->{destination_dir}$self->{local_llgal_dir}/$opts->{captions_filename}") {
	$messages->print ("Reading existing captions from $opts->{captions_filename}.\n") ;
	open (CAP, "$self->{destination_dir}$self->{local_llgal_dir}/$opts->{captions_filename}")
	    or die "Can't open $self->{destination_dir}$self->{local_llgal_dir}/$opts->{captions_filename} for reading\n" ;
	@captions = <CAP> ;
	close CAP ;

	foreach my $line (@captions) {
	    if ($line =~ /^TITLE:\s*(.*)\s*$/) {
		$old_title = $1 ;
	    } elsif ($line =~ /^PARENT:\s*(.*)\s*$/) {
		$old_parent_gallery_link = 1 ;
		$old_parent_gallery_link_text = $1 ;
	    } elsif ($line =~ /^PREV:\s*(.+)\s+----\s+(.+)\s*/) {
		$old_prev_gallery_link = 1 ;
		$old_prev_gallery_link_target = $2 ;
		$old_prev_gallery_link_text = $1 ;
	    } elsif ($line =~ /^NEXT:\s*(.+)\s+----\s+(.+)\s*/) {
		$old_next_gallery_link = 1 ;
		$old_next_gallery_link_target = $2 ;
		$old_next_gallery_link_text = $1 ;
	    }
	}

	$messages->print ("Appending new captions to $opts->{captions_filename}: ") ;
	open (CAP, ">>$self->{destination_dir}$self->{local_llgal_dir}/$opts->{captions_filename}")
	    or die "Can't open $self->{destination_dir}$self->{local_llgal_dir}/$opts->{captions_filename} file to append\n" ;

	print CAP "\n" ;
	print CAP "# Appended new captions (". (scalar localtime) .").\n" ;
	print CAP "\n" ;
    } else {
	$messages->print ("Creating the $opts->{captions_filename} file: ") ;
	open (CAP, ">$self->{destination_dir}$self->{local_llgal_dir}/$opts->{captions_filename}")
	    or die "Can't create $self->{destination_dir}$self->{local_llgal_dir}/$opts->{captions_filename} file\n" ;

	print CAP "# This is llgal's $opts->{captions_filename} file, first generated ", scalar localtime, ".\n" ;
	if (open CAPHEADER, "$self->{llgal_share_dir}/$opts->{captions_header_filename}") {
	    while (my $line = <CAPHEADER>) { print CAP $line ; }
	    close CAPHEADER ;
	} else {
	    $messages->warning ("Failed to open $opts->{captions_header_filename}\n") ;
	}
	print CAP "# $opts->{captions_removal_line}\n" ;
	print CAP "\n" ;
    }

    print CAP "TITLE: $opts->{index_title}\n"
	if !defined $old_title
	    or $old_title ne $opts->{index_title} ;
    print CAP "PARENT: $opts->{parent_gallery_link_text}\n"
	if $opts->{parent_gallery_link} and
	    ( !$old_parent_gallery_link
	    or $old_parent_gallery_link_text ne $opts->{parent_gallery_link_text} ) ;
    print CAP "PREV: $opts->{prev_gallery_link_text} ---- $opts->{prev_gallery_link_target}\n"
	if $opts->{prev_gallery_link} and
	    ( !$old_prev_gallery_link
	    or $old_prev_gallery_link_target ne $opts->{prev_gallery_link_target}
	    or $old_prev_gallery_link_text ne $opts->{prev_gallery_link_text} ) ;
    print CAP "NEXT: $opts->{next_gallery_link_text} ---- $opts->{next_gallery_link_target}\n"
	if $opts->{next_gallery_link} and
	    ( !$old_next_gallery_link
	    or $old_next_gallery_link_target ne $opts->{next_gallery_link_target}
	    or $old_next_gallery_link_text ne $opts->{next_gallery_link_text} ) ;
    print CAP "\n" ;

    $messages->init_percentage (scalar @entries) ;

    for (my $i = 0; $i < @entries; $i++) {
	my $entry = $entries[$i] ;
	my $type = $entry->{type} ;
	if ($type == $TYPE_IMAGE) {
	    print CAP "IMG: ". $entry->{filename}
		." ---- ". $entry->{caption} ."\n"
		unless grep { $captions[$_] =~ m/^(\s*IMG:)?\s*$entry->{filename}\s+----\s/ }
		    ( 0 .. $#captions ) ;

	} elsif ($type == $TYPE_MOVIE) {
	    print CAP "MVI: " . $entry->{filename}
		." ---- ". $entry->{linktext}
		." ---- ". $entry->{caption} ."\n"
		unless grep { $captions[$_] =~ m/^\s*MVI:\s*$entry->{filename}\s+----\s/ }
		    ( 0 .. $#captions ) ;

	} elsif ($type == $TYPE_FILE) {
	    print CAP "FIL: " . $entry->{filename}
		." ---- ". $entry->{linktext}
		." ---- ". $entry->{caption} ."\n"
		unless grep { $captions[$_] =~ m/^\s*FIL:\s*$entry->{filename}\s+----\s/ }
		    ( 0 .. $#captions ) ;

	} elsif ($type == $TYPE_DIR) {
	    print CAP "DIR: " . $entry->{filename}
		." ---- ". $entry->{linktext}
		." ---- ". $entry->{caption} ."\n"
		unless grep { $captions[$_] =~ m/^\s*DIR:\s*$entry->{filename}\s+----\s/ }
		    ( 0 .. $#captions ) ;

	} elsif ($type == $TYPE_TEXT) {
	    # TODO: do not insert again ? (in case of --Ps)
	    print CAP "TXT: " . $entry->{linktext} ." ---- ". $entry->{caption} ."\n";

	} elsif ($type == $TYPE_LINE) {
	    print CAP "LINE\n" ;

	} elsif ($type == $TYPE_BREAK) {
	    print CAP "BREAK\n" ;

	} else {
	    die "Unrecognized entry type $type.\n" ;
	}

	$messages->update_percentage ($i+1) ;
    }

    $messages->end_percentage () ;

    close CAP ;

    return @entries ;
}

#######################################################################
# Read entry list in the captions file

sub read_captions_file {
    my $gallery = shift ;
    my @entries = () ;
    my @headers = () ;
    my @footers = () ;
    my $user_fields = () ;

    $messages->print ("Reading entries in the $opts->{captions_filename} file: ") ;

    open(CAP,"$self->{destination_dir}$self->{local_llgal_dir}/$opts->{captions_filename}")
	or die "Can't open $self->{destination_dir}$self->{local_llgal_dir}/$opts->{captions_filename} file\n" ;

    my $size = (-s CAP) ;
    $messages->init_percentage ($size) ;

    my $line ;
    while (defined ($line = <CAP>)) {
	chomp $line ;
	$line =~ s/^\s*// ;
	$line =~ s/\s\(\s*\)$/$1/ ;
	# only lines that don't start with # and are not empty
	if (!($line =~ m/^\#/) and !($line =~ /^$/)) {
	    if ($line =~ m/^TITLE:\s*(.*)\s*/) {
		# title
		$opts->{index_title} = $1 ;

	    } elsif ($line =~ m/^INDEXHEAD:\s*(.*)\s*$/) {
		# header for the index
		push @headers, $1 ;

	    } elsif ($line =~ m/^INDEXFOOT:\s*(.*)\s*$/) {
		# footer for the index
		push @footers, $1 ;

# TODO move these to $gallery
	    } elsif ($line =~ m/^PARENT:\s*(.*)\s*$/) {
		# parent gallery link label
		$opts->{parent_gallery_link} = 1 ;
		$opts->{parent_gallery_link_text} = $1 ;

	    } elsif ($line =~ m/^PREV:\s*(.*)\s+----\s+(.*)\s*$/) {
		# prev gallery link label
		$opts->{prev_gallery_link_text} = $1 ;
		$opts->{prev_gallery_link} = $2 ;

	    } elsif ($line =~ m/^NEXT:\s*(.*)\s+----\s+(.*)\s*$/) {
		# next gallery link label
		$opts->{next_gallery_link_text} = $1 ;
		$opts->{next_gallery_link} = $2 ;

	    } elsif ($line =~ m/^REPLACE:\s*(.+)\s+----\s+(.*)\s*$/) {
		# replacing
		$user_fields->{$1} = $2 ;

	    } else {
		# that's a slide, create its entry
		my $entry ;
		# flexibility:
		# - the last \s might be omitted when there's no caption
		# - \s is facultative after TYP: at the begining
		if ($line =~ m/^TXT:\s*(.+)\s+----\s*(?:\s(.*))?\s*$/) {
		    # text slide
		    $entry = create_nofile_entry ($TYPE_TEXT, undef, $1, $2) ;

		} elsif ($line =~ m/^LNK:\s*(.+)\s+----\s+(.+)\s+----\s*(?:\s(.*))?\s*$/) {
		    # link slide
		    $entry = create_nofile_entry ($TYPE_LINK, $1, $2, $3) ;

		} elsif ($line =~ m/^DIR:\s*(.+)\s+----\s+(.+)\s+----\s*(?:\s(.*))?\s*$/) {
		    # directory slide
		    $entry = create_file_entry ($TYPE_DIR, $1, $2, $3) ;

		} elsif ($line =~ m/^MVI:\s*(.+)\s+----\s+(.+)\s+----\s*(?:\s(.*))?\s*$/) {
		    # movie slide
		    $entry = create_file_entry ($TYPE_MOVIE, $1, $2, $3) ;

		} elsif ($line =~ m/^FIL:\s*(.+)\s+----\s+(.+)\s+----\s*(?:\s(.*))?\s*$/) {
		    # movie slide
		    $entry = create_file_entry ($TYPE_FILE, $1, $2, $3) ;

		} elsif ($line =~ m/^LINE/) {
		    # horizontal line
		    $entry = create_nofile_entry ($TYPE_LINE, undef, undef, undef) ;

		} elsif ($line =~ m/^BREAK/) {
		    # thumbnail row break
		    $entry = create_nofile_entry ($TYPE_BREAK, undef, undef, undef) ;

		} elsif ($line =~ m/^IMG:\s*(.+)\s+----\s*(?:\s(.*))?\s*$/
			 or $line =~ m/^(.+)\s+----\s*(?:\s(.*))?\s*$/) {
		    # image slide (default)
		    $entry = create_file_entry ($TYPE_IMAGE, $1, undef, $2) ;

		} else {
		    die "Unrecognized line #$. in captions file: \"$line\"\n" ;
		}

		# really add this entry
		push @entries, $entry
		    if defined $entry ;
	    }
	}
	$messages->update_percentage (tell CAP) ;
    }
    close CAP ;
    $messages->end_percentage () ;

    @{$gallery->{entries}} = @entries ;
    @{$gallery->{headers}} = @headers ;
    @{$gallery->{footers}} = @footers ;
    $gallery->{user_fields} = $user_fields ;
}

#######################################################################
# Add recursion header and footer

sub add_headers_footers {
    my $gallery = shift ;
    my @headers = @{$gallery->{headers}} ;
    my @footers = @{$gallery->{footers}} ;

    # parent, prev and next, in reverse order
    unshift @headers, "<div style=\"text-align: right;\"><a href=\"$opts->{next_gallery_link_target}\">$opts->{next_gallery_link_text}$opts->{next_gallery_link_target}</a></div>"
	if $opts->{next_gallery_link} ;
    unshift @headers, "<a href=\"$opts->{prev_gallery_link_target}\">$opts->{prev_gallery_link_text}$opts->{prev_gallery_link_target}</a>"
	if $opts->{prev_gallery_link} ;
    unshift @headers, "<a href=\"..\">$opts->{parent_gallery_link_text}</a>"
	if $opts->{parent_gallery_link} ;

    # prev, next and parent
    push @footers, "<a href=\"$opts->{prev_gallery_link_target}\">$opts->{prev_gallery_link_text}$opts->{prev_gallery_link_target}</a>"
	if $opts->{prev_gallery_link} ;
    push @footers, "<div style=\"text-align: right;\"><a href=\"$opts->{next_gallery_link_target}\">$opts->{next_gallery_link_text}$opts->{next_gallery_link_target}</a></div>"
	if $opts->{next_gallery_link} ;
    push @footers, "<a href=\"..\">$opts->{parent_gallery_link_text}</a>"
	if $opts->{parent_gallery_link} ;

    @{$gallery->{headers}} = @headers ;
    @{$gallery->{footers}} = @footers ;
}

#######################################################################
# Precompute common fields to be inserted in the HTML pages

sub precompute_common_html_fields
{
    my $gallery = shift ;
    my @entries = @{$gallery->{entries}} ;
    my $common_fields = () ;

    # index title
    $common_fields->{"<!--TITLE-->"} = $opts->{index_title} ;

    # index link text
    $common_fields->{"<!--INDEX-LINK-TEXT-->"} = $opts->{index_link_text} ;
    if ($opts->{index_link_image}) {
	if ($opts->{index_link_image_location}) {
	    $common_fields->{"<!--INDEX-LINK-TEXT-->"} = "<img src=\"$opts->{index_link_image_location}\" "
		."alt=\"$opts->{index_link_text}\" "
		."class=\"image-link\" />" ;
	} else {
	    $common_fields->{"<!--INDEX-LINK-TEXT-->"} = "<img src=\"$self->{local_llgal_dir}/"
		. (make_safe_url $opts->{index_link_image_filename}) ."\" "
		."alt=\"$opts->{index_link_text}\" class=\"image-link\" />" ;
	}
    }

    # index file
    $common_fields->{"<!--INDEX-FILE-->"} = "$opts->{index_filename}.$opts->{www_extension}\" title=\"$opts->{over_index_link_text}" ;

    # css
    $common_fields->{"<!--CSS-->"} = "$self->{local_llgal_dir}/$opts->{css_filename}" ;
    if ($opts->{css_location}) {
	$common_fields->{"<!-- CSS -->"} = $opts->{css_location} ;
    }

    # codeset
    $common_fields->{"LLGAL-CODESET"} = $opts->{codeset} ;

    # command line
    $common_fields->{"LLGAL-OPTIONS"} = join " ", @llgal_options ;

    # credits text
    $common_fields->{"<!--CREDITS-->"} = $opts->{credits_text} ;

    $gallery->{common_fields} = $common_fields ;
}

#######################################################################
# Create the individual slide show files

sub generate_slides {
    my $gallery = shift ;
    my @entries = @{$gallery->{entries}} ;

    # remove old webpages
    system ("rm -f $self->{destination_dir}$opts->{slide_filenameprefix}*.$opts->{www_extension}") ;
    die "Failed to remove existing webpages.\n"
	if $? ;

    # find the slidetemplate
    my $slidetemplate = (Llgal::Templates::find_template_file ($self, $opts, $opts->{slidetemplate_filename}, 1))
	. "/$opts->{slidetemplate_filename}" ;
    $messages->print ("Using '$slidetemplate' as HTML slide template.\n") ;

    # keep the slidetemplate in memory instead of always reopening it
    my @slidetemplate_text ;
    open(SR,"$slidetemplate")
	or die "Can't open the slide template file '$slidetemplate'\n" ;
    @slidetemplate_text = <SR> ;
    close SR ;

    # create slides
    $messages->print ("Creating individual slides: ") ;
    $messages->init_percentage (scalar @entries) ;

    for (my $i = 0; $i < @entries; $i++) {
	my $entry = $entries[$i] ;

	next if defined $entry->{no_slide} ;

	open(SW, ">$self->{destination_dir}$entry->{slide_filename}")
	    or die "Can't create slide file\n" ;
	my $type = $entry->{type} ;

	##############################
	# Precompute all fields first

	# titles
	my $SLIDE_TITLE = $entry->{title} ;

	# this style contents and style
	my $THIS_SLIDE_STYLE = "image-slide" ;
	$THIS_SLIDE_STYLE = "text-slide\" style=\"width: $opts->{text_slide_width}px; height: $opts->{text_slide_height}px;"
	    if !$entry->{scaled_url} ;
	my $THIS_SLIDE ;
	if ($type == $TYPE_IMAGE) {
	    # image slide

	    if (defined $entry->{scaled_filename}) {
		# scaled image with link to the real image
		$THIS_SLIDE = "<a href=\"$entry->{url}\" "
		    ."title=\"$opts->{over_scaled_text}$entry->{title} $entry->{dimstring}\">" ;
		$THIS_SLIDE .= "<img src=\"$entry->{scaled_url}\" "
		    ."style=\"width: $entry->{scaled_xdim}px; height: $entry->{scaled_ydim}px;\" "
		    ."alt=\"$opts->{alt_scaled_text}$entry->{title} $entry->{scaled_dimstring}\" />" ;
		$THIS_SLIDE .= "</a>" ;

	    } else {
		# real image
		$THIS_SLIDE = "<img src=\"$entry->{url}\" "
		    ."style=\"width: $entry->{scaled_xdim}px; height: $entry->{scaled_ydim}px;\" "
		    ."alt=\"$opts->{alt_full_text}$entry->{title} $entry->{dimstring}\" "
		    ."title=\"$entry->{title} $entry->{dimstring}\" />" ;

	    }
	} elsif ($entry->{scaled_url}) {
	    # another type, with a user-given scaled image
	    if ($type == $TYPE_TEXT) {
		# text with scaled image ? ok...
		$THIS_SLIDE = "<img src=\"$entry->{scaled_url}\" "
		    ."style=\"width: $entry->{scaled_xdim}px; height: $entry->{scaled_ydim}px;\" "
		    ."title=\"$entry->{title} $entry->{dimstring}\" "
		    ."alt=\"$entry->{linktext} $entry->{scaled_dimstring}\" />" ;

	    } else {
		# another type with scaled image linking to the target
		$THIS_SLIDE = "<a href=\"$entry->{url}\" "
		    ."title=\"$entry->{title} $entry->{dimstring}\">" ;
		$THIS_SLIDE .= "<img src=\"$entry->{scaled_url}\" "
		    ."style=\"width: $entry->{scaled_xdim}px; height: $entry->{scaled_ydim}px;\" "
		    ."alt=\"$entry->{linktext} $entry->{scaled_dimstring}\" />" ;
		$THIS_SLIDE .= "</a>" ;
	    }

	} elsif ($type == $TYPE_TEXT) {
	    # text slide
	    $THIS_SLIDE = $entry->{linktext} ;
	} else {
	    # link-style slide
	    $THIS_SLIDE = "<a href=\"$entry->{url}\" title=\"$entry->{title} $entry->{dimstring}\">$entry->{linktext}</a>" ;
	}

	# slide counter
	my $slide_counter = $opts->{slide_counter_format} ;
	$slide_counter =~ s/%n/$entry->{counter}/ ;
	$slide_counter =~ s/%0n/$entry->{counter_with_zeros}/ ;
	$slide_counter =~ s/%t/$gallery->{nslides}/ ;
	# caption
	my $IMAGE_CAPTION = $entry->{caption} . $slide_counter . "&nbsp;&nbsp;&nbsp;$entry->{dimstring}" ;

	# previous slide
	my $PREV_SLIDE_LINK_TEXT = "" ;
	my $PREV_SLIDE = "" ;
	if ($entry->{prev} != -1) {
	    my $prev = $entries[$entry->{prev}] ;
	    if ($opts->{prev_slide_link_preview} and $prev->{thumb_url}) {
		$PREV_SLIDE_LINK_TEXT = "<img src=\"$prev->{thumb_url}\" "
		    ."style=\"width: $prev->{thumb_xdim}px; height: $prev->{thumb_ydim}px;\" "
		    ."alt=\"$opts->{prev_slide_link_text}\" />" ;
	    } elsif ($opts->{prev_slide_link_image}) {
		if ($opts->{prev_slide_link_image_location}) {
		    $PREV_SLIDE_LINK_TEXT = "<img src=\"$opts->{prev_slide_link_image_location}\" "
			."alt=\"$opts->{prev_slide_link_text}\" class=\"image-link\" />" ;
		} else {
		    $PREV_SLIDE_LINK_TEXT = "<img src=\"$self->{local_llgal_dir}/". (make_safe_url $opts->{prev_slide_link_image_filename}) ."\" "
			."alt=\"$opts->{prev_slide_link_text}\" class=\"image-link\" />" ;
		}
	    } else {
		$PREV_SLIDE_LINK_TEXT = $opts->{prev_slide_link_text} ;
	    }
	    $PREV_SLIDE = "$prev->{slide_url}\" title=\"$opts->{over_prev_slide_link_text}$prev->{title}" ;
	}

	# next slide
	my $NEXT_SLIDE_LINK_TEXT = "" ;
	my $NEXT_SLIDE = "" ;
	if ($entry->{next} != -1) {
	    my $next = $entries[$entry->{next}] ;
	    if ($opts->{next_slide_link_preview} and $next->{thumb_url}) {
		$NEXT_SLIDE_LINK_TEXT = "<img src=\"$next->{thumb_url}\" "
		    ."style=\"width: $next->{thumb_xdim}px; height: $next->{thumb_ydim}px;\" "
		    ."alt=\"$opts->{next_slide_link_text}\" />" ;
	    } elsif ($opts->{next_slide_link_image}) {
		if ($opts->{next_slide_link_image_location}) {
		    $NEXT_SLIDE_LINK_TEXT = "<img src=\"". $opts->{next_slide_link_image_location} ."\" "
			."alt=\"$opts->{next_slide_link_text}\" class=\"image-link\" />" ;
		} else {
		    $NEXT_SLIDE_LINK_TEXT = "<img src=\"$self->{local_llgal_dir}/". (make_safe_url $opts->{next_slide_link_image_filename}) ."\" "
			."alt=\"$opts->{next_slide_link_text}\" class=\"image-link\" />" ;
		}
	    } else {
		$NEXT_SLIDE_LINK_TEXT = $opts->{next_slide_link_text} ;
	    }
	    $NEXT_SLIDE = "$next->{slide_url}\" title=\"$opts->{over_next_slide_link_text}$next->{title}" ;
	}

	# exif information
	my $EXIF_TABLE = "" ;
	if ($type == $TYPE_IMAGE
	    and (@{$opts->{show_exif_tags}} or $opts->{show_all_exif_tags})) {
	    my $exif_infos = $entry->{exif_infos} ;
	    foreach my $tag ($opts->{show_all_exif_tags} ? (keys %{$exif_infos}) : @{$opts->{show_exif_tags}}) {
		my $value = $exif_infos->{$tag} ;
		my $description = $opts->{exiftool}->GetDescription ($tag) ;
		$EXIF_TABLE .= "<tr><td class=\"exif-name\">$description</td>"
		    ."<td class=\"exif-value\">$value</td></tr>\n"
		    if defined $value ;
	    }
	    $EXIF_TABLE = "<table class=\"exif\">\n". $EXIF_TABLE ."</table>" ;
	}

	#################################
	# Replace fields in the template

	my @slidetemplate_text_copy = @slidetemplate_text ; # don't touch the original template
        for my $line (@slidetemplate_text_copy) {

	    # user-defined fields
	    my $user_fields = $gallery->{user_fields} ;
	    foreach my $field (keys %{$user_fields}) {
		$line =~ s/$field/$user_fields->{$field}/g ;
	    }

	    # common fields
	    my $common_fields = $gallery->{common_fields} ;
	    foreach my $field (keys %{$common_fields}) {
		$line =~ s/$field/$common_fields->{$field}/g ;
	    }

	    # slide specific fields
	    $line =~ s/<!--SLIDE-TITLE-->/$SLIDE_TITLE/g ;
	    $line =~ s/<!--THIS-SLIDE-STYLE-->/$THIS_SLIDE_STYLE/g ;
	    $line =~ s/<!--THIS-SLIDE-->/$THIS_SLIDE/ ;
	    $line =~ s/<!--IMAGE-CAPTION-->/$IMAGE_CAPTION/g ;
	    $line =~ s/<!--PREV-SLIDE-LINK-TEXT-->/$PREV_SLIDE_LINK_TEXT/g ;
	    $line =~ s/<!--PREV-SLIDE-->/$PREV_SLIDE/g ;
	    $line =~ s/<!--NEXT-SLIDE-LINK-TEXT-->/$NEXT_SLIDE_LINK_TEXT/g ;
	    $line =~ s/<!--NEXT-SLIDE-->/$NEXT_SLIDE/g ;
	    $line =~ s/<!--EXIF-TABLE-->/$EXIF_TABLE/ ;

	    # output the line
	    print SW "$line" ;
	}
	close SW ;
	$messages->update_percentage ($i+1) ;
    }
    $messages->end_percentage () ;
}


#######################################################################
# Creating the index file

sub generate_index {
    my $gallery = shift ;
    my @entries = @{$gallery->{entries}} ;
    my @headers = @{$gallery->{headers}} ;
    my @footers = @{$gallery->{footers}} ;

    # find the indextemplate
    my $indextemplate = (Llgal::Templates::find_template_file ($self, $opts, $opts->{indextemplate_filename}, 1))
	. "/$opts->{indextemplate_filename}" ;
    $messages->print ("Using '$indextemplate' as HTML index template.\n") ;

    # open the template and the destination
    $messages->print ("Creating the $opts->{index_filename}.$opts->{www_extension} file: ") ;
    open(IXR, "$indextemplate")
	or die "Can't open the index template file '$indextemplate'\n" ;
    open(IXW, ">$self->{destination_dir}$opts->{index_filename}.$opts->{www_extension}")
	or die "Can't create main $opts->{index_filename}.$opts->{www_extension} file\n" ;

    # headers
    my $line ;
    while (defined($line = <IXR>)) {

	# stop at <!-- ********** -->
	last if $line =~ m/\*{10}/ ;

	if ($line =~ m/<!--HEADERS-->/) {
	    foreach my $header (@headers) {
		print IXW "    <div class=\"header\">" . $header . "</div>\n" ;
	    }
	} else {
	    # user-defined fields
	    my $user_fields = $gallery->{user_fields} ;
	    foreach my $field (keys %{$user_fields}) {
		$line =~ s/$field/$user_fields->{$field}/g ;
	    }

	    # common fields
	    my $common_fields = $gallery->{common_fields} ;
	    foreach my $field (keys %{$common_fields}) {
		$line =~ s/$field/$common_fields->{$field}/g ;
	    }

	    print IXW "$line" ;
	}
    }
    print IXW "\n" ;

    # output thumbnails
    my $forced_width_warning = 0 ;
    my $i = 0 ;
    $messages->init_percentage (scalar @entries) ;

    while ($i < scalar @entries) {
	my $entry = $entries[$i] ;
	my $type = $entry->{type} ;

	if ($type == $TYPE_LINE or $type == $TYPE_BREAK) {
	    if ($type == $TYPE_LINE) {
		# output a horizontal line
		print IXW "<hr class=\"index\">" ;
	    }
	    # next line, next entry
	    $messages->update_percentage ($i+1) ;
	    $i++ ;
	    next ;
	}

	if ($entry->{no_thumb}) {
	    # output a line with this text
	    print IXW "<div class=\"header\">" ;
	    if ($type == $TYPE_TEXT) {
		print IXW $entry->{linktext} ;
	    } else {
		print IXW "<a href=\"$entry->{url}\" title=\"$entry->{title} $entry->{dimstring}\">$entry->{linktext}</a>" ;
	    }
	    print IXW "</div>\n" ;
	    # next line, next entry
	    $messages->update_percentage ($i+1) ;
	    $i++ ;
	    next ;
	}

	# output a row of thumbnail
	my $width = $entries[$i]->{thumb_xdim} + $opts->{index_cellpadding} ;
	my $num = 1 ;
	# figure out how many entries to put on this row
	while ($i + $num < @entries) {
	    # stop if this is listed instead of having a slide
	    last if defined $entries[$i+$num]->{no_thumb} ;
	    # stop if there's too much thumbnail on this row
	    last if $opts->{thumbnails_per_row}
	    and $num + 1 > $opts->{thumbnails_per_row} ;
	    # stop if these thumbnail are too large
	    last if $opts->{pixels_per_row}
	    and $width + $entries[$i+$num]->{thumb_xdim} + $opts->{index_cellpadding} > $opts->{pixels_per_row} ;
	    # compute the new num and width
	    $width += $entries[$i+$num]->{thumb_xdim} + $opts->{index_cellpadding} ;
	    $num++ ;
	}
	# check whether a single thumbnail was already too large
	if ($opts->{pixels_per_row} > 0 and $width > $opts->{pixels_per_row}) {
	    $forced_width_warning++ ;
	}

	# Table header
	if ($opts->{show_no_film_effect}) {
	    print IXW "<table class=\"index\" style=\"border-spacing: ", $opts->{index_cellpadding}, "px 0px;\">\n" ;
	} else {
	    print IXW "<table class=\"index with-tile\" style=\"border-spacing: ", $opts->{index_cellpadding}, "px 0px;\">\n" ;
	}

	# Row header
	# include the image to force the height of the line. we could do it in the css but IE css support sucks a lot
	print IXW "  <tr><td class=\"tiled\" colspan=\"", $num+2, "\"><img src=\"$self->{local_llgal_dir}/$opts->{filmtile_filename}\" /></td></tr>\n"
	    unless $opts->{show_no_film_effect} ;
	print IXW "  <tr>\n" ;
	print IXW "    <td class=\"thumb\">&nbsp;</td>\n"
	    unless $opts->{show_no_film_effect} ;

	# Actual row of thumbnails
	for (my $j = 0; $j < $num; $j++) {
	    my $entry = $entries[$i+$j] ;
	    my $type = $entry->{type} ;
	    my $title = $entry->{title} ;
	    my $thumb_width = $entry->{thumb_xdim} ;
	    my $thumb_height = $entry->{thumb_ydim} ;
	    my $box_width = $thumb_width;
	    my $box_height = $thumb_height;

	    # if a thumbnail width max is defined, force the box to its width
	    $box_width = $opts->{thumbnail_width_max} if $opts->{thumbnail_width_max} ;

	    if ($type == $TYPE_IMAGE) {
		# IMG thumbnail

		print IXW "    <td class=\"thumb\" style=\"width: ${box_width}px; height: ${box_height}px;\">\n" ;
		if ($opts->{make_no_slides}) {
		    print IXW "      <a href=\"$entry->{url}\"" ;
		} else {
		    print IXW "      <a href=\"$entry->{slide_url}\"" ;
		}
		print IXW " title=\"$opts->{over_thumbnail_text}$title $entry->{scaled_dimstring}\">\n" ;
		print IXW "        <img src=\"$entry->{thumb_url}\" "
			."style=\"width: ${thumb_width}px; height: ${thumb_height}px;\" "
			."alt=\"$opts->{alt_thumbnail_text}$title $entry->{thumb_dimstring}\" />\n" ;
		print IXW "      </a>\n" ;
		print IXW "    </td>\n" ;

	    } elsif ($entry->{thumb_url}) {
		# not IMG, but with a user-given thumbnail

		print IXW "    <td class=\"thumb\" style=\"width: ${box_width}px; height: ${box_height}px;\">\n" ;
		if ($type == $TYPE_TEXT) {
		    # TXT with a thumbnail ? ok...
		    if ($opts->{make_no_slides}) {
			# thumbnail linking to the TXT slide
			print IXW "      <a href=\"$entry->{slide_url}\" "
				."title=\"$title $entry->{scaled_dimstring}\">\n" ;
			print IXW "        <img src=\"$entry->{thumb_url}\" "
				."style=\"width: ${thumb_width}px; height: ${thumb_height}px;\" "
				."alt=\"$entry->{linktext} $entry->{thumb_dimstring}\" />\n" ;
			print IXW "      </a>" ;

		    } else {
			# thumbnail without any link
			print IXW "      <img src=\"$entry->{thumb_url}\" "
				."title=\"$title $entry->{scaled_dimstring}\" "
				."style=\"width: ${thumb_width}px; height: ${thumb_height}px;\" "
				."alt=\"$entry->{linktext} $entry->{thumb_dimstring}\" />\n" ;
		    }
		} else {
		    # other types directly link to the target instead of the slide
		    print IXW "      <a href=\"$entry->{url}\" "
		    	."title=\"$title $entry->{scaled_dimstring}\">\n" ;
		    print IXW "        <img src=\"$entry->{thumb_url}\" "
			."style=\"width: ${thumb_width}px; height: ${thumb_height}px;\" "
			."alt=\"$entry->{linktext} $entry->{thumb_dimstring}\" />\n" ;
		    print IXW "      </a>\n" ;
		}
		print IXW "    </td>\n" ;
	    } else {
		# not IMG, without thumbnail
		print IXW "    <td class=\"text-thumb\" style=\"width: ${box_width}px; height: ${box_height}px;\">\n" ;
		if ($type == $TYPE_TEXT) {
		    # thumbnail linking to the slide
		    print IXW "      <a href=\"$entry->{slide_url}\" title=\"$title\">$entry->{linktext}</a>\n" ;
		} else {
		    # thumbnail directly linking to the target
		    print IXW "      <a href=\"$entry->{url}\" title=\"$title $entry->{dimstring}\">$entry->{linktext}</a>\n" ;
		}
		print IXW "    </td>\n" ;
	    }

	    $messages->update_percentage ($i+$j+1) ;
	}

	# Row footer
	print IXW "    <td class=\"thumb\">&nbsp;</td>\n"
	    unless $opts->{show_no_film_effect} ;
	print IXW "  </tr>\n" ;
	print IXW "  <tr><td class=\"tiled\" colspan=\"", $num+2, "\"><img src=\"$self->{local_llgal_dir}/$opts->{filmtile_filename}\" /></td></tr>\n"
	    unless $opts->{show_no_film_effect} ;

	# Dimensions and filesizes
	if ($opts->{show_dimensions} or $opts->{show_size}) {
	    print IXW "  <tr>\n" ;
	    print IXW "    <td>&nbsp;</td>\n"
		unless $opts->{show_no_film_effect} ;
	    for (my $j = 0; $j < $num; $j++) {
		my $entry = $entries[$i+$j] ;
		print IXW "    <td class=\"thumb-dim\">$entry->{scaled_dimstring}</td>\n" ;
	    }
	    print IXW "    <td>&nbsp;</td>\n"
		unless $opts->{show_no_film_effect} ;
	    print IXW "  </tr>\n" ;
	}

	# Write image captions under images if option -u is given
	if ($opts->{show_caption_under_thumbnails}) {
	    print IXW "  <tr>\n" ;
	    print IXW "<td>&nbsp;</td>\n"
		unless $opts->{show_no_film_effect} ;
	    for (my $j = 0; $j < $num; $j++) {
		my $entry = $entries[$i+$j] ;
		print IXW "    <td class=\"thumb-caption\">$entry->{caption}</td>\n" ;
	    }
	    print IXW "  </tr>\n" ;
	}

	# Table footer
	print IXW "</table>\n" ;

	$i += $num ;
    }

    # search next <!-- ********** -->
    while (defined($line = <IXR>)) {
	last if $line =~ m/\*{10}/ ;
    }
    print IXW "\n";

    # footers
    while (defined ($line = <IXR>)) {
	if ($line =~ m/<!--FOOTERS-->/) {
	    foreach my $footer (@footers) {
		print IXW "    <div class=\"footer\">" . $footer . "</div>\n" ;
	    }
	} else {
	    # user-defined fields
	    my $user_fields = $gallery->{user_fields} ;
	    foreach my $field (keys %{$user_fields}) {
		$line =~ s/$field/$user_fields->{$field}/g ;
	    }

	    # common fields
	    my $common_fields = $gallery->{common_fields} ;
	    foreach my $field (keys %{$common_fields}) {
		$line =~ s/$field/$common_fields->{$field}/g ;
	    }

	    print IXW "$line" ;
	}
    }
    close IXW ;
    close IXR ;

    $messages->end_percentage () ;

    $messages->warning ("Row width max ($opts->{pixels_per_row}) too low for one single thumbnail. "
	. "Forced $forced_width_warning time". ($forced_width_warning>1?"s":"") .".")
	if $forced_width_warning ;
}

#######################################################################
# If --www was invoked make all files world-readable at the END

sub make_readable {
    my $file = shift ;
    my ($status, @output) = Llgal::Utils::system_with_output
	("make world readable", "chmod", "a+r", $file) ;
    $messages->warning (@output)
	if $status ;
}

sub make_readable_and_traversable {
    my $file = shift ;
    my ($status, @output) = Llgal::Utils::system_with_output
	("make world readable and traversable", "chmod", "a+rx", $file) ;
    $messages->warning (@output)
	if $status ;
}

sub make_www_rights {
    my $gallery = shift ;
    my $opts = shift ;
    my @entries = @{$gallery->{entries}} ;

    $messages->print ("Making all llgal files world-readable for WWW publishing.\n") ;

    # index
    make_readable "$self->{destination_dir}$opts->{index_filename}.$opts->{www_extension}" ;
    # .llgal
    make_readable_and_traversable "$self->{destination_dir}$self->{local_llgal_dir}" ;
    # css
    make_readable "$self->{destination_dir}$self->{local_llgal_dir}/$opts->{css_filename}" ;
    # filmtile
    make_readable "$self->{destination_dir}$self->{local_llgal_dir}/$opts->{filmtile_filename}"
	if ! $opts->{show_no_film_effect} ;
    # index link image
    make_readable "$self->{destination_dir}$self->{local_llgal_dir}/$opts->{index_link_image_filename}"
 	if $opts->{index_link_image} ;
    # prev slide link image
    make_readable "$self->{destination_dir}$self->{local_llgal_dir}/$opts->{prev_slide_link_image_filename}"
 	if $opts->{prev_slide_link_image} and ! $opts->{prev_slide_link_preview};
    # next slide link image
    make_readable "$self->{destination_dir}$self->{local_llgal_dir}/$opts->{next_slide_link_image_filename}"
 	if $opts->{next_slide_link_image} and ! $opts->{next_slide_link_preview} ;

    # entries that have a slide
    foreach my $entry (@entries) {
	my $type = $entry->{type} ;

	# target
	if ($type == $TYPE_DIR) {
	    make_readable_and_traversable "$self->{destination_dir}$entry->{filename}" ;
	} elsif ($type == $TYPE_MOVIE or $type == $TYPE_FILE) {
	    make_readable "$self->{destination_dir}$entry->{filename}" ;
	}

	# slide
	make_readable "$self->{destination_dir}$entry->{slide_filename}"
	    if ! $opts->{make_no_slides} and ! defined $entry->{no_slide} ;

	# thumbnail
	make_readable "$self->{destination_dir}$entry->{thumb_filename}"
	    if ($type == $TYPE_IMAGE or $entry->{thumb_url}) and !defined $entry->{no_thumb} ;

	# scaled image
	make_readable "$self->{destination_dir}$entry->{scaled_filename}"
	    if ($type == $TYPE_IMAGE or $entry->{scaled_url})
	    and ($opts->{slide_width_max} > 0 or $opts->{slide_height_max} > 0) and !$opts->{make_no_slides} ;
    }
}

#######################################################################
# Main code

# evaluate generic configuration files
my $generic_opts = {} ;
# system-wide configuration file
Llgal::Config::merge_opts ($generic_opts, Llgal::Config::parse_generic_config_file
			   ($self, "$self->{llgal_config_dir}/$self->{generic_configuration_filename}")) ;
# user-wide configuration file
Llgal::Config::merge_opts ($generic_opts, Llgal::Config::parse_generic_config_file
			   ($self, "$self->{user_share_dir}/$self->{generic_configuration_filename}")) ;

# early configuration ends here
$self->{early_configuration} = 0 ;

# parse cmdline now but DO NOT MERGE now
my $cmdline_opts = Llgal::Config::parse_cmdline_options ($self) ;

# basic special behaviors may be done here
Llgal::Config::die_usage ($self)
    if $self->{help_asked} ;
die "This is llgal version $self->{version}.\n"
    if $self->{version_asked} ;

# the local llgal directory name is now fixed
# we may check the destination directory
check_destination ;

# revert a path into ..
sub back_path {
    my $dir = shift ;
    $dir =~ s/([^\/]+)/../g ;
    return $dir ;
}

# forward declaration
sub main_process ;

# recursive call, after saving globals
sub subdir_process {
    my $dir = shift ;
    my $subdir_opts = shift ;
    $messages->print ("Entering subdirectory '$dir'...\n") ;
    # save context
    my $saved_destination_dir = $self->{destination_dir};
    my $saved_destination_string = $destination_string;
    my $saved_opts = $opts ;
    my $saved_opts_without_defaults = $opts_without_defaults ;
    my $saved_messages = $messages->copy () ;
    $messages->indent () ;
    # setup new gallery context
    $self->{destination_dir} .= $dir."/" ;
    @ARGV = @llgal_options ;
    # recursive call
    my $subgallery = main_process $subdir_opts ;
    # restore context
    $self->{destination_dir} = $saved_destination_dir;
    $destination_string = $saved_destination_string;
    $opts = $saved_opts ;
    $opts_without_defaults = $saved_opts_without_defaults ;
    $messages = $saved_messages ;
    $self->{messages} = $messages ;
    $messages->print ("Leaving subdirectory '$dir'.\n") ;
    print "\n" ;
    return $subgallery ;
}

sub main_process {
    my $recursive_opts = shift ;

    # setup the destination directory
    setup_destination ;

    # add recursive specific opts first, so that they may be locally overriden
    $opts_without_defaults = Llgal::Config::merge_opts_into ($generic_opts, $recursive_opts) ;

    # evaluate gallery specific configuration, without modifying $generic_opts
    Llgal::Config::merge_opts ($opts_without_defaults, Llgal::Config::parse_generic_config_file
			       ($self, "$self->{destination_dir}$self->{local_llgal_dir}/$self->{generic_configuration_filename}")) ;

    # DO NOT MOVE THIS LINE BEFORE CONFIG FILE PARSING
    # parse command line options
    Llgal::Config::merge_opts ($opts_without_defaults, $cmdline_opts) ;

    # set the locale before getting the defaults
    if (defined $opts_without_defaults->{language}) {
	setlocale (LC_MESSAGES, $opts_without_defaults->{language}) ;
    } else {
	setlocale (LC_MESSAGES, "") ;
    }

    # set defaults values for all uninitialized values
    $opts = Llgal::Config::add_defaults ($opts_without_defaults) ;

    if ($self->{clean_asked} or $self->{cleanall_asked} or $self->{give_templates}) {
	# complex special behaviors that need full configuration, and recurse in all subdirectories

	if ($self->{clean_asked} or $self->{cleanall_asked}) {
	    # clean
	    my $cleanall = shift ;
	    $messages->delay_warnings () ;
	    clean_files $self->{cleanall_asked} ;
	    $messages->show_delayed_warnings () ;

	} elsif ($self->{give_templates}) {
	    # give templates
	    my $destdir = $self->{give_templates} ;
	    $destdir = $self->{local_llgal_dir}
		if $destdir eq "local" ;
	    $destdir = $self->{user_share_dir}
		if $destdir eq "user" ;
	    Llgal::Templates::give_templates ($self, $opts, $destdir) ;
	    $messages->print ("You may now edit templates in $destdir and generate new galleries.\n") ;
	    $messages->print ("You may also remove any template that you do not want to modify.\n") ;
	}

	# recursive in ALL subdirectories
	if ($opts->{recursive}) {
	    # list subdirs
	    opendir DIR, $self->{destination_dir} ? $self->{destination_dir} : "./" ; # destination is empty for './'
	    my @dir_entries = () ;
	    while (my $dir = readdir DIR) {
		push @dir_entries, $dir
		    if $dir =~ /^[^.]/ and -d "$self->{destination_dir}$dir" ;
	    }
	    closedir DIR ;
	    # process recursively
	    print "\n" if @dir_entries ;
	    map { subdir_process $_, {} } @dir_entries ;
	}

    } elsif ($self->{generate_captions}) {
	# generate captions and recurse in entries only

	Llgal::Config::prepare_captions_variables ($self, $opts) ;

	my @entries = generate_captions_entries $opts ;
	$messages->print ("Now edit the $self->{destination_dir}$self->{local_llgal_dir}/$opts->{captions_filename} file to your liking and run llgal\n") ;

	if ($opts->{recursive}) {
	    # list subdir entries
	    my @dir_entries = grep { $_->{type} == $TYPE_DIR } @entries ;
	    # process recursively
	    print "\n" if @dir_entries ;
	    map { subdir_process $_->{filename}, {} } @dir_entries ;
	}

    } else {
	# main gallery creation and recurse in entries only

	Llgal::Config::prepare_gallery_variables ($self, $opts) ;

	my $gallery = init_gallery () ;

	if (-e "$self->{destination_dir}$self->{local_llgal_dir}/$opts->{captions_filename}") {
	    # generate the gallery using the caption file
	    read_captions_file $gallery ;
	    fill_entries $gallery ;
	    $messages->print ("Found ". (scalar @{$gallery->{entries}}) ." entries in the captions file.\n") ;
	} else {
	    # generate the gallery from scratch
	    @{$gallery->{entries}} = get_entries $opts ;
	    fill_entries $gallery ;
	    $messages->print ("Found ". (scalar @{$gallery->{entries}}) ." entries in $destination_string\n") ;
	}

	finalize_entries $gallery, $opts ;

	add_headers_footers $gallery ;

	precompute_common_html_fields $gallery ;

	if ($opts->{make_no_slides}) {
	    $messages->print ("Linking thumbnails directly to image files...  Making no html slides.\n") ;
	} else {
	    generate_slides $gallery ;
	}

	generate_index $gallery ;

	Llgal::Templates::get_llgal_files ($self, $opts) ;

	$messages->delay_warnings () ;
	make_www_rights $gallery, $opts
	    if $opts->{www_access_rights} ;
	$messages->show_delayed_warnings () ;

	# generate a local config for this gallery
	if (defined $self->{generate_config} and $self->{generate_config} eq "local") {
	    Llgal::Config::generate_config ($self, "$self->{destination_dir}$self->{local_llgal_dir}/$self->{generic_configuration_filename}", $opts_without_defaults) ;
	}

	if ($opts->{recursive}) {
	    # list subdir entries
	    my @entries = grep { $_->{type} == $TYPE_DIR } @{$gallery->{entries}} ;
	    # process recursively
	    print "\n" if @entries ;
	    for (my $i = 0; $i < @entries; $i++) {
	        my $entry = $entries[$i] ;
		my $dir = $entry->{filename} ;
		my $revdir = back_path $dir ;

		# additional opts to generate the subgallery
		my $subdir_opts = {} ;

		# link to the parent gallery
		$subdir_opts->{parent_gallery_link} = 1 ;

		if ($opts->{link_subgalleries} and @entries > 1) {
		    # link to the previous gallery
		    my $prev = $entries[$entry->{prev}] ;
		    if ($prev->{type} == $TYPE_DIR) {
			$subdir_opts->{prev_gallery_link_target} = "$revdir/$prev->{url}" ;
			$subdir_opts->{prev_gallery_link} = 1 ;
		    }
		    # link to the next gallery
		    my $next = $entries[$entry->{next}] ;
		    if ($next->{type} == $TYPE_DIR) {
			$subdir_opts->{next_gallery_link_target} = "$revdir/$next->{url}" ;
			$subdir_opts->{next_gallery_link} = 1 ;
		    }
		}

		my $subgallery = subdir_process $dir, $subdir_opts ;
		$entry->{gallery} = $subgallery ;
	    }
	}

	return $gallery ;
    }
}

# generate main gallery
my $root_gallery = main_process {} ;

# only generate a config once
if (defined $self->{generate_config} and not $self->{generate_config} eq "local") {
    Llgal::Config::generate_config ($self, $self->{generate_config}, $opts_without_defaults) ;
}
