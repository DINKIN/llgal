#!/usr/bin/perl -w

use FileHandle ;
use Getopt::Long ;
use Image::Size ;
use Image::ExifTool ;
use POSIX qw(strftime) ;
use Time::Local ;
use URI::Escape ;
use Text::ParseWords ;
use Cwd ;
use I18N::Langinfo qw(langinfo CODESET) ;
use Locale::gettext ;
use POSIX qw (setlocale) ;

use strict ;
no strict "refs" ;

Getopt::Long::Configure('noignorecase', 'noautoabbrev', 'bundling') ;
STDOUT->autoflush("1") ;

# constants
my $version = "@VERSION@" ;
my $llgal_config_dir = "@SYSCONFDIR@/llgal" ;
my $llgal_share_dir = "@DATADIR@/llgal" ;
my $user_share_dir = $ENV{HOME}."/.llgal" ;
my $generic_configuration_filename = "llgalrc" ;
# local llgal directory, may be modified during early configuration
my $local_llgal_dir = ".llgal" ;

# some variable may only be modified when by system
# or user-wide configuration files only
my $early_configuration = 1 ;

######################################################################
# store command-line options upfront to write in the index <HEAD>
my @llgal_options = @ARGV ;

######################################################################
# a few routines that are required early

# split at each space, except between quotes
sub parse_convert_options {
    my $line = shift ;
    return parse_line (' +', 0, $line) ;
}

# join with spaces, and protect spaces
sub join_convert_options {
    return join (' ', map { my $val = $_ ; $val =~ s/( +)/\'$1\'/g ; $val } @_) ;
}

######################################################################
# early configuration that have to be now

# look in current directory "."
my $destination_dir = "." ;

Getopt::Long::Configure('passthrough') ;
GetOptions(
	'd=s'	=> \$destination_dir,
	) ;

# restore default behavior: process all options and warn on error
Getopt::Long::Configure('nopassthrough') ;

######################################################################
# gettext strings are prefixed to distinguish between identical strings

textdomain ("llgal") ;
bindtextdomain ("llgal", "@LOCALEDIR@") ;

sub llgal_gettext {
    my $id = shift ;
    my $string = gettext ($id) ;
    $string =~ s/^[^|]+\|// ;
    return $string ;
}

######################################################################
# ExifTool initialization, except what might be changed with llgal config
my $exifTool = new Image::ExifTool;

# Accept unknown tags, just in case...
$exifTool->Options(Unknown => 1) ;

######################################################################
# various temporary globals
my $destination_string ;
my $local_llgal_url ;
my $opts ;
my $opts_without_defaults ;
my $indent = "" ;

######################################################################
# general command-line options

# show version
my $version_asked = 0 ;
# displays brief usage message
my $help_asked = 0 ;
# clean up all generated files
my $clean_asked = 0 ;
# clean up all generated and user modified files
my $cleanall_asked = 0 ;
# generate (or update) captions
my $generate_captions = 0 ;
# give templates to the given directory
my $give_templates = undef ;

# Special behavior options
# generate a config file
my $generate_config = undef ;

######################################################################
# default values that will be restored if the associated option is set to -1

my $index_cellpadding_default = 3 ;
my $pixels_per_row_default = 0 ; # unlimited
my $thumbnail_width_max_default = 0 ; # unlimited
my $thumbnail_height_max_default = 75 ;
my $thumbnails_per_row_default = 5 ;
my $slide_height_max_default = 0 ; # unlimited
my $slide_width_max_default = 0 ; # unlimited
my $text_slide_width_default = 400 ;
my $text_slide_height_default = 300 ;

######################################################################
# a few routines

# Print messages with indentation according to recursion level

sub indprint {
    print $indent ;
    print @_ ;
}

# Warnings are shown after each step of processing to avoid
# breaking precentage progressions and so

my $tmp_warning = "" ;

sub add_warning {
    $tmp_warning .= "!! ".(shift)."\n" ;
}

sub add_external_warnings {
    while (@_) {
	my $line = shift ;
	chomp $line ;
	add_warning "# $line" ;
    }
}

sub show_warnings {
    print $tmp_warning ;
    $tmp_warning = "" ;
}

sub immediate_warning {
    print "!! ".(shift)."\n" ;
}

sub immediate_external_warnings {
    while (@_) {
	my $line = shift ;
	chomp $line ;
	immediate_warning "# $line" ;
    }
}

# Print percentage

sub init_percentage {
    print "  0%" ;
}

sub print_percentage {
    my ($i,$n) = (shift,shift) ;
    my $val = int($i*100/$n) ;
    print "\b\b\b\b" ;
    if ($val == 100) {
	print "100%" ;
    } elsif ($val >= 10) {
	print " ".$val."%" ;
    } else {
	print "  ".$val."%" ;
    }
}

sub end_percentage {
    print "\b\b\b\b100%\n" ;
}

######################################################################
# configuration variables characteristics

# normal option characteristics
my $OPT_IS_NUMERIC = 1 ;
my $OPT_IS_STRING = 2 ;
my $OPT_IS_NONEMPTY_STRING = 3 ;

my $normal_opts_type = {
# Name of generic llgal files
    captions_header_filename => $OPT_IS_NONEMPTY_STRING,
    css_filename => $OPT_IS_NONEMPTY_STRING,
    filmtile_filename => $OPT_IS_NONEMPTY_STRING,
    index_link_image_filename => $OPT_IS_NONEMPTY_STRING,
    prev_slide_link_image_filename => $OPT_IS_NONEMPTY_STRING,
    next_slide_link_image_filename => $OPT_IS_NONEMPTY_STRING,
    indextemplate_filename => $OPT_IS_NONEMPTY_STRING,
    slidetemplate_filename => $OPT_IS_NONEMPTY_STRING,
# location of generic llgal files that are available on the web
    css_location => $OPT_IS_STRING,
    filmtile_location => $OPT_IS_STRING,
    index_link_image_location => $OPT_IS_STRING,
    prev_slide_link_image_location => $OPT_IS_STRING,
    next_slide_link_image_location => $OPT_IS_STRING,
# Location and name of generated files
    index_filename => $OPT_IS_NONEMPTY_STRING,
    slide_filenameprefix => $OPT_IS_STRING,
    scaled_image_filenameprefix => $OPT_IS_NONEMPTY_STRING,
    thumbnail_image_filenameprefix => $OPT_IS_NONEMPTY_STRING,
    captions_filename => $OPT_IS_NONEMPTY_STRING,
    user_scaled_image_filenameprefix => $OPT_IS_NONEMPTY_STRING,
    user_thumbnail_image_filenameprefix => $OPT_IS_NONEMPTY_STRING,
# Index
    index_cellpadding => $OPT_IS_NUMERIC, # >= 0, -1 for default
    list_links => $OPT_IS_NUMERIC,
    pixels_per_row => $OPT_IS_NUMERIC, # > 0, 0 for unlimited, -1 for default
    thumbnails_per_row => $OPT_IS_NUMERIC, # > 0, 0 for unlimited, -1 for default
    thumbnail_height_max => $OPT_IS_NUMERIC, # > 0, -1 for default
    thumbnail_width_max => $OPT_IS_NUMERIC, # > 0, 0 for unlimited, -1 for default
    show_caption_under_thumbnails => $OPT_IS_NUMERIC,
    show_no_film_effect => $OPT_IS_NUMERIC,
# Slides
    make_no_slides => $OPT_IS_NUMERIC,
    make_slide_filename_from_filename => $OPT_IS_NUMERIC,
    make_slide_filename_from_extension => $OPT_IS_NUMERIC,
    slide_width_max => $OPT_IS_NUMERIC, # > 0, 0 for unlimited, -1 for default
    slide_height_max => $OPT_IS_NUMERIC, # > 0, 0 for unlimited, -1 for default
    text_slide_width => $OPT_IS_NUMERIC, # > 0, -1 for default
    text_slide_height => $OPT_IS_NUMERIC, # > 0, -1 for default
    index_link_image => $OPT_IS_NUMERIC,
    prev_slide_link_image => $OPT_IS_NUMERIC,
    next_slide_link_image => $OPT_IS_NUMERIC,
    prev_slide_link_preview => $OPT_IS_NUMERIC,
    next_slide_link_preview => $OPT_IS_NUMERIC,
    make_slide_title_from_caption => $OPT_IS_NUMERIC,
# Captions
    captions_removal_line => $OPT_IS_NONEMPTY_STRING,
    make_caption_from_image_comment => $OPT_IS_STRING,
    make_caption_from_image_timestamp => $OPT_IS_NUMERIC,
    make_caption_from_filename => $OPT_IS_NUMERIC,
    show_dimensions => $OPT_IS_NUMERIC,
    show_size => $OPT_IS_NUMERIC,
    slide_counter_format => $OPT_IS_STRING,
# Text
    index_title => $OPT_IS_STRING,
    index_link_text => $OPT_IS_NONEMPTY_STRING,
    parent_gallery_link_text => $OPT_IS_NONEMPTY_STRING,
    prev_gallery_link_text => $OPT_IS_STRING,
    next_gallery_link_text => $OPT_IS_STRING,
    prev_slide_link_text => $OPT_IS_NONEMPTY_STRING,
    next_slide_link_text => $OPT_IS_NONEMPTY_STRING,
    MVI_link_text => $OPT_IS_STRING,
    FIL_link_text => $OPT_IS_STRING,
    DIR_link_text => $OPT_IS_STRING,
    alt_full_text => $OPT_IS_STRING,
    alt_scaled_text => $OPT_IS_STRING,
    alt_thumbnail_text => $OPT_IS_STRING,
    over_scaled_text => $OPT_IS_STRING,
    over_thumbnail_text => $OPT_IS_STRING,
    over_index_link_text => $OPT_IS_STRING,
    over_prev_slide_link_text => $OPT_IS_STRING,
    over_next_slide_link_text => $OPT_IS_STRING,
    show_size_unit => $OPT_IS_STRING,
    timestamp_format_in_caption => $OPT_IS_NONEMPTY_STRING,
    credits_text => $OPT_IS_STRING,
# Recursion
    parent_gallery_link => $OPT_IS_NUMERIC,
    prev_gallery_link => $OPT_IS_NUMERIC,
    prev_gallery_link_target => $OPT_IS_STRING,
    next_gallery_link => $OPT_IS_NUMERIC,
    next_gallery_link_target => $OPT_IS_STRING,
    link_subgalleries => $OPT_IS_NUMERIC,
# What files to insert
    image_extensions => $OPT_IS_STRING,
    movie_extensions => $OPT_IS_STRING,
    add_all_files => $OPT_IS_NUMERIC,
    add_subdirs => $OPT_IS_NUMERIC,
    sort_criteria => $OPT_IS_NONEMPTY_STRING,
# Various
    codeset => $OPT_IS_STRING,
    language => $OPT_IS_STRING,
    force_image_regeneration => $OPT_IS_NUMERIC,
    recursive => $OPT_IS_NUMERIC,
    www_access_rights => $OPT_IS_NUMERIC,
    www_extension => $OPT_IS_NONEMPTY_STRING,
# Internal options, not parseable, not exportable
} ;

# options whose input or output is non-trivial:

# options that have a special parsing routine
my $special_opts_with_input = {
    local_llgal_dir => 1,
    exclude => 1,
    include => 1,
    additional_configuration_file => 1,
    additional_template_dir => 1,
    convert_options => 1,
    scaled_convert_options => 1,
    thumbnail_convert_options => 1,
} ;

# internal options that have a special outputting routine
my $special_opts_with_output = {
    excludes => 1,
    template_dirs => 1,
    convert_options => 1,
    scaled_convert_options => 1,
    thumbnail_convert_options => 1,
} ;

# stuff that is not stored in the option hash but need be outputted
my $special_nonopts_with_output = {
    local_llgal_dir => 1,
} ;

# internal options that are never output
my $special_opts_without_output = {
    default_thumb_xdim => 1,
    default_thumb_ydim => 1,
    thumbnail_create_command => 1,
    slide_create_command => 1,
    slide_copy_command => 1,
} ;

# options whose merging is done as array
my $special_opts_merging_as_array = {
    excludes => 1,
    template_dirs => 1,
    convert_options => 1,
    scaled_convert_options => 1,
    thumbnail_convert_options => 1,
} ;

######################################################################
# manage configuration variables

# overwrite current_opts (1st argument) with overwriting_opts (2nd)
sub merge_opts {
    my $current_opts = shift ;
    my $overwriting_opts = shift ;
    foreach my $key (keys %{$overwriting_opts}) {
	if (defined $overwriting_opts->{$key}) {
	    if (defined $special_opts_merging_as_array->{$key}
		and defined $current_opts->{$key}) {
		$current_opts->{$key} = [@{$current_opts->{$key}}, @{$overwriting_opts->{$key}}] ;
	    } else {
		$current_opts->{$key} = $overwriting_opts->{$key}
	    }
	}
    }
}

# overwrite current_opts with overwriting_opts in a new hash, without changing the originals
sub merge_opts_into {
    my $current_opts = shift ;
    my $overwriting_opts = shift ;
    my $new_opts = {} ;
    merge_opts ($new_opts, $current_opts) ;
    merge_opts ($new_opts, $overwriting_opts) ;
    return $new_opts ;
}

# set default to all uninitialized options
sub add_defaults {
    my $current_opts = shift ;

    my $default_opts = {
# Name of generic llgal files
	captions_header_filename => "captions.header",
	css_filename => "llgal.css",
	filmtile_filename => "tile.png",
	index_link_image_filename => "index.png",
	prev_slide_link_image_filename => "prev.png",
	next_slide_link_image_filename => "next.png",
	indextemplate_filename => "indextemplate.html",
	slidetemplate_filename => "slidetemplate.html",
# Location of llgal files if already on the web
	css_location => "",
	filmtile_location => "",
	index_link_image_location => "",
	prev_slide_link_image_location => "",
	next_slide_link_image_location => "",

# Location and name of generated files
# name of the index file (-i)
	index_filename => "index",
# prefix of HTML slide filenames
	slide_filenameprefix => "slide_",
# scaled and thumbnail image filename prefix
	scaled_image_filenameprefix => "scaled_",
	thumbnail_image_filenameprefix => "thumb_",
# captions filename
	captions_filename => "captions",
# additional prefix of user-provided scaled images
	user_scaled_image_filenameprefix => "my",
# additional prefix of user-provided thumbnails
	user_thumbnail_image_filenameprefix => "my",

# Index
# cellpadding value for the thumbnail index tables (-p)
	index_cellpadding => $index_cellpadding_default,
# list links outside f the table (-L)
	list_links => 0,
# how many pixels per row at most in index (--wx)
	pixels_per_row => $pixels_per_row_default,
# how many thumbnails per row at most in index (-w)
	thumbnails_per_row => $thumbnails_per_row_default,
# max height of a thumbnail (--xy or -y)
	thumbnail_height_max => $thumbnail_height_max_default,
# scale thumb longer dimension (--xy)
	thumbnail_width_max => $thumbnail_width_max_default,
# write captions under thumbnails on index page (-u)
	show_caption_under_thumbnails => 0,
# omit the film effect altogether (-r)
	show_no_film_effect => 0,

# Slides
# make no slides, just thumbnail links to images (-s)
	make_no_slides => 0,
# use image names as slide names (-n)
	make_slide_filename_from_filename => 0,
# also use image extension in the slide names
	make_slide_filename_from_extension => 0,
# max width of the slides (--bigxy)
	slide_width_max => $slide_width_max_default,
# max height of the slides (--bigxy or --bigy)
	slide_height_max => $slide_height_max_default,
# default text slide width
	text_slide_width => $text_slide_width_default,
# default text slide height
	text_slide_height => $text_slide_height_default,
# use an image for link from a slide to the index, previous or next slide
	index_link_image => 0,
	prev_slide_link_image => 0,
	next_slide_link_image => 0,
# use an image preview for link from a slide to the previous or next slide
	prev_slide_link_preview => 0,
	next_slide_link_preview => 0,
# use captions as slide titles (-k)
	make_slide_title_from_caption => 0,

# Captions
# this line will be placed in caption generated file
# the user may remove it to prevent llgal from removing the caption file with --clean
	captions_removal_line => "REMOVE THIS LINE IF LLGAL SHOULD NOT REMOVE THIS FILE",
# use image comment as captions (--cc)
	make_caption_from_image_comment => 0,
# use image timestamp as captions (--ct)
	make_caption_from_image_timestamp => 0,
# preserve image names as captions (--cf)
	make_caption_from_filename => 0,
# to write image dimensions (-a or --ad)
	show_dimensions => 0,
# to write image size (-a or --as)
	show_size => 0,
# omit the image slide from the caption (--nc)
	slide_counter_format => "&nbsp;&nbsp;&nbsp;(%0n/%t)",

# Text
# title of the gallery (--title)
	index_title => llgal_gettext ("index_title|Index of pictures"),
# label of link to the parent gallery
	parent_gallery_link_text => llgal_gettext ("parent_gallery_link_text|Back to parent gallery"),
# label of link to previous gallery
	prev_gallery_link_text => llgal_gettext ("prev_gallery_link_text|Previous gallery "),
# label of link to previous gallery
	next_gallery_link_text => llgal_gettext ("next_gallery_link_text|Next gallery "),
# label of link from slides to index
	index_link_text => llgal_gettext ("index_link_text|Index"),
# label of link from a slide to the previous one
	prev_slide_link_text => llgal_gettext ("prev_slide_link_text|&lt;&lt;Prev"),
# label of link from a slide to the next one
	next_slide_link_text => llgal_gettext ("next_slide_link_text|Next&gt;&gt;"),
# text prefixing the link text
	MVI_link_text => llgal_gettext ("MVI_link_text|Open movie "),
	FIL_link_text => llgal_gettext ("FIL_link_text|Download file "),
	DIR_link_text => llgal_gettext ("DIR_link_text|Open subgallery "),
# alternative text for full-size images in slides
	alt_full_text => llgal_gettext ("alt_full_text|"),
# alternative text for scaled images in slides
	alt_scaled_text => llgal_gettext ("alt_scaled_text|Scaled image "),
# alternative text for thumbnails in the index
	alt_thumbnail_text => llgal_gettext ("alt_thumbnail_text|Thumbnail "),
# text shown when the mouse pointer is over a scaled image in a slide
	over_scaled_text => llgal_gettext ("over_scaled_text|Click to see full size "),
# text shown when the mouse pointer is over a thumbnail
	over_thumbnail_text => llgal_gettext ("over_thumbnail_text|Click to enlarge "),
# text shown when the mouse pointer is over a link to the index
	over_index_link_text => llgal_gettext ("over_index_link_text|Return to the index"),
# text shown when the mouse pointer is over a link to the previous slide
	over_prev_slide_link_text => llgal_gettext ("over_prev_slide_link_text|Previous slide "),
# text shown when the mouse pointer is over a link to the next slide
	over_next_slide_link_text => llgal_gettext ("over_next_slide_link_text|Next slide "),
# change kB to another unit (--asu)
	show_size_unit => llgal_gettext ("show_size_unit|kB"),
# format of the timestamp in captions (--ctf)
	timestamp_format_in_caption => llgal_gettext ("timestamp_format_in_caption|%y-%m-%d %H:%M:%S"),
# credits line at the bottom of the index
	credits_text => llgal_gettext ("credits_text|created with <a href=\"http://home.gna.org/llgal\">llgal</a>"),

# Recursion
# add links between subgalleries
	link_subgalleries => 0,
# generate header and footer for link to parent gallery
	parent_gallery_link => 0,
# generate header and footer for link to previous subgallery
	prev_gallery_link => 0,
	prev_gallery_link_target => "",
# generate header and footer for link to next subgallery
	next_gallery_link => 0,
	next_gallery_link_target => "",

# What files to insert in the gallery
# image and movie extensions
	image_extensions => "jpg|jpeg|png|gif|tif|tiff|bmp",
	movie_extensions => "mpg|mpeg|avi|mov|ogm|wmv",
# add all files, not only images and movies (-A)
	add_all_files => 0,
# add subdirectories to entry list (-S)
	add_subdirs => 0,
# exclude/include
	excludes => [],
# sort criteria
	sort_criteria => "name",

# Various
# codeset to be set in HTML headers (--codeset)
	codeset => langinfo (CODESET ()),
# language to be used for generated text in HTML pages (--lang)
# default is actually useless since we set it before reading the defaults
	language => "",
# user-added directories where templates might be found
	template_dirs => [],
# options to be passed to convert (--con)
	convert_options => [],
	scaled_convert_options => [],
	thumbnail_convert_options => [],
# force thumbnails and scaled images regeneration
	force_image_regeneration => 0,
# makes everything world-readable (--www)
	www_access_rights => 0,
# extension of generate webpages (--php)
	www_extension => "html",
    } ;

    # merge given options _into_ defaults
    merge_opts ($default_opts, $current_opts) ;
    return $default_opts ;
}

######################################################################
# Create usage now to use defaults values

my $usage = << "END_OF_USAGE" ;
This is llgal $version, the image slide show generator.
Syntax:  llgal [-option -option ...]
Behavior Options:
  llgal generates a gallery, except with one of the following options:
    --clean            remove all generated files
    --cleanall         remove all generated and user modified files
    --gc               generate or update the captions file
    --gt [<dir>]       give templates to the directory <dir>
    -h, --help         displays this brief help
    -v, --version      show version
Additional Behavior Options:
  The behavior might also be modified with the following options,
  either when generating a gallery or not:
    --config <s>       pass an additional configuration files
    -d <dir>           operate on files in directory <dir> (current directory)
    -f                 force thumbnail and scaled slide regeneration
    --gencfg <file>    generate the configuration file <file>
    --option <s>       pass an additional option as in configuration files
    -R                 run recursively in subdirectories
Selecting files:
    -A                 add all non-image non-video files to the list of slides
    --exclude <s>      exclude matching files
    --include <s>      include matching files that were excluded
    -S                 add subdirectories to the list of slides
Layout Options:
    -a                 write image sizes under thumbnails on index page
    --ad               like -a, but write only the image dimensions
    --as               like -a, but write only the file size
    --asu <s>          change file size unit (kB)
    --bigxy <n>        like --xy, use it if you have very large image files
    --bigy <n>         like -y, use it if you have very large image files
    --cc [<s>]         use image comments as captions
    --cf               use file names as captions
    --ct               use image timestamps as captions
    --ctf <s>          timestamp format in captions
    --codeset <s>      change the codeset in HTML pages
    --con <s>          options to pass to convert (e.g. -quality N)
    -i <file>          name of the main thumbnail index file (index)
    -k                 use the image captions for the HTML slide titles
    -L                 list links outside of the table
    --lang <s>         change the locale
    --li               use images for links in slides
    --lt               use thumbnail preview for links in slides
    -n                 use image file names for the HTML slide files
    --nc               omit the image count from the captions
    -p <n>             cellpadding value of thumbnail index tables (3)
    --php              use php extension for generated webpages
    -r                 omit the film effect altogether
    --Rl               add links between subgalleries
    -s                 make no HTML slides, link thumbnails to images
    --sort <s>         sort files with criteria <s>
    --templates <dir>  use templates in <dir>
    --title <s>        title of the index of the gallery (Index of pictures)
    -u                 write captions under thumbnails on index page
    --uc <url>         use a CSS file that is already available on the web
    --ui <url>         use filmtile and link images that are already available on the web
    -w <n>             rows in thumbnail index are at most <n> images wide (5)
    --www              make all llgal files world-readable
    --wx <n>           rows in thumbnail index are at most <n> pixels wide
    --xy <n>           scale thumbs to <n> pixels in their longer dimension
    -y <n>             scale all thumbnails to the same height <n> (75)
  Default values are given in parentheses (where applicable).
Author:  Brice Goglin
Homepage:  http://home.gna.org/llgal
Report bugs to:  <llgal-users AT gna.org>
END_OF_USAGE

######################################################################
# do not show usage when dying from inside Getoptions

my $no_usage_on_getoptions_error = 0 ;

######################################################################
# parse options in config files

# forward declaration
sub parse_custom_config_file ;

# option parsing global variables
my $recursive_included_configuration_file = 0 ;
my $current_configuration_file = undef ;

# in case of option parsing error
sub process_option_error {
    my $error = shift ;
    $no_usage_on_getoptions_error = 1 ;
    if (defined $current_configuration_file) {
	my $file = $current_configuration_file ;
	$current_configuration_file = undef ; # reset here since we won't be able to reset anywhere else
	die "Line #$. of $file:\n  $error.\n" ;
    } else {
	die "$error.\n" ;
    }
}

# process one option line
sub process_option {
    my $opts = shift ;
    my $line = shift ;
    chomp $line ;

    if ($line =~ /^([^ ]+)\s*=.+$/) {
	my $optname = $1 ;
	my $type = $normal_opts_type->{$optname} ;
	if (defined $type) {
	    # use the options type to choose parsing

	    if ($type == $OPT_IS_NUMERIC) {
		# any match is fine
		if ($line =~ /^[^ ]+\s*=\s*(\d+)$/) {
		    $opts->{$optname} = $1 ;
		} else {
		    process_option_error "Configuration option <$optname> value must be numeric (in <$line>)" ;
		}

	    } elsif ($type == $OPT_IS_STRING) {
		# value must be quoted
		if ($line =~ /^[^ ]+\s*=\s*"(.*)"$/) {
		    $opts->{$optname} = $1 ;
		} else {
		    process_option_error "Configuration option <$optname> value must be a string (in <$line>)" ;
		}

	    } elsif ($type == $OPT_IS_NONEMPTY_STRING) {
		# value must be quoted and non-empty
		if ($line =~ /^[^ ]+\s*=\s*"(.+)"$/) {
		    $opts->{$optname} = $1 ;
		} else {
		    process_option_error "Configuration option <$optname> value must be a non-empty string (in <$line>)" ;
		}

	    }

	} elsif ($special_opts_with_input->{$optname}) {
	    # not a normal option, must be special

	    if ($line =~ /^local_llgal_dir\s*=\s*"(.*)"$/) {
		# the local llgal directory name may only be changed
		# during early configuration
		if ($early_configuration) {
		    $local_llgal_dir = $1 ;
		} elsif ($1 ne $local_llgal_dir) {
		    immediate_warning "Ignoring changes to the name of the local llgal directory outside of" ;
		    immediate_warning "system- and user-wide configuration files." ;
		}

	    } elsif ($line =~ /^exclude\s*=\s*"(.+)"$/) {
		my $entry = () ;
		$entry->{excluded} = 1 ;
		$entry->{filter} = $1 ;
		push (@{$opts->{excludes}}, $entry) ;

	    } elsif ($line =~ /^exclude\s*=\s*"(.+)"$/) {
		my $entry = () ;
		$entry->{excluded} = 0 ;
		$entry->{filter} = $1 ;
		push (@{$opts->{excludes}}, $entry) ;

	    } elsif ($line =~ /^additional_configuration_file\s*=\s*"(.+)"$/) {
		my $file = $1 ;
		if ($recursive_included_configuration_file++ >= 10) {
		    $no_usage_on_getoptions_error = 1 ;
		    die "Not opening '$file' since too much configuration files were recursively included, loop detected ?\n" ;
		}
		my $saved_current_configuration_file = $current_configuration_file ;
		parse_custom_config_file ($opts, $file) ;
		$current_configuration_file = $saved_current_configuration_file ;
		$recursive_included_configuration_file-- ;

	    } elsif ($line =~ /^additional_template_dir\s*=\s*"(.+)"$/) {
		push (@{$opts->{template_dirs}}, $1) ;

	    } elsif ($line =~ /^convert_options\s*=\s*"(.*)"$/) {
		push (@{$opts->{convert_options}}, parse_convert_options ($1)) ;

	    } elsif ($line =~ /^scaled_convert_options\s*=\s*"(.*)"$/) {
		push (@{$opts->{scaled_convert_options}}, parse_convert_options ($1)) ;

	    } elsif ($line =~ /^thumbnail_convert_options\s*=\s*"(.*)"$/) {
		push (@{$opts->{thumbnail_convert_options}}, $1) ;

	    } else {
		die "Unknown special inconfig option $optname.\n" ;
	    }

	} else {
	    process_option_error "Unknown configuration option <$optname>" ;
	}
    } else {
	process_option_error "Configuration must be given <opt> = <value> (was $line)" ;
    }

    return $opts ;
}

sub parse_generic_config_file {
    my $opts = {} ;
    my $file = shift ;

    # TODO: remove this one day (maybe on march 14th 2006, since it will be 6 month ?)
    # warn on obsolete file
    my $oldconffile = $file ;
    $oldconffile =~ s/$local_llgal_dir\/llgalrc$/.llgalrc/ ;
    $oldconffile =~ s/llgal\/llgalrc$/llgalrc/ ;
    immediate_warning "Obsolete configuration file $oldconffile skipped, should be moved to $file."
	if -e $oldconffile ;

    # generic configuration files may not exist
    if (open CONF, $file) {
	$current_configuration_file = $file ;
	while (<CONF>) {
	    process_option ($opts, $_)
		if (/^[^#]/ and !/^(\s*)$/) ;
	}
	$current_configuration_file = undef ;
	close CONF ;
    }
    return $opts ;
}

sub parse_custom_config_file {
    my $opts = shift ;
    my $file = shift ;

    # don't use a capitalized file handle since it would be shared across recursive calls
    if (open my $conf, $file) {
	$current_configuration_file = $file ;
	while (<$conf>) {
	    process_option ($opts, $_)
		if (/^[^#]/ and !/^(\s*)$/) ;
	}
	$current_configuration_file = undef ;
	close $conf ;
    } else {
	# custom configuration files have to exist
	$no_usage_on_getoptions_error = 1 ;
	die "Failed to open additional configuration file '$file' ($!).\n" ;
    }
}

######################################################################
# process command-line arguments (overriding defaults above)

sub parse_cmdline_options {
    my $opts = {} ;

    if (!GetOptions(
# behaviors
	'clean'		=> \$clean_asked,
	'cleanall'	=> \$cleanall_asked,
	'gc'		=> \$generate_captions,
	'gt:s'		=> sub {
				shift ; my $value = shift ;
				$value = "local" if !$value ;
				$give_templates = $value ;
				},
	'h|help'	=> \$help_asked,
	'v|version'	=> \$version_asked,
	'f'		=> \$opts->{force_image_regeneration},
	'gencfg=s'	=> \$generate_config,
	'config=s'	=> sub { shift ; parse_custom_config_file ($opts, shift) ; },
	'R'		=> \$opts->{recursive},

# layout
	'A'		=> \$opts->{add_all_files},
	'a'		=> sub { $opts->{show_dimensions} = $opts->{show_size} = 1 ; },
	'ad'		=> \$opts->{show_dimensions},
	'as'		=> \$opts->{show_size},
	'asu=s'		=> \$opts->{show_size_unit},
	'bigxy=i'	=> sub { shift ; $opts->{slide_width_max} = $opts->{slide_height_max} = shift ; },
	'bigy=i'	=> \$opts->{slide_height_max},
	'cc:s'		=> sub {
				shift ; my $value = shift ;
				if ($value eq "") { $opts->{make_caption_from_image_comment} = "std,exif" ; }
				elsif ($value eq "0") { $opts->{make_caption_from_image_comment} = "" ; }
				else { $opts->{make_caption_from_image_comment} = $value ; }
				},
	'cf'		=> \$opts->{make_caption_from_filename},
	'ct'		=> \$opts->{make_caption_from_image_timestamp},
	'ctf=s'		=> \$opts->{timestamp_format_in_caption},
	'codeset=s'     => \$opts->{codeset},
	'con=s'		=> sub { shift ; push (@{$opts->{convert_options}}, parse_convert_options (shift)) ; },
	'i=s'		=> \$opts->{index_filename},
	'k'		=> \$opts->{make_slide_title_from_caption},
	'L'		=> \$opts->{list_links},
	'lang=s'        => \$opts->{language},
	'li'		=> sub { $opts->{index_link_image} = 1 ; $opts->{prev_slide_link_image} = 1 ; $opts->{next_slide_link_image} = 1 ; },
	'lt'		=> sub { $opts->{prev_slide_link_preview} = 1 ; $opts->{next_slide_link_preview} = 1 ; },
	'n'		=> \$opts->{make_slide_filename_from_filename},
	'nc'		=> sub { $opts->{slide_counter_format} = "" ; },
	'option=s'	=> sub { shift ; process_option ($opts, shift) ; },
	'p=i'		=> \$opts->{index_cellpadding},
	'php'		=> sub { $opts->{www_extension} = "php" ; },
	'r'		=> \$opts->{show_no_film_effect},
	'Rl'		=> \$opts->{link_subgalleries},
	'S'		=> \$opts->{add_subdirs},
	's'		=> \$opts->{make_no_slides},
	'sort=s'	=> \$opts->{sort_criteria},
	'templates=s'	=> \@{$opts->{template_dirs}},
	'title=s'	=> \$opts->{index_title},
	'u'		=> \$opts->{show_caption_under_thumbnails},
	'uc=s'          => \$opts->{css_location},
	'ui=s'          => sub { shift ; my $url = shift ;
				 $opts->{filmtile_location} = $url ;
				 $opts->{index_link_image_location} = $url ;
				 $opts->{prev_slide_link_image_location} = $url ;
				 $opts->{next_slide_link_image_location} = $url ;
			     },
	'w=i'		=> \$opts->{thumbnails_per_row},
	'www'		=> \$opts->{www_access_rights},
	'wx=i'		=> \$opts->{pixels_per_row},
	'xy=i'		=> sub { shift ; $opts->{thumbnail_width_max} = $opts->{thumbnail_height_max} = shift ; },
	'y=i'		=> \$opts->{thumbnail_height_max},
	'exclude=s'	=> sub {
				shift ;
				my $entry = () ;
				$entry->{filter} = shift ;
				$entry->{excluded} = 1 ;
				push @{$opts->{excludes}}, $entry ;
				},
	'include=s'	=> sub {
				shift ;
				my $entry = () ;
				$entry->{filter} = shift ;
				$entry->{excluded} = 0 ;
				push @{$opts->{excludes}}, $entry ;
				},
	'parent-gal'	=> \$opts->{parent_gallery_link},
	'prev-gal=s'	=> sub { shift ; $opts->{prev_gallery_link_target} = shift ; $opts->{prev_gallery_link} = 1 ; },
	'next-gal=s'	=> sub { shift ; $opts->{next_gallery_link_target} = shift ; $opts->{next_gallery_link} = 1 ; },
    )) {
	# there has been an error during command line parsing
	if ($no_usage_on_getoptions_error) {
	    # the error has already been displayed
	    exit -1 ;
	} else {
	    die $usage ;
	}
    }

    return $opts ;
}

######################################################################
# a few routines

# system routine which:
# - takes a description followed by cmdline arguments
# - returns a table composed of the status followed by STDERR and STDOUT lines

sub system_with_output {
    my $descr = shift ;
    pipe (my $pipe_out, my $pipe_in) ;
    my $pid = fork() ;
    if ($pid < 0) {
	close $pipe_in ;
	close $pipe_out ;
	return ( -1, "Fork failed while trying to $descr\n" ) ;
    } elsif ($pid > 0) {
	close $pipe_in ;
	waitpid ($pid, 0) ;
	my $status = $? >> 8 ;
	$status = -1
	    if $status == 255 ;
	my @lines = <$pipe_out> ;
	close $pipe_out ;
	return ( $status , @lines ) ;
    } else {
	close $pipe_out ;
	open STDERR, ">&", $pipe_in ;
	open STDOUT, ">&", $pipe_in ;
	{ exec @_ } ;
	print $pipe_in "Exec of $_[0] failed while trying to $descr\n" ;
	close $pipe_in ;
	exit -1 ;
    }
}

# check whether an argument is an integer

sub is_integer {
    my $s = shift ;
    return $s eq int($s) ;
}

# copy a file
sub copy_file {
    my $filename = shift ;
    my $srcdir = shift ;
    my $destdir = shift ;
    my ($status, @output) = system_with_output
	("copy '$filename' from '$srcdir'",
	"cp", "-f", "$srcdir/$filename", "$destdir/$filename") ;
    if ($status) {
	# die on whatever error
	immediate_external_warnings @output ;
	die "Failed to get generic '$filename' file.\n" ;
    }
}

# find path to the template file in generic directories
sub find_generic_template_file {
    my ($filename, $check) = (shift, shift) ;
    foreach my $dir (@{$opts->{template_dirs}}) {
	return $dir
	    if -e "$dir/$filename" ;
    }
    return $user_share_dir
	if -e "$user_share_dir/$filename" ;
    die "File '$llgal_share_dir/$filename' does not exist.\nPlease install llgal properly.\n"
	unless -e "$llgal_share_dir/$filename" or !$check ;
    return $llgal_share_dir ;
}

# find path to the template, using the local one if it exists
sub find_template_file {
    my ($filename, $check) = (shift, shift) ;
    return $local_llgal_dir
	if -e "$local_llgal_dir/$filename" ;
    return find_generic_template_file ($filename, $check) ;
}

# get a template file from generic directories and save it to local directory
sub get_template_file {
    my $filename = shift ;
    if (-e "$destination_dir$local_llgal_dir/$filename") {
	indprint "Found $filename in $destination_dir$local_llgal_dir/, using it.\n" ;
    } else {
	my $srcdir = find_generic_template_file ($filename, 1) ;
	indprint "No $filename in $destination_dir$local_llgal_dir/, getting a copy from $srcdir\n" ;
	copy_file ($filename, $srcdir, "$destination_dir$local_llgal_dir" ) ;
    }
}

# revert a path into ..
sub back_path {
    my $dir = shift ;
    $dir =~ s/([^\/]+)/../g ;
    return $dir ;
}

# generating safe url
sub make_safe_url_nowarn {
    my $file = shift ;
    my $safe = uri_escape ($file) ;
    return $safe ;
}

sub make_safe_url {
    my $file = shift ;
    my $safe = uri_escape ($file) ;

    add_warning "Non-ascii characters were escaped in filename '$file'."
	if $safe ne $file and $file =~ /[\x80-\xFF]/ ;

    return $safe ;
}

######################################################################
# sanity check

sub sanity_checks {
    my $opts = shift ;

    # cannot have --bigy/xy and -s
    die "Please choose between --bigy/xy and -s\n"
	if ($opts->{slide_height_max} or $opts->{slide_width_max}) and $opts->{make_no_slides} ;

    # check a few string that have to be non-empty and may need to be single file without path
    die "Please give a non-empty filename without path as a CSS filename\n"
	if $opts->{css_filename} eq "" or $opts->{css_filename} =~ /\// ;
    die "Please give a non-empty filename without path as a film tile filename\n"
	if $opts->{filmtile_filename} eq "" or $opts->{filmtile_filename} =~ /\// ;
    die "Please give a non-empty filename without path as a index link image filename\n"
	if $opts->{index_link_image_filename} eq "" or $opts->{index_link_image_filename} =~ /\// ;
    die "Please give a non-empty filename without path as a previous slide link image filename\n"
	if $opts->{prev_slide_link_image_filename} eq "" or $opts->{prev_slide_link_image_filename} =~ /\// ;
    die "Please give a non-empty filename without path as a next slide link image filename\n"
	if $opts->{next_slide_link_image_filename} eq "" or $opts->{next_slide_link_image_filename} =~ /\// ;
    die "Please give a non-empty filename without path as a index template filename\n"
	if $opts->{indextemplate_filename} eq "" or $opts->{indextemplate_filename} =~ /\// ;
    die "Please give a non-empty filename without path as a slide template filename\n"
	if $opts->{slidetemplate_filename} eq "" or $opts->{slidetemplate_filename} =~ /\// ;
    die "Please give a non-empty directory name without path as a local llgal directory\n"
	if $local_llgal_dir eq "" or $local_llgal_dir =~ /\// ;
    die "Please give a non-empty string without path as a slide filename prefix\n"
	if $opts->{scaled_image_filenameprefix} eq "" or $opts->{scaled_image_filenameprefix} =~ /\// ;
    die "Please give a non-empty string without path as a thumbnail filename prefix\n"
	if $opts->{thumbnail_image_filenameprefix} eq "" or $opts->{thumbnail_image_filenameprefix} =~ /\// ;
    die "Please give a non-empty filename without path as a index filename\n"
	if $opts->{index_filename} eq "" or $opts->{index_filename} =~ /\// ;
    die "Please give a non-empty filename without path as a caption filename\n"
	if $opts->{captions_filename} eq "" or $opts->{captions_filename} =~ /\// ;
    die "Please give a non-empty string without path as a user-given scaled image prefix\n"
	if $opts->{user_scaled_image_filenameprefix} eq "" or $opts->{user_scaled_image_filenameprefix} =~ /\// ;
    die "Please give a non-empty string without path as a user-given thumbnail image prefix\n"
	if $opts->{user_thumbnail_image_filenameprefix} eq "" or $opts->{user_thumbnail_image_filenameprefix} =~ /\// ;
    die "Please give a non-empty caption removal line\n"
	if $opts->{captions_removal_line} eq "" ;

    # DateFormat should be initialized with whatever the user said to --ctf
    $exifTool->Options(DateFormat => $opts->{timestamp_format_in_caption}) ;
}

######################################################################
# check and prepare numerical options

sub prepare_numerical_options {
    my $opts = shift ;

    # thumbnail_width_max must be > 0 or 0 for unlimited
    die "Please give an integer value for thumbnail width max\n"
	unless is_integer ($opts->{thumbnail_width_max}) ;
    if ($opts->{thumbnail_width_max} < 0) {
	indprint "Thumbnail width max value < 0, restoring to default (".
	    ($thumbnail_width_max_default?$thumbnail_width_max_default:"unlimited") .")\n" ;
	$opts->{thumbnail_width_max} = $thumbnail_width_max_default ;
    }
    die "Please give a positive thumbnail width max value (or 0 for unlimited)\n"
	unless $opts->{thumbnail_width_max} >= 0 ;

    # thumbnail_height_max must be > 0
    die "Please give an integer value for thumbnail height max\n"
	unless is_integer ($opts->{thumbnail_height_max}) ;
    if ($opts->{thumbnail_height_max} < 0) {
	indprint "Thumbnail height max value < 0, restoring to default ($thumbnail_height_max_default)\n" ;
	$opts->{thumbnail_height_max} = $thumbnail_height_max_default ;
    }
    die "Please give a positive thumbnail height max value\n"
	unless $opts->{thumbnail_height_max} > 0 ;

    # thumbnails_per_row must be > 0 or 0 for unlimited
    die "Please give an integer value for thumbnails per row\n"
	unless is_integer ($opts->{thumbnails_per_row}) ;
    if ($opts->{thumbnails_per_row} < 0) {
	indprint "Thumbnails per row value < 0, restoring to default (".
	    ($thumbnails_per_row_default?$thumbnails_per_row_default:"unlimited") .")\n" ;
	$opts->{thumbnails_per_row} = $thumbnails_per_row_default ;
    }
    die "Please give a positive thumbnails per row value (or 0 for unlimited)\n"
	unless $opts->{thumbnails_per_row} >= 0 ;

    # pixels_per_row must be > 0 or 0 for unlimited
    die "Please give an integer value for pixels per row\n"
	unless is_integer ($opts->{pixels_per_row}) ;
    if ($opts->{pixels_per_row} < 0) {
	indprint "Pixels per row value < 0, restoring to default (".
	    ($pixels_per_row_default?$pixels_per_row_default:"unlimited") .")\n" ;
	$opts->{pixels_per_row} = $pixels_per_row_default ;
    }
    die "Please give a positive pixels per row value (or 0 for unlimited)\n"
	unless $opts->{pixels_per_row} >= 0 ;

    # index_cellpadding must be >= 0
    die "Please give an integer value for index cellpadding\n"
	unless is_integer ($opts->{index_cellpadding}) ;
    if ($opts->{index_cellpadding} < 0) {
	indprint "Index cellpadding value < 0, restoring to default ($index_cellpadding_default)\n" ;
	$opts->{index_cellpadding} = $index_cellpadding_default ;
    }
    die "Please give a positive or null index cellpadding value\n"
	unless $opts->{index_cellpadding} >= 0 ;

    # text_slide_width must be > 0
    die "Please give an integer value for text slide width\n"
	unless is_integer ($opts->{text_slide_width}) ;
    if ($opts->{text_slide_width} < 0) {
	indprint "Text slide width value < 0, restoring to default ($text_slide_width_default)\n" ;
	$opts->{text_slide_width} = $text_slide_width_default ;
    }
    die "Please give a positive text slide width value\n"
	unless $opts->{text_slide_width} > 0 ;

    # text_slide_height must be > 0
    die "Please give an integer value for text slide height\n"
	unless is_integer ($opts->{text_slide_height}) ;
    if ($opts->{text_slide_height} < 0) {
	indprint "Text slide height value < 0, restoring to default ($text_slide_height_default)\n" ;
	$opts->{text_slide_height} = $text_slide_height_default ;
    }
    die "Please give a positive text slide height value\n"
	unless $opts->{text_slide_height} > 0 ;

    # slide_width_max must be > 0, 0 for unlimited
    die "Please give an integer value for slide width max\n"
	unless is_integer ($opts->{slide_width_max}) ;
    if ($opts->{slide_width_max} < 0) {
	indprint "Slide width max value < 0, restoring to default (".
	    ($slide_width_max_default?$slide_width_max_default:"unlimited") .")\n" ;
	$opts->{slide_width_max} = $slide_width_max_default ;
    }
    die "Please give a positive slide width max value (or 0 for unlimited)\n"
	unless $opts->{slide_width_max} >= 0 ;

    # slide_height_max must be > 0, 0 for unlimited
    die "Please give an integer value for slide height max\n"
	unless is_integer ($opts->{slide_height_max}) ;
    if ($opts->{slide_height_max} < 0) {
	indprint "Slide height max value < 0, restoring to default (".
	    ($slide_height_max_default?$slide_height_max_default:"unlimited") .")\n" ;
	$opts->{slide_height_max} = $slide_height_max_default ;
    }
    die "Please give a positive slide height max value (or 0 for unlimited)\n"
	unless $opts->{slide_height_max} >= 0 ;

    # either pixels or thumbnails per row must be limited
    die "Please limit pixels or thumbnails per row\n"
	unless $opts->{pixels_per_row} > 0 or $opts->{thumbnails_per_row} > 0 ;
}

######################################################################
# prepare a few variables for later

sub prepare_various_variables {
    my $opts = shift ;

    # adapt text slide width and height in case of --bigxy or --bigy
    if ($opts->{slide_height_max} > 0) {
	$opts->{text_slide_width} = $opts->{text_slide_width} / $opts->{text_slide_height} * $opts->{slide_height_max} ;
	$opts->{text_slide_height} = $opts->{slide_height_max} ;
    }
    if ($opts->{slide_width_max} > 0 and $opts->{text_slide_width} > $opts->{slide_width_max}) {
	$opts->{text_slide_height} = $opts->{text_slide_height} / $opts->{text_slide_width} * $opts->{slide_width_max} ;
	$opts->{text_slide_width} = $opts->{slide_width_max} ;
    }

    # thumbnail default size (for text and link slide especially)
    if ($opts->{thumbnail_width_max} > 0) {
	($opts->{default_thumb_xdim}, $opts->{default_thumb_ydim}) = ($opts->{thumbnail_width_max}, $opts->{thumbnail_height_max}) ;
    } else {
	($opts->{default_thumb_xdim}, $opts->{default_thumb_ydim}) = ($opts->{thumbnail_height_max} * 4/3, $opts->{thumbnail_height_max}) ;
    }

    # convert options for thumbnails
    my @thumbnail_scale_options ;
    if ($opts->{thumbnail_width_max} > 0) {
	@thumbnail_scale_options = ("-scale", $opts->{thumbnail_width_max}."x".$opts->{thumbnail_height_max}.">") ;
    } else {
	@thumbnail_scale_options = ("-scale", "x".$opts->{thumbnail_height_max}) ;
    }
    @{$opts->{thumbnail_create_command}} = ("convert", "+profile", "*", @{$opts->{convert_options}}, @{$opts->{thumbnail_convert_options}}, @thumbnail_scale_options) ;

    # convert options for slides
    @{$opts->{slide_create_command}} = ("convert", "+profile", "*", @{$opts->{convert_options}}, @{$opts->{scaled_convert_options}} ) ;
    if ($opts->{slide_height_max} > 0) {
	if ($opts->{slide_width_max} > 0) {
	    push (@{$opts->{slide_create_command}}, ("-scale", "$opts->{slide_width_max}x$opts->{slide_height_max}")) ;
	} else {
	    push (@{$opts->{slide_create_command}}, ("-scale", "x$opts->{slide_height_max}")) ;
	}
    } else {
	if ($opts->{slide_width_max} > 0) {
	    push (@{$opts->{slide_create_command}}, ("-scale", "$opts->{slide_width_max}x")) ;
	}
    }
    @{$opts->{slide_copy_command}} = ("cp", "-f") ;

    # css location
    if ($opts->{css_location} =~ /^(.*\/)$/) {
	$opts->{css_location} .= $opts->{css_filename} ;
    }

    # images location
    if ($opts->{filmtile_location} =~ /^(.*)\/$/) {
	$opts->{filmtile_location} .= $opts->{filmtile_filename} ;
    }
    if ($opts->{index_link_image_location} =~ /^(.*\/)$/) {
	$opts->{index_link_image_location} .= $opts->{index_link_image_filename} ;
    }
    if ($opts->{prev_slide_link_image_location} =~ /^(.*\/)$/) {
	$opts->{prev_slide_link_image_location} .= $opts->{prev_slide_link_image_filename} ;
    }
    if ($opts->{next_slide_link_image_location} =~ /^(.*\/)$/) {
	$opts->{next_slide_link_image_location} .= $opts->{next_slide_link_image_filename} ;
    }
}

######################################################################
# --clean and --cleanall option

sub clean_files {
    my $cleanall = shift ;
    my $notdeleted = 0 ;
    if ($cleanall) {
	indprint "Cleaning all in $destination_string\n" ;
    } else {
	indprint "Cleaning in $destination_string\n" ;
    }

    opendir DIR, "$destination_dir$local_llgal_dir"
	or die "Can't open directory $destination_dir$local_llgal_dir ($!)\n" ;
    while ($_ = readdir DIR) {
	if (/^$opts->{thumbnail_image_filenameprefix}/ or /^$opts->{scaled_image_filenameprefix}/) {
	    unlink "$destination_dir$local_llgal_dir/$_" ;
	} elsif (/^$opts->{filmtile_filename}$/ or /^$opts->{index_link_image_filename}$/
		 or /^$opts->{prev_slide_link_image_filename}$/ or /^$opts->{next_slide_link_image_filename}$/
		 or /^$opts->{indextemplate_filename}$/ or /^$opts->{slidetemplate_filename}$/
		 or /^$opts->{css_filename}$/) {
	    my $original = (find_generic_template_file $_, 0)."/".$_ ;
	    my $diff = 0 ;
	    my @output ;
	    # default is cleanall, which removes everything, as if file were not changed
	    if (!$cleanall) {
		($diff, @output) = system_with_output
		    ("compare $_ with its original",
		     "cmp", "-s", "$destination_dir$local_llgal_dir/$_", "$original") ;
		if ($diff == -1) {
		    immediate_external_warnings @output ;
		    die "Failed to execute 'cmp' to check whether $destination_dir$local_llgal_dir/$_ has been modified ($!).\n" ;
		}
		add_external_warnings @output ;
		# on other errors, assume files are different ($diff != 0)
	    }
	    if ($diff) {
		add_warning "Preserved $destination_dir$local_llgal_dir/$_ since it seems to be modified." ;
		$notdeleted++ ;
	    } else {
		if (!unlink "$destination_dir$local_llgal_dir/$_" and ! $!{ENOENT}) {
		    add_warning "Failed to remove file $destination_dir$local_llgal_dir/$_ ($!)." ;
		}
	    }
	} elsif (/^$opts->{captions_filename}$/) {
	    my $grep = 0 ;
	    my @output ;
	    # default is cleanall, which removes everything, as if the removal line was here
	    if (!$cleanall) {
		($grep, @output) = system_with_output
		    ("check for caption removal line",
		     "grep", "-q", "$opts->{captions_removal_line}", "$destination_dir$local_llgal_dir/$_") ;
		if ($grep == -1) {
		    immediate_external_warnings @output ;
		    die "Failed to execute 'grep' to check whether $destination_dir$local_llgal_dir/$_ has been modified ($!).\n" ;
		}
		add_external_warnings @output ;
		# on other errors, assume file doesn't contain the caption removal line ($grep != 0)
	    }
	    if ($grep) {
		add_warning "Preserved $destination_dir$local_llgal_dir/$_ since it seems to be modified." ;
		$notdeleted++ ;
	    } else {
		if (!unlink "$destination_dir$local_llgal_dir/$_" and ! $!{ENOENT}) {
		    add_warning "Failed to remove file $destination_dir$local_llgal_dir/$_." ;
		}
	    }
	} else {
	    $notdeleted++ ;
	}
    }
    closedir DIR ;
    if ($notdeleted <= 2 and $cleanall) {
	if (!rmdir "$destination_dir$local_llgal_dir"  and ! $!{ENOENT}) {
	    add_warning "Failed to remove directory $destination_dir$local_llgal_dir ($!)." ;
	}
    }

    opendir DIR, $destination_dir ? $destination_dir : "./" ; # destination is empty for './'
    while ($_ = readdir DIR ) {
	if (/^$opts->{index_filename}\.$opts->{www_extension}$/
	    or /^$opts->{slide_filenameprefix}\d+\.$opts->{www_extension}$/) {
	    unlink "$destination_dir$_" ;
	}
    }
    closedir DIR ;
}

#####################################################################
# Give templates to the given directory

sub give_templates {
    my $destdir = shift ;
    if ( ! -e $destdir ) {
	indprint "Creating template directory $destdir...\n" ;
	mkdir $destdir
	    or die "Failed to create $destdir ($!)" ;
    }

    foreach my $filename
	( $opts->{css_filename}, $opts->{filmtile_filename}, $opts->{index_link_image_filename},
	  $opts->{prev_slide_link_image_filename}, $opts->{next_slide_link_image_filename},
	  $opts->{indextemplate_filename}, $opts->{slidetemplate_filename} ) {
	if ( -e "$destdir/$filename" ) {
	    indprint "$filename already exists in $destdir.\n" ;
	} else {
	    my $srcdir = find_generic_template_file ($filename, 1) ;
	    indprint "$filename does not exist in $destdir, getting a copy from $srcdir...\n" ;
	    copy_file ($filename, $srcdir, $destdir ) ;
	}
    }
}

#####################################################################
# Main variables

# The main gallery is composed of
# - @entries (the entry list)
# - @headers and @footers

sub init_gallery {
    my $gallery = () ;
    @{$gallery->{headers}} = () ;
    @{$gallery->{footers}} = () ;
    @{$gallery->{entries}} = () ;
    return $gallery ;
}

# Entries are hashed composed of
# - type: see below
# - filename (original filename with extension)
# - url (url of the filename)
# - linktext (an associated text that may be used in a link, www-safe)
# - caption (the caption of the slide, www-safe)
# - title (title, www-safe)
# - no_slide (1 or undef)

# - xdim, ydim, kbytes (details about the image or movie)
# - dimstring (string containing dimensions and/or size that were requested)

# - slide_filename (name of the HTML slide filename)
# - slide_url (url of the HTML slide filename)

# - thumb_xdim, thumb_ydim (details about the thumbnail image)
# - thumb_dimstring (string containing dimensions)
# - thumb_filename (name of the thumbnail image file)
# - thumb_url (url of the thumbnail image file)

# - scaled_xdim, scaled_ydim, scaled_kbytes (details about the scaled image)
# - scaled_dimstring (string containing dimensions and/or size that were requested)
# - scaled_filename (name of the scaled image file)
# - scaled_url (url of the scaled image file)

# - gallery (the whole gallery in the subdirectory pointed by this entry)

# types
my $TYPE_TXT = 0 ;
my $TYPE_LNK = 1 ;
my $TYPE_IMG = 2 ;
my $TYPE_MVI = 3 ;
my $TYPE_FIL = 4 ;
my $TYPE_DIR = 5 ;
my $TYPE_LIN = 6 ;
my $TYPE_BRK = 7 ;

###################################################################################
# checking files

sub check_file {
    my $filename = shift ;

    if (! -e $filename) {
	add_warning "Cannot find file '$filename', skipping it." ;
	return -1 ;
    }

    my $excluded = 0 ;
    for(my $i = 0; $i < @{$opts->{excludes}}; $i++) {
	my $entry = @{$opts->{excludes}}[$i] ;
	if ($filename =~ /^(.*\/)*$entry->{filter}$/) {
	    $excluded = $entry->{excluded}
	}
    }
    return -1
	if $excluded ;

    return 0 ;
}

sub check_image {
    my $filename = shift ;
    my ($status, @output) = system_with_output
	( "check \"$filename\" validity",
	  "identify", $filename ) ;
    if ($status == -1) {
	immediate_external_warnings @output ;
	die "Failed to check \"$filename\" validity\n" ;
    } elsif ($status) {
	# do not show external warnings
	add_warning "Bad image file '$filename', skipping it." ;
	return -1 ;
    }
    return 0 ;
}

sub check_movie {
    # TODO
    return 0 ;
}

###################################################################################
# returns a filename that the user provided in the llgal directory
# to be used as a thumbnail or scaled image

sub find_user_thumbnail {
    my $entry = shift ;
    my $type = $entry->{type} ;
    my $filename = $entry->{filename} ;
    my $user_thumbnail_filename = "$opts->{user_thumbnail_image_filenameprefix}$opts->{thumbnail_image_filenameprefix}$filename" ;

    if ($type == $TYPE_IMG) {
	if (-f "$local_llgal_dir/$user_thumbnail_filename") {
	    return $user_thumbnail_filename ;
	}
    } else {
	foreach my $ext (split (/\|/, $opts->{image_extensions})) {
	    if (-f "$local_llgal_dir/$user_thumbnail_filename.$ext") {
		return "$user_thumbnail_filename.$ext" ;
	    }
	}
    }
    return "" ;
}

sub find_user_scaled {
    my $entry = shift ;
    my $type = $entry->{type} ;
    my $filename = $entry->{filename} ;
    my $user_scaled_filename = "$opts->{user_scaled_image_filenameprefix}$opts->{scaled_image_filenameprefix}$filename" ;

    if ($type == $TYPE_IMG) {
	if (-f "$local_llgal_dir/$user_scaled_filename") {
	    return $user_scaled_filename ;
	}
    } else {
	foreach my $ext (split (/\|/, $opts->{image_extensions})) {
	    if (-f "$local_llgal_dir/$user_scaled_filename.$ext") {
		return "$user_scaled_filename.$ext" ;
	    }
	}
    }
    return "" ;
}

###################################################################################
# extract caption from image infos

# Image comment
sub generate_caption_from_image_comment {
    my $infos = shift ;
    my @texts = () ;
    # Loop until a non-empty comment list is found
    foreach my $types (split (/,/, $opts->{make_caption_from_image_comment})) {
	# types is a + separated string of types
	foreach my $type (split (/\+/, $types)) {
	    if ($type =~ /^std$/i) {
		# Standard comment such as JFIF or GIF
		my $comment = $infos->{Comment} ;
		push (@texts, $comment)
		    if $comment ;
	    } elsif ($type =~ /^exif$/i) {
		# Exif comment
		my $comment = $infos->{UserComment} ;
		push (@texts, $comment)
		    if $comment ;
	    } else {
		die "Unrecognized image comment type '$type'\n" ;
	    }
	}
	return @texts
	    if @texts ;
    }
    return () ;
}

# Image timestamp
sub generate_caption_from_image_timestamp {
    my $infos = shift ;
    my $imagetime = $infos->{DateTimeOriginal} ;
    return $imagetime;
}

# Image infos
sub generate_caption_from_image_infos {
    my $infos = shift ;
    my @texts = () ;
    if ($opts->{make_caption_from_image_comment}) {
	my @comments = generate_caption_from_image_comment $infos ;
	push (@texts, @comments) ;
    }
    if ($opts->{make_caption_from_image_timestamp}) {
	my $timestamp = generate_caption_from_image_timestamp $infos ;
	push (@texts, $timestamp) ;
    }
    return @texts ;
}

###################################################################################
# Generate entries

sub create_file_entry {
    my $entry = () ;
    my $type = shift ;
    my $filename = shift ;
    my $linktext = shift ;
    my $caption = shift ;

    # check file
    return undef
	if check_file ("$destination_dir$filename") < 0 ;
    if ($type == $TYPE_IMG) {
	return undef
	    if check_image ("$destination_dir$filename") < 0 ;
    } elsif ($type == $TYPE_MVI) {
	return undef
	    if check_movie ("$destination_dir$filename") < 0 ;
    }

    # set the type
    $entry->{type} = $type ;

    # set the filename
    $entry->{filename} = $filename ;

    # make a safe url
    $entry->{url} = make_safe_url ($filename) ;

    # the link text (will be web-safe after caption file generation)
    if (not defined $linktext) {
	$linktext = "" ;
	if ($type == $TYPE_MVI) {
	    $linktext = $opts->{MVI_link_text}.$filename ;
	} elsif ($type == $TYPE_FIL) {
	    $linktext = $opts->{FIL_link_text}.$filename ;
	} elsif ($type == $TYPE_DIR) {
	    $linktext = $opts->{DIR_link_text}.$filename ;
	}
	$linktext =~ s/&/&amp;/g ;
#       $linktext =~ s/"/&\#34;/g ;
    }
    $entry->{linktext} = $linktext ;

    # for images, extract required exif infos
    if ($type == $TYPE_IMG) {
	my @exif_tags = () ;
	@exif_tags = (@exif_tags, 'DateTimeOriginal')
	    if $opts->{make_caption_from_image_timestamp} ;
	@exif_tags = (@exif_tags, 'UserComment', 'Comment')
	    if $opts->{make_caption_from_image_comment} ;
	$entry->{infos} = $exifTool->ImageInfo ("$destination_dir$filename", @exif_tags) ;
    }

    # the caption (will be web-safe after caption file generation)
    if (not defined $caption) {
	my @texts = () ;
	push (@texts, $filename)
	    if $opts->{make_caption_from_filename} ;
	push (@texts, generate_caption_from_image_infos $entry->{infos})
	    if $type == $TYPE_IMG ;
	$caption = join (' - ', grep {$_} @texts) ;
	$caption =~ s/&/&amp;/g ;
#	$caption =~ s/"/&\#34;/g ;
    }
    chomp $caption ;
    $entry->{caption} = $caption ;

    # title is based on the filename
    my $title = $filename ;
    $title =~ s/&/&amp;/g ;
#    $title =~ s/"/&\#34;/g ;

    # add caption to the title if asked
    $title .= ": ". $caption
	if $opts->{make_slide_title_from_caption} ;

    $entry->{title} = $title ;

    # do not generate more if we are only generating captions
    return $entry ;
}

sub fill_file_entry {
    my $entry = shift ;
    my $type = $entry->{type} ;
    my $filename = $entry->{filename} ;

    # keep real filename for later
    my $real_filename = "$destination_dir$filename" ;

    # xdim, ydim, kbytes of the image or movie
    if ($type == $TYPE_IMG) {
	my ($x,$y) = imgsize ("$destination_dir$filename") ;
	$entry->{xdim} = $x ;
	$entry->{ydim} = $y ;
	# initialize here so that we can use it even when scaled are not used
	$entry->{scaled_xdim} = $x ;
	$entry->{scaled_ydim} = $y ;
    }
    if ($type == $TYPE_IMG or $type == $TYPE_MVI or $type == $TYPE_FIL) {
	my $kbytes = (-s "$destination_dir$filename") >> 10 ;
	$entry->{kbytes} = $kbytes ;
	# initialize here so that we can use it even when scaled are not used
	$entry->{scaled_kbytes} = $kbytes ;
    }

    # dimstring
    if ($type == $TYPE_IMG) {
	if ($opts->{show_dimensions} and $opts->{show_size}) {
	    $entry->{dimstring} = "($entry->{xdim}x$entry->{ydim}, $entry->{kbytes}$opts->{show_size_unit})" ;
	} elsif ($opts->{show_size}) {
	    $entry->{dimstring} = "($entry->{kbytes}$opts->{show_size_unit})" ;
	} elsif ($opts->{show_dimensions}) {
	    $entry->{dimstring} = "($entry->{xdim}x$entry->{ydim})" ;
	} else {
	    $entry->{dimstring} = "" ;
	}
    } elsif ($type == $TYPE_MVI or $type == $TYPE_FIL) {
	if ($opts->{show_size}) {
	    $entry->{dimstring} = "($entry->{kbytes}$opts->{show_size_unit})" ;
	} else {
	    $entry->{dimstring} = "" ;
	}
    } else {
	$entry->{dimstring} = "" ;
    }

    # thumbnail, its url and dimensions
    my $thumb_filename = find_user_thumbnail ($entry) ;
    if ($thumb_filename) {
	# there's a user provided thumbnail, just use it

	$entry->{thumb_filename} = "$local_llgal_dir/$thumb_filename" ;
	$entry->{thumb_url} = "$local_llgal_url/". make_safe_url_nowarn ($thumb_filename) ;

	# thumbnails dimensions
	my ($x, $y) = imgsize ("$local_llgal_dir/$thumb_filename") ;
	if ($y > $opts->{thumbnail_height_max}) {
	    $x = $x * ($opts->{thumbnail_height_max} / $y) ;
	    $y = $opts->{thumbnail_height_max} ;
	}
	if ($opts->{thumbnail_width_max} > 0 and $x > $opts->{thumbnail_width_max}) {
	    $y = $y * ($opts->{thumbnail_width_max} / $x) ;
	    $x = $opts->{thumbnail_width_max} ;
	}

	($entry->{thumb_xdim},$entry->{thumb_ydim}) = ($x, $y) ;

	# dimstring
	if ($opts->{show_dimensions}) {
	    $entry->{thumb_dimstring} = "(${x}x${y})" ;
	} else {
	    $entry->{thumb_dimstring} = "" ;
	}

    } elsif ($type == $TYPE_IMG) {
	# no user provided thumbnail, generate one

	# filename and url
	$thumb_filename = "$opts->{thumbnail_image_filenameprefix}$filename" ;
	$entry->{thumb_filename} = "$local_llgal_dir/$thumb_filename" ;
	$entry->{thumb_url} = "$local_llgal_url/". make_safe_url_nowarn ($thumb_filename) ;

	# thumbnails dimensions
	my $real_thumb_filename = "$destination_dir$entry->{thumb_filename}" ;
	if ((! -e "$real_thumb_filename") or $opts->{force_image_regeneration}) {
	    my ($status, @output) = system_with_output
		( "create '$real_filename' thumbnail",
		  @{$opts->{thumbnail_create_command}}, "$real_filename", "$real_thumb_filename" ) ;
	    if ($status == -1) {
		immediate_external_warnings @output ;
		die "Failed to create '$real_filename' thumbnail\n" ;
	    } elsif ($status) {
		add_warning "Failed to create '$real_filename' thumbnail" ;
		add_external_warnings @output ;
		return undef ;
	    }
	}
	($entry->{thumb_xdim},$entry->{thumb_ydim}) = imgsize ("$real_thumb_filename") ;

	# dimstring
	if ($opts->{show_dimensions}) {
	    $entry->{thumb_dimstring} = "($entry->{thumb_xdim}x$entry->{thumb_ydim})" ;
	} else {
	    $entry->{thumb_dimstring} = "" ;
	}

    } else {
	# default thumbnail dimensions
	$entry->{thumb_xdim} = $opts->{default_thumb_xdim} ;
	$entry->{thumb_ydim} = $opts->{default_thumb_ydim} ;

	# dimstring is empty
        $entry->{thumb_dimstring} = "" ;
    }

    if (!$opts->{make_no_slides}) {
	# scaled image, its url and dimensions

	my $scaled_filename = find_user_scaled ($entry) ;
	if ($scaled_filename) {
	    # there's a user provided scaled, just use it

	    $entry->{scaled_filename} = "$local_llgal_dir/$scaled_filename" ;
	    $entry->{scaled_url} = "$local_llgal_url/". make_safe_url_nowarn ($scaled_filename) ;

	    # thumbnails dimensions
	    my ($x, $y) = imgsize ("$local_llgal_dir/$scaled_filename") ;
	    if ($opts->{slide_height_max} > 0 and $y > $opts->{slide_height_max}) {
		$x = $x * ($opts->{slide_height_max} / $y) ;
		$y = $opts->{slide_height_max} ;
	    }
	    if ($opts->{slide_width_max} > 0 and $x > $opts->{slide_width_max}) {
		$y = $y * ($opts->{slide_width_max} / $x) ;
		$x = $opts->{slide_width_max} ;
	    }

	    ($entry->{scaled_xdim},$entry->{scaled_ydim}) = ($x, $y) ;
	    $entry->{scaled_kbytes} = (-s "$local_llgal_dir/$scaled_filename") >> 10 ;

	    # dimstring
	    if ($opts->{show_dimensions} and $opts->{show_size}) {
		$entry->{scaled_dimstring} = "($entry->{scaled_xdim}x$entry->{scaled_ydim}, $entry->{scaled_kbytes}$opts->{show_size_unit})" ;
	    } elsif ($opts->{show_size}) {
		$entry->{scaled_dimstring} = "($entry->{scaled_kbytes}$opts->{show_size_unit})" ;
	    } elsif ($opts->{show_dimensions}) {
		$entry->{scaled_dimstring} = "($entry->{scaled_xdim}x$entry->{scaled_ydim})" ;
	    } else {
		$entry->{scaled_dimstring} = "" ;
	    }

	} elsif ($type == $TYPE_IMG and ($opts->{slide_width_max} > 0 or $opts->{slide_height_max} > 0)) {
	    # no user provided scaled, generate one

	    # filename and url
	    $scaled_filename = "$opts->{scaled_image_filenameprefix}$filename" ;
	    $entry->{scaled_filename} = "$local_llgal_dir/$scaled_filename" ;
	    $entry->{scaled_url} = "$local_llgal_url/". make_safe_url_nowarn ($scaled_filename) ;

	    # scaled image dimensions
	    my $real_scaled_filename = "$destination_dir$entry->{scaled_filename}" ;
	    my ($x,$y) ;
	    if ((! -e "$real_scaled_filename") or $opts->{force_image_regeneration}) {
		# only scale down, never up.
		($x,$y) = imgsize ("$real_filename") ;
		my ($status, @output) ;
		if ($x <= $opts->{slide_width_max} and $y <= $opts->{slide_height_max}) {
		    ($status, @output) = system_with_output
			( "copy '$real_filename' scaled image",
			  @{$opts->{slide_copy_command}}, "$real_filename", "$real_scaled_filename" ) ;
		} else {
		    ($status, @output) = system_with_output
			( "create '$real_filename' scaled image",
			  @{$opts->{slide_create_command}}, "$real_filename", "$real_scaled_filename" ) ;
		}
		if ($status == -1) {
		    immediate_external_warnings @output ;
		    die "Failed to create '$real_filename' scaled image\n" ;
		} elsif ($status) {
		    add_warning "Failed to create '$real_filename' scaled image" ;
		    add_external_warnings @output ;
		    return undef ;
		}
	    }
	    ($entry->{scaled_xdim},$entry->{scaled_ydim}) = imgsize ("$real_scaled_filename") ;
	    $entry->{scaled_kbytes} = (-s "$real_scaled_filename") >> 10 ;

	    # dimstring
	    if ($opts->{show_dimensions} and $opts->{show_size}) {
		$entry->{scaled_dimstring} = "($entry->{scaled_xdim}x$entry->{scaled_ydim}, $entry->{scaled_kbytes}$opts->{show_size_unit})" ;
	    } elsif ($opts->{show_size}) {
		$entry->{scaled_dimstring} = "($entry->{scaled_kbytes}$opts->{show_size_unit})" ;
	    } elsif ($opts->{show_dimensions}) {
		$entry->{scaled_dimstring} = "($entry->{scaled_xdim}x$entry->{scaled_ydim})" ;
	    } else {
		$entry->{scaled_dimstring} = "" ;
	    }

	} else {
	    $entry->{scaled_dimstring} = $entry->{dimstring} ;
	}
    }
    return $entry ;
}

sub create_nofile_entry {
    my $entry = () ;
    my $type = shift ;
    my $url = shift ;
    my $linktext = shift ;
    my $caption = shift ;

    # set the type
    $entry->{type} = $type ;

    # row break and horizontal lines need nothing
    if ($type == $TYPE_LIN or $type == $TYPE_BRK) {
	$entry->{no_slide} = 1 ;
	return $entry ;
    }

    # make a safe url
    if (defined $url) {
	$entry->{url} = make_safe_url ($url) ;
    }

    # the link text (will be web-safe after caption file generation)
    $entry->{linktext} = $linktext ;

    # the caption (will be web-safe after caption file generation)
    $entry->{caption} = $caption ;

    # add caption to the title if asked
    my $title = "" ;
    $title = $caption
	if $opts->{make_slide_title_from_caption} ;
    $entry->{title} = $title ;

    # do not generate more if we are only generating captions
    return $entry ;
}

sub fill_nofile_entry {
    my $entry = shift ;

    # dimstring
    $entry->{dimstring} = "" ;

    # default thumbnail dimensions
    $entry->{thumb_xdim} = $opts->{default_thumb_xdim} ;
    $entry->{thumb_ydim} = $opts->{default_thumb_ydim} ;

    # dimstring is empty
    $entry->{thumb_dimstring} = "" ;

    if (!$opts->{make_no_slides}) {
	# scaled image dimensions
	$entry->{scaled_dimstring} = $entry->{dimstring} ;
    }
    return $entry ;
}

# fill entries, everything that's not required for
# captions generation, but may be done early
sub fill_entries {
    my $gallery = shift ;
    my @entries = @{$gallery->{entries}} ;
    my @final_entries = () ;

    indprint "Preparing entries: " ;
    init_percentage () ;

    my $i = 0 ;
    for my $entry (@entries) {
	my $type = $entry->{type} ;
	my $final_entry ;
	if ($type == $TYPE_LIN or $type == $TYPE_BRK) {
	    $final_entry = $entry ; # nothing to do
	} elsif ($type == $TYPE_TXT or $type == $TYPE_LNK) {
	    $final_entry = fill_nofile_entry $entry ;
	} else {
	    $final_entry = fill_file_entry $entry ;
	}
	push @final_entries, $final_entry
	    if defined $final_entry ;
	print_percentage (($i++)+1, scalar @entries) ;
    }
    end_percentage () ;
    show_warnings ;

    @{$gallery->{entries}} = @final_entries ;
}

# generate slide number, filename and url only when the order of entries is fixed
sub finalize_entries {
    my $gallery = shift ;
    my $opts = shift ;

    my @entries = @{$gallery->{entries}} ;

    if ($opts->{list_links}) {
	map {
	    my $type = $_->{type} ;
	    $_->{no_slide} = 1
		if $type == $TYPE_LNK or $type == $TYPE_DIR or $type == $TYPE_MVI or $type == $TYPE_FIL ;
	} @entries ;
    }

    # account slides
    my $nslides = scalar (grep { ! $_->{no_slide} } @entries) ;
    $gallery->{nslides} = $nslides ;

    # prepare numbering
    my $counter_length = length $nslides ;

    my $prev = undef ;
    my $first = undef ;
    my $indix = 0 ;
    for(my $i=0; $i < @entries; $i++) {
	my $entry = $entries[$i] ;

	# entries without a slide are not taken into account
	next if defined $entry->{no_slide} ;

	# slide counter
	$indix++;
	$entry->{counter} = $indix ;
	my $counter_with_zeros = sprintf "%0${counter_length}d", $indix ;
	$entry->{counter_with_zeros} = $counter_with_zeros ;

	my $type = $entry->{type} ;
	my $filename = $entry->{filename} ;

	# HTML slide and its url
	if (!$opts->{make_no_slides} and $type != $TYPE_LIN and $type != $TYPE_BRK) {
	    my $slide_filename ;
	    if ($opts->{make_slide_filename_from_filename}) {
		if ($type == $TYPE_TXT or $type == $TYPE_LNK) {
		    $slide_filename = "$opts->{slide_filenameprefix}$counter_with_zeros.$opts->{www_extension}" ;
		} elsif ($opts->{make_slide_filename_from_extension}) {
		    $slide_filename = "$filename.$opts->{www_extension}" ;
		} else {
		    my @parts = split (/\./, $filename) ;
		    pop @parts ;
		    my $basename = join ('.', @parts) ;
		    $slide_filename = "$basename.$opts->{www_extension}" ;
		}
	    } else {
		$slide_filename = "$opts->{slide_filenameprefix}$counter_with_zeros.$opts->{www_extension}" ;
	    }
	    $entry->{slide_filename} = $slide_filename ;
	    $entry->{slide_url} = make_safe_url_nowarn ($slide_filename) ;
	}

	# link to previous entry
	if (defined $prev) {
	    $entry->{prev} = $prev;
	    $entries[$prev]->{next} = $i ;
	}
	$prev = $i ;

	# store first
	$first = $i unless defined $first ;
    }

    if (defined $first) {
	# link last to first
	$entries[$prev]->{next} = $first ;
	$entries[$first]->{prev} = $prev ;
    }
}

#######################################################################
# Generating entry table from files in target directory

sub get_entries_from_directory {
    my $gallery = shift ;
    my @entries = () ;

    opendir DIR, $destination_dir ? $destination_dir : "./" # destination is empty for './'
	or die "Can't open $destination_string ($!)\n" ;
    # get all files, except dot-starting ones and webpages
    my @filenames = grep ((!/\.$opts->{www_extension}$/i and !/^\./), readdir DIR) ;
    closedir DIR ;

    # sort now so that slide numbering doesn't become wrong later
    if ($opts->{sort_criteria} eq "name") {
	@filenames = sort @filenames ;
    } elsif ($opts->{sort_criteria} eq "revname") {
	@filenames = sort { $b cmp $a } @filenames ;

    } elsif ($opts->{sort_criteria} eq "iname") {
	@filenames = sort { uc($a) cmp uc($b) } @filenames ;
    } elsif ($opts->{sort_criteria} eq "reviname") {
	@filenames = sort { uc($b) cmp uc($a) } @filenames ;

    } elsif ($opts->{sort_criteria} eq "date" or $opts->{sort_criteria} eq "time") {
	@filenames = sort { (-M $a) <=> (-M $b) } @filenames ;
    } elsif ($opts->{sort_criteria} eq "revdate" or $opts->{sort_criteria} eq "revtime") {
	@filenames = sort { (-M $b) <=> (-M $a) } @filenames ;

    } elsif ($opts->{sort_criteria} eq "size") {
	@filenames = sort { (-s $a) <=> (-s $b) } @filenames ;
    } elsif ($opts->{sort_criteria} eq "revsize") {
	@filenames = sort { (-s $b) <=> (-s $a) } @filenames ;

    } elsif ($opts->{sort_criteria} eq "none" or $opts->{sort_criteria} eq "") {
	# do not sort
    } else {
	die "Unknown sort criteria '$opts->{sort_criteria}'.\n" ;
    }

    indprint "Listing entries: " ;
    init_percentage () ;

    for(my $i = 0; $i < @filenames; $i++) {
	my $filename = $filenames[$i] ;
	if (-d "$destination_dir$filename") {
	    # directory
	    if ($opts->{add_subdirs} or $opts->{recursive}) {
		my $entry = create_file_entry ($TYPE_DIR, $filename, undef, undef) ;
		push @entries, $entry
		    if defined $entry ;
	    }

	} else {
	    # file
	    my $entry = undef ;

	    if ($filename =~ /($opts->{image_extensions})$/i) {
		# image
		my $entry = create_file_entry ($TYPE_IMG, $filename, undef, undef) ;
		goto JUST_A_FILE
		    if not defined $entry ;
		push @entries, $entry ;

	    } elsif ($filename =~ /($opts->{movie_extensions})$/i) {
		# movie
		my $entry = create_file_entry ($TYPE_MVI, $filename, undef, undef) ;
		goto JUST_A_FILE
		    if not defined $entry ;
		push @entries, $entry ;

	    } else {
	      JUST_A_FILE:
		if ($opts->{add_all_files}) {
		    # not an image, not a movie, just a file
		    my $entry = create_file_entry ($TYPE_FIL, $filename, undef, undef) ;
		    push @entries, $entry
			if defined $entry ;
		}
	    }
	}

	print_percentage ($i+1, scalar @filenames) ;
    }
    end_percentage () ;
    show_warnings ;

    @{$gallery->{entries}} = @entries ;
}

#######################################################################
# Check acces rights and create local subdirectory to place all llgal files

sub check_destination {

    # check destination
    die "Destination $destination_dir does not exist.\n"
	if ! -e $destination_dir ;
    die "Destination $destination_dir is not a directory.\n"
	if ! -d $destination_dir ;

    # cleanup destination
    # add a final /
    $destination_dir .= "/"
	unless $destination_dir =~ m@/$@ ;
    # remove starting ./
    $destination_dir =~ s/^(\.\/+)+// ;

    # Are we in .llgal ? just check the last part of the path by concatening
    # pwd and destination_dir even if destination_dir is an absolute path
    my $path = getcwd."/".$destination_dir ;
    if ($path =~ m@/*(?:[^/]+/+)*([^/]+)/+$@) {
	if ($1 eq $local_llgal_dir) {
	    immediate_warning "!! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !!" ;
	    immediate_warning "Your working directory looks like a .llgal directory. !!" ;
	    immediate_warning "This might not be what you really want to do.         !!" ;
	    immediate_warning "!! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !!" ;
	}
    }

    # TODO: remove this one day (maybe on march 7th 2006, since it will be 6 month ?)
    # temporary check, to be removed soon
    if ($local_llgal_dir ne ".llgal.files" and -e "${destination_dir}.llgal.files") {
	immediate_warning "!! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !!" ;
	immediate_warning "llgal now uses '.llgal' instead '.llgal.files'. !!" ;
	immediate_warning "You should probably update it.                  !!" ;
	immediate_warning "!! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !!" ;
    }

    # create globals to factorize later
    $local_llgal_url = make_safe_url_nowarn ($local_llgal_dir) ;
}

sub setup_destination {

    # create globals to factorize later
    $destination_string = ($destination_dir ? "directory $destination_dir" : "current directory") ;

    # Create or check the local llgal directory
    if (! -e "$destination_dir$local_llgal_dir") {
	mkdir "$destination_dir$local_llgal_dir"
	    or die "Failed to create $destination_dir$local_llgal_dir directory ($!)" ;
    }
    die "Local llgal $destination_dir$local_llgal_dir is not a directory.\n"
	if ! -d "$destination_dir$local_llgal_dir" ;
}

#######################################################################
# Generate captions file

sub generate_captions_file {
    my $opts = shift ;

    # use a temp gallery to pass the entries back to the caller
    my $gallery = init_gallery () ;
    get_entries_from_directory $gallery ;
    my @entries = @{$gallery->{entries}} ;

    indprint "Found ". (scalar @entries) ." files in $destination_string\n" ;

    my @captions = () ;

    # store old values from the captions file, if it exists
    my $old_title ;

    my $old_parent_gallery_link = 0 ;
    my $old_parent_gallery_link_text ;

    my $old_prev_gallery_link = 0 ;
    my $old_prev_gallery_link_target ;
    my $old_prev_gallery_link_text ;

    my $old_next_gallery_link = 0 ;
    my $old_next_gallery_link_target ;
    my $old_next_gallery_link_text ;

    if (-e "$destination_dir$local_llgal_dir/$opts->{captions_filename}") {
	indprint "Reading existing captions from $opts->{captions_filename}.\n" ;
	open (CAP, "$destination_dir$local_llgal_dir/$opts->{captions_filename}")
	    or die "Can't open $destination_dir$local_llgal_dir/$opts->{captions_filename} for reading\n" ;
	@captions = <CAP> ;
	close CAP ;

	foreach my $line (@captions) {
	    if ($line =~ /^TITLE:\s*(.*)\s*$/) {
		$old_title = $1 ;
	    } elsif ($line =~ /^PARENT:\s*(.*)\s*$/) {
		$old_parent_gallery_link = 1 ;
		$old_parent_gallery_link_text = $1 ;
	    } elsif ($line =~ /^PREV:\s*(.+)\s+----\s+(.+)\s*/) {
		$old_prev_gallery_link = 1 ;
		$old_prev_gallery_link_target = $2 ;
		$old_prev_gallery_link_text = $1 ;
	    } elsif ($line =~ /^NEXT:\s*(.+)\s+----\s+(.+)\s*/) {
		$old_next_gallery_link = 1 ;
		$old_next_gallery_link_target = $2 ;
		$old_next_gallery_link_text = $1 ;
	    }
	}

	indprint "Appending new captions to $opts->{captions_filename}: " ;
	open (CAP, ">>$destination_dir$local_llgal_dir/$opts->{captions_filename}")
	    or die "Can't open $destination_dir$local_llgal_dir/$opts->{captions_filename} file to append\n" ;

	print CAP "\n" ;
	print CAP "# Appended new captions (". (scalar localtime) .").\n" ;
	print CAP "\n" ;
    } else {
	indprint "Creating the $opts->{captions_filename} file: " ;
	open (CAP, ">$destination_dir$local_llgal_dir/$opts->{captions_filename}")
	    or die "Can't create $destination_dir$local_llgal_dir/$opts->{captions_filename} file\n" ;

	print CAP "# This is llgal's $opts->{captions_filename} file, first generated ", scalar localtime, ".\n" ;
	if (open CAPHEADER, "$llgal_share_dir/$opts->{captions_header_filename}") {
	    while (my $line = <CAPHEADER>) { print CAP $line ; }
	    close CAPHEADER ;
	} else {
	    add_warning "Failed to open $opts->{captions_header_filename}\n" ;
	}
	print CAP "# $opts->{captions_removal_line}\n" ;
	print CAP "\n" ;
    }

    print CAP "TITLE: $opts->{index_title}\n"
	if !defined $old_title
	    or $old_title ne $opts->{index_title} ;
    print CAP "PARENT: $opts->{parent_gallery_link_text}\n"
	if $opts->{parent_gallery_link} and
	    ( !$old_parent_gallery_link
	    or $old_parent_gallery_link_text ne $opts->{parent_gallery_link_text} ) ;
    print CAP "PREV: $opts->{prev_gallery_link_text} ---- $opts->{prev_gallery_link_target}\n"
	if $opts->{prev_gallery_link} and
	    ( !$old_prev_gallery_link
	    or $old_prev_gallery_link_target ne $opts->{prev_gallery_link_target}
	    or $old_prev_gallery_link_text ne $opts->{prev_gallery_link_text} ) ;
    print CAP "NEXT: $opts->{next_gallery_link_text} ---- $opts->{next_gallery_link_target}\n"
	if $opts->{next_gallery_link} and
	    ( !$old_next_gallery_link
	    or $old_next_gallery_link_target ne $opts->{next_gallery_link_target}
	    or $old_next_gallery_link_text ne $opts->{next_gallery_link_text} ) ;
    print CAP "\n" ;

    init_percentage () ;

    for (my $i = 0; $i < @entries; $i++) {
	my $entry = $entries[$i] ;
	my $type = $entry->{type} ;
	if ($type == $TYPE_IMG) {
	    print CAP "IMG: ". $entry->{filename}
		." ---- ". $entry->{caption} ."\n"
		unless grep { $captions[$_] =~ m/^(\s*IMG:)?\s*$entry->{filename}\s+----\s/ }
		    ( 0 .. $#captions ) ;
	} elsif ($type == $TYPE_MVI) {
	    print CAP "MVI: " . $entry->{filename}
		." ---- ". $entry->{linktext}
		." ---- ". $entry->{caption} ."\n"
		unless grep { $captions[$_] =~ m/^\s*MVI:\s*$entry->{filename}\s+----\s/ }
		    ( 0 .. $#captions ) ;
	} elsif ($type == $TYPE_FIL) {
	    print CAP "FIL: " . $entry->{filename}
		." ---- ". $entry->{linktext}
		." ---- ". $entry->{caption} ."\n"
		unless grep { $captions[$_] =~ m/^\s*FIL:\s*$entry->{filename}\s+----\s/ }
		    ( 0 .. $#captions ) ;
	} elsif ($type == $TYPE_DIR) {
	    print CAP "DIR: " . $entry->{filename}
		." ---- ". $entry->{linktext}
		." ---- ". $entry->{caption} ."\n"
		unless grep { $captions[$_] =~ m/^\s*DIR:\s*$entry->{filename}\s+----\s/ }
		    ( 0 .. $#captions ) ;
	}
	print_percentage ($i+1, scalar @entries) ;
    }

    end_percentage () ;

    close CAP ;
    show_warnings ;

    return $gallery ;
}

#######################################################################
# Read entry list in the captions file

sub read_captions_file {
    my $gallery = shift ;
    my @entries = () ;
    my @headers = () ;
    my @footers = () ;

    indprint "Reading entries in the $opts->{captions_filename} file: " ;
    init_percentage () ;

    open(CAP,"$destination_dir$local_llgal_dir/$opts->{captions_filename}")
	or die "Can't open $destination_dir$local_llgal_dir/$opts->{captions_filename} file\n" ;

    my $size = (-s CAP) ;
    my $line ;
    while (defined ($line = <CAP>)) {
	chomp $line ;
	$line =~ s/^\s*// ;
	$line =~ s/\s\(\s*\)$/$1/ ;
	# only lines that don't start with # and are not empty
	if (!($line =~ m/^\#/) and !($line =~ /^$/)) {
	    if ($line =~ m/^TITLE:\s*(.*)\s*/) {
		# title
		$opts->{index_title} = $1 ;

	    } elsif ($line =~ m/^INDEXHEAD:\s*(.*)\s*$/) {
		# header for the index
		push @headers, $1 ;

	    } elsif ($line =~ m/^INDEXFOOT:\s*(.*)\s*$/) {
		# footer for the index
		push @footers, $1 ;

# TODO move these to $gallery
	    } elsif ($line =~ m/^PARENT:\s*(.*)\s*$/) {
		# parent gallery link label
		$opts->{parent_gallery_link} = 1 ;
		$opts->{parent_gallery_link_text} = $1 ;

	    } elsif ($line =~ m/^PREV:\s*(.*)\s+----\s+(.*)\s*$/) {
		# prev gallery link label
		$opts->{prev_gallery_link_text} = $1 ;
		$opts->{prev_gallery_link} = $2 ;

	    } elsif ($line =~ m/^NEXT:\s*(.*)\s+----\s+(.*)\s*$/) {
		# next gallery link label
		$opts->{next_gallery_link_text} = $1 ;
		$opts->{next_gallery_link} = $2 ;

	    } else {
		# that's a slide, create its entry
		my $entry ;
		# flexibility:
		# - the last \s might be omitted when there's no caption
		# - \s is facultative after TYP: at the begining
		if ($line =~ m/^TXT:\s*(.+)\s+----\s*(?:\s(.*))?\s*$/) {
		    # text slide
		    $entry = create_nofile_entry ($TYPE_TXT, undef, $1, $2) ;

		} elsif ($line =~ m/^LNK:\s*(.+)\s+----\s+(.+)\s+----\s*(?:\s(.*))?\s*$/) {
		    # link slide
		    $entry = create_nofile_entry ($TYPE_LNK, $1, $2, $3) ;

		} elsif ($line =~ m/^DIR:\s*(.+)\s+----\s+(.+)\s+----\s*(?:\s(.*))?\s*$/) {
		    # directory slide
		    $entry = create_file_entry ($TYPE_DIR, $1, $2, $3) ;

		} elsif ($line =~ m/^MVI:\s*(.+)\s+----\s+(.+)\s+----\s*(?:\s(.*))?\s*$/) {
		    # movie slide
		    $entry = create_file_entry ($TYPE_MVI, $1, $2, $3) ;

		} elsif ($line =~ m/^FIL:\s*(.+)\s+----\s+(.+)\s+----\s*(?:\s(.*))?\s*$/) {
		    # movie slide
		    $entry = create_file_entry ($TYPE_FIL, $1, $2, $3) ;

		} elsif ($line =~ m/^LINE/) {
		    # horizontal line
		    $entry = create_nofile_entry ($TYPE_LIN, undef, undef, undef) ;

		} elsif ($line =~ m/^BREAK/) {
		    # thumbnail row break
		    $entry = create_nofile_entry ($TYPE_BRK, undef, undef, undef) ;

		} elsif ($line =~ m/^IMG:\s*(.+)\s+----\s*(?:\s(.*))?\s*$/
			 or $line =~ m/^(.+)\s+----\s*(?:\s(.*))?\s*$/) {
		    # image slide (default)
		    $entry = create_file_entry ($TYPE_IMG, $1, undef, $2) ;

		} else {
		    die "Unrecognized line #$. in captions file: \"$line\"\n" ;
		}

		# really add this entry
		push @entries, $entry
		    if defined $entry ;
	    }
	}
	print_percentage (tell CAP, $size) ;
    }
    close CAP ;
    end_percentage () ;
    show_warnings ;

    @{$gallery->{entries}} = @entries ;
    @{$gallery->{headers}} = @headers ;
    @{$gallery->{footers}} = @footers ;
}

#######################################################################
# Add recursion header and footer

sub add_headers_footers {
    my $gallery = shift ;
    my @headers = @{$gallery->{headers}} ;
    my @footers = @{$gallery->{footers}} ;

    # parent, prev and next, in reverse order
    unshift @headers, "<div style=\"text-align: right;\"><a href=\"$opts->{next_gallery_link_target}\">$opts->{next_gallery_link_text}$opts->{next_gallery_link_target}</a></div>"
	if $opts->{next_gallery_link} ;
    unshift @headers, "<a href=\"$opts->{prev_gallery_link_target}\">$opts->{prev_gallery_link_text}$opts->{prev_gallery_link_target}</a>"
	if $opts->{prev_gallery_link} ;
    unshift @headers, "<a href=\"..\">$opts->{parent_gallery_link_text}</a>"
	if $opts->{parent_gallery_link} ;

    # prev, next and parent
    push @footers, "<a href=\"$opts->{prev_gallery_link_target}\">$opts->{prev_gallery_link_text}$opts->{prev_gallery_link_target}</a>"
	if $opts->{prev_gallery_link} ;
    push @footers, "<div style=\"text-align: right;\"><a href=\"$opts->{next_gallery_link_target}\">$opts->{next_gallery_link_text}$opts->{next_gallery_link_target}</a></div>"
	if $opts->{next_gallery_link} ;
    push @footers, "<a href=\"..\">$opts->{parent_gallery_link_text}</a>"
	if $opts->{parent_gallery_link} ;

    @{$gallery->{headers}} = @headers ;
    @{$gallery->{footers}} = @footers ;
}

#######################################################################
# Create the individual slide show files

sub generate_slides {
    my $gallery = shift ;
    my @entries = @{$gallery->{entries}} ;

    # remove old webpages
    system ("rm -f ${destination_dir}$opts->{slide_filenameprefix}*.$opts->{www_extension}") ;
    die "Failed to remove existing webpages.\n"
	if $? ;

    # find the slidetemplate
    my $slidetemplate = find_template_file ($opts->{slidetemplate_filename}, 1) . "/$opts->{slidetemplate_filename}" ;
    indprint "Using '$slidetemplate' as HTML slide template.\n" ;

    # keep the slidetemplate in memory instead of always reopening it
    my @slidetemplate_text ;
    open(SR,"$slidetemplate")
	or die "Can't open the slide template file '$slidetemplate'\n" ;
    @slidetemplate_text = <SR> ;
    close SR ;

    # create slides
    indprint "Creating individual slides: " ;
    init_percentage () ;
    for (my $i = 0; $i < @entries; $i++) {
	my $entry = $entries[$i] ;

	next if defined $entry->{no_slide} ;

	open(SW, ">$destination_dir$entry->{slide_filename}")
	    or die "Can't create slide file\n" ;
	my $type = $entry->{type} ;
	my $title = $entry->{title} ;

	my @slidetemplate_text_copy = @slidetemplate_text ; # don't touch the original template
        for my $line (@slidetemplate_text_copy) {
	    $line =~ s/LLGAL-CODESET/$opts->{codeset}/g ;
	    $line =~ s/<!--SLIDE-TITLE-->/$title/g ;
	    $line =~ s/<!--TITLE-->/$opts->{index_title}/g ;
	    if ($opts->{css_location}) {
		$line =~ s/<!--CSS-->/$opts->{css_location}/g ;
	    } else {
		$line =~ s/<!--CSS-->/$local_llgal_dir\/$opts->{css_filename}/g ;
	    }

	    # set the style
	    if ($line =~ m/<!--THIS-SLIDE-STYLE-->/g) {
		if ($entry->{scaled_url}) {
		    $line =~ s/<!--THIS-SLIDE-STYLE-->/image-slide/ ;
		} else {
		    $line =~ s/<!--THIS-SLIDE-STYLE-->/text-slide" style="width: $opts->{text_slide_width}px; height: $opts->{text_slide_height}px;/ ;
		}
	    }

	    # fill the main part
	    if ($line =~ m/<!--THIS-SLIDE-->/g) {
		my $content ;
		if ($type == $TYPE_IMG) {
		    # image slide

		    if (defined $entry->{scaled_filename}) {
			# scaled image with link to the real image
			$content = "<a href=\"$entry->{url}\" "
			    ."title=\"$opts->{over_scaled_text}$title $entry->{dimstring}\">" ;
			$content .= "<img src=\"$entry->{scaled_url}\" "
			    ."style=\"width: $entry->{scaled_xdim}px; height: $entry->{scaled_ydim}px;\" "
			    ."alt=\"$opts->{alt_scaled_text}$title $entry->{scaled_dimstring}\" />" ;
			$content .= "</a>" ;

		    } else {
			# real image
			$content = "<img src=\"$entry->{url}\" "
			    ."style=\"width: $entry->{scaled_xdim}px; height: $entry->{scaled_ydim}px;\" "
			    ."alt=\"$opts->{alt_full_text}$title $entry->{dimstring}\" "
			    ."title=\"$title $entry->{dimstring}\" />" ;

		    }
		} elsif ($entry->{scaled_url}) {
		    # another type, with a user-given scaled image
		    if ($type == $TYPE_TXT) {
			# text with scaled image ? ok...
			$content = "<img src=\"$entry->{scaled_url}\" "
			    ."style=\"width: $entry->{scaled_xdim}px; height: $entry->{scaled_ydim}px;\" "
			    ."title=\"$title $entry->{dimstring}\" "
			    ."alt=\"$entry->{linktext} $entry->{scaled_dimstring}\" />" ;
		    } else {
			# another type with scaled image linking to the target
			$content = "<a href=\"$entry->{url}\" "
			    ."title=\"$title $entry->{dimstring}\">" ;
			$content .= "<img src=\"$entry->{scaled_url}\" "
			    ."style=\"width: $entry->{scaled_xdim}px; height: $entry->{scaled_ydim}px;\" "
			    ."alt=\"$entry->{linktext} $entry->{scaled_dimstring}\" />" ;
			$content .= "</a>" ;
		    }
		} elsif ($type == $TYPE_TXT) {
		    # text slide
		    $content = $entry->{linktext} ;
		} else {
		    # link-style slide
		    $content = "<a href=\"$entry->{url}\" title=\"$title $entry->{dimstring}\">$entry->{linktext}</a>" ;
		}

		# finally replace <!--THIS-SLIDE-->
		$line =~ s/<!--THIS-SLIDE-->/$content/ ;
	    }

	    # compute the slide counter
	    my $slide_counter = $opts->{slide_counter_format} ;
	    $slide_counter =~ s/%n/$entry->{counter}/ ;
	    $slide_counter =~ s/%0n/$entry->{counter_with_zeros}/ ;
	    $slide_counter =~ s/%t/$gallery->{nslides}/ ;

	    # add the caption and dimensions
	    my $imagecaption = $entry->{caption} . $slide_counter . "&nbsp;&nbsp;&nbsp;$entry->{dimstring}" ;

	    $line =~ s/<!--IMAGE-CAPTION-->/$imagecaption/g ;
	    $line =~ s/<!--THIS-SLIDE-->/$entry->{slide_url}/g ;

	    # process INDEX-FILE
	    my $index_link = $opts->{index_link_text} ;
	    if ($opts->{index_link_image}) {
		if ($opts->{index_link_image_location}) {
		    $index_link = "<img src=\"$opts->{index_link_image_location}\" "
			."alt=\"$opts->{index_link_text}\" "
			."class=\"image-link\" />" ;
		} else {
		    $index_link = "<img src=\"$local_llgal_dir/". (make_safe_url $opts->{index_link_image_filename}) ."\" "
			."alt=\"$opts->{index_link_text}\" class=\"image-link\" />" ;
		}
	    }
	    $line =~ s/<!--INDEX-LINK-TEXT-->/$index_link/g ;
	    $line =~ s/<!--INDEX-FILE-->/$opts->{index_filename}.$opts->{www_extension}\" title=\"$opts->{over_index_link_text}/g ;

	    # process PREV-SLIDE
	    my $prev = $entries[$entry->{prev}] ;

	    my $prev_slide_link ;
	    if ($opts->{prev_slide_link_preview} and $prev->{thumb_url}) {
		$prev_slide_link = "<img src=\"$prev->{thumb_url}\" "
		    ."style=\"width: $prev->{thumb_xdim}px; height: $prev->{thumb_ydim}px;\" "
		    ."alt=\"$opts->{prev_slide_link_text}\" />" ;
	    } elsif ($opts->{prev_slide_link_image}) {
		if ($opts->{prev_slide_link_image_location}) {
		    $prev_slide_link = "<img src=\"$opts->{prev_slide_link_image_location}\" "
			."alt=\"$opts->{prev_slide_link_text}\" class=\"image-link\" />" ;
		} else {
		    $prev_slide_link = "<img src=\"$local_llgal_dir/". (make_safe_url $opts->{prev_slide_link_image_filename}) ."\" "
			."alt=\"$opts->{prev_slide_link_text}\" class=\"image-link\" />" ;
		}
	    } else {
		$prev_slide_link = $opts->{prev_slide_link_text} ;
	    }
	    $line =~ s/<!--PREV-SLIDE-LINK-TEXT-->/$prev_slide_link/g ;
	    $line =~ s/<!--PREV-SLIDE-->/$prev->{slide_url}\" title=\"$opts->{over_prev_slide_link_text}$prev->{title}/g ;

	    # process NEXT-SLIDE
	    my $next = $entries[$entry->{next}] ;

	    my $next_slide_link ;
	    if ($opts->{next_slide_link_preview} and $next->{thumb_url}) {
		$next_slide_link = "<img src=\"$next->{thumb_url}\" "
		    ."style=\"width: $next->{thumb_xdim}px; height: $next->{thumb_ydim}px;\" "
		    ."alt=\"$opts->{next_slide_link_text}\" />" ;
	    } elsif ($opts->{next_slide_link_image}) {
		if ($opts->{next_slide_link_image_location}) {
		    $next_slide_link = "<img src=\"". $opts->{next_slide_link_image_location} ."\" "
			."alt=\"$opts->{next_slide_link_text}\" class=\"image-link\" />" ;
		} else {
		    $next_slide_link = "<img src=\"$local_llgal_dir/". (make_safe_url $opts->{next_slide_link_image_filename}) ."\" "
			."alt=\"$opts->{next_slide_link_text}\" class=\"image-link\" />" ;
		}
	    } else {
		$next_slide_link = $opts->{next_slide_link_text} ;
	    }
	    $line =~ s/<!--NEXT-SLIDE-LINK-TEXT-->/$next_slide_link/g ;
	    $line =~ s/<!--NEXT-SLIDE-->/$next->{slide_url}\" title=\"$opts->{over_next_slide_link_text}$next->{title}/g ;

	    $line =~ s/<!--CREDITS-->/$opts->{credits_text}/g ;

	    # output the line
	    print SW "$line" ;
	}
	close SW ;
	print_percentage ($i+1, scalar @entries) ;
    }
    end_percentage () ;
}
show_warnings ;

#######################################################################
# Creating the index file

sub generate_index {
    my $gallery = shift ;
    my @entries = @{$gallery->{entries}} ;
    my @headers = @{$gallery->{headers}} ;
    my @footers = @{$gallery->{footers}} ;

    # find the indextemplate
    my $indextemplate = find_template_file ($opts->{indextemplate_filename}, 1) . "/$opts->{indextemplate_filename}" ;
    indprint "Using '$indextemplate' as HTML index template.\n" ;

    # open the template and the destination
    indprint "Creating the $opts->{index_filename}.$opts->{www_extension} file: " ;
    open(IXR, "$indextemplate")
	or die "Can't open the index template file '$indextemplate'\n" ;
    open(IXW, ">$destination_dir$opts->{index_filename}.$opts->{www_extension}")
	or die "Can't create main $opts->{index_filename}.$opts->{www_extension} file\n" ;

    # headers
    my $line ;
    while (defined($line = <IXR>)) {

	# stop at <!-- ********** -->
	last if $line =~ m/\*{10}/ ;

	if ($line =~ m/<!--HEADERS-->/) {
	    foreach my $header (@headers) {
		print IXW "    <div class=\"header\">" . $header . "</div>\n" ;
	    }
	} else {
	    $line =~ s/LLGAL-CODESET/$opts->{codeset}/g ;
	    $line =~ s/LLGAL-OPTIONS/@llgal_options/g ;
	    $line =~ s/<!--TITLE-->/$opts->{index_title}/g ;
	    if ($opts->{css_location}) {
		$line =~ s/<!--CSS-->/$opts->{css_location}/g ;
	    } else {
		$line =~ s/<!--CSS-->/$local_llgal_dir\/$opts->{css_filename}/g ;
	    }
	    print IXW "$line" ;
	}
    }
    print IXW "\n" ;

    # output thumbnails
    my $forced_width_warning = 0 ;
    my $i = 0 ;
    init_percentage () ;
    while ($i < scalar @entries) {
	my $entry = $entries[$i] ;
	my $type = $entry->{type} ;

	if ($type == $TYPE_LIN or $type == $TYPE_BRK) {
	    if ($type == $TYPE_LIN) {
		# output a horizontal line
		print IXW "<hr class=\"index\">" ;
	    }
	    # next line, next entry
	    print_percentage ($i+1, scalar @entries) ;
	    $i++ ;
	    next ;
	}

	if ($entry->{no_slide}) {
	    # output a line with this text
	    print IXW "<div class=\"header\">" ;
	    if ($type == $TYPE_TXT) {
		print IXW $entry->{linktext} ;
	    } else {
		print IXW "<a href=\"$entry->{url}\" title=\"$entry->{title} $entry->{dimstring}\">$entry->{linktext}</a>" ;
	    }
	    print IXW "</div>\n" ;
	    # next line, next entry
	    print_percentage ($i+1, scalar @entries) ;
	    $i++ ;
	    next ;
	}

	# output a row of thumbnail
	my $width = $entries[$i]->{thumb_xdim} + $opts->{index_cellpadding} ;
	my $num = 1 ;
	# figure out how many entries to put on this row
	while ($i + $num < @entries) {
	    # stop if this is listed instead of having a slide
	    last if defined $entries[$i+$num]->{no_slide} ;
	    # stop if there's too much thumbnail on this row
	    last if $opts->{thumbnails_per_row}
	    and $num + 1 > $opts->{thumbnails_per_row} ;
	    # stop if these thumbnail are too large
	    last if $opts->{pixels_per_row}
	    and $width + $entries[$i+$num]->{thumb_xdim} + $opts->{index_cellpadding} > $opts->{pixels_per_row} ;
	    # compute the new num and width
	    $width += $entries[$i+$num]->{thumb_xdim} + $opts->{index_cellpadding} ;
	    $num++ ;
	}
	# check whether a single thumbnail was already too large
	if ($opts->{pixels_per_row} > 0 and $width > $opts->{pixels_per_row}) {
	    $forced_width_warning++ ;
	}

	# Table header
	if ($opts->{show_no_film_effect}) {
	    print IXW "<table class=\"index\" style=\"border-spacing: ", $opts->{index_cellpadding}, "px 0px;\">\n" ;
	} else {
	    print IXW "<table class=\"index with-tile\" style=\"border-spacing: ", $opts->{index_cellpadding}, "px 0px;\">\n" ;
	}

	# Row header
	# include the image to force the height of the line. we could do it in the css but IE css support sucks a lot
	print IXW "  <tr><td class=\"tiled\" colspan=\"", $num+2, "\"><img src=\"$local_llgal_dir/$opts->{filmtile_filename}\" /></td></tr>\n"
	    unless $opts->{show_no_film_effect} ;
	print IXW "  <tr>\n" ;
	print IXW "    <td class=\"thumb\">&nbsp;</td>\n"
	    unless $opts->{show_no_film_effect} ;

	# Actual row of thumbnails
	for (my $j = 0; $j < $num; $j++) {
	    my $entry = $entries[$i+$j] ;
	    my $type = $entry->{type} ;
	    my $title = $entry->{title} ;
	    my $width = $entry->{thumb_xdim} ;
	    my $height = $entry->{thumb_ydim} ;

	    if ($type == $TYPE_IMG) {
		# IMG thumbnail

		print IXW "    <td class=\"thumb\" style=\"width: ${width}px; height: ${height}px;\">\n" ;
		if ($opts->{make_no_slides}) {
		    print IXW "      <a href=\"$entry->{url}\"" ;
		} else {
		    print IXW "      <a href=\"$entry->{slide_url}\"" ;
		}
		print IXW " title=\"$opts->{over_thumbnail_text}$title $entry->{scaled_dimstring}\">\n" ;
		print IXW "        <img src=\"$entry->{thumb_url}\" "
			."style=\"width: $entry->{thumb_xdim}px; height: $entry->{thumb_ydim}px;\" "
			."alt=\"$opts->{alt_thumbnail_text}$title $entry->{thumb_dimstring}\" />\n" ;
		print IXW "      </a>\n" ;
		print IXW "    </td>\n" ;

	    } elsif ($entry->{thumb_url}) {
		# not IMG, but with a user-given thumbnail

		print IXW "    <td class=\"thumb\" style=\"width: ${width}px; height: ${height}px;\">\n" ;
		if ($type == $TYPE_TXT) {
		    # TXT with a thumbnail ? ok...
		    if ($opts->{make_no_slides}) {
			# thumbnail linking to the TXT slide
			print IXW "      <a href=\"$entry->{slide_url}\" "
				."title=\"$title $entry->{scaled_dimstring}\">\n" ;
			print IXW "        <img src=\"$entry->{thumb_url}\" "
				."style=\"width: $entry->{thumb_xdim}px; height: $entry->{thumb_ydim}px;\" "
				."alt=\"$entry->{linktext} $entry->{thumb_dimstring}\" />\n" ;
			print IXW "      </a>" ;

		    } else {
			# thumbnail without any link
			print IXW "      <img src=\"$entry->{thumb_url}\" "
				."title=\"$title $entry->{scaled_dimstring}\" "
				."style=\"width: $entry->{thumb_xdim}px; height: $entry->{thumb_ydim}px;\" "
				."alt=\"$entry->{linktext} $entry->{thumb_dimstring}\" />\n" ;
		    }
		} else {
		    # other types directly link to the target instead of the slide
		    print IXW "      <a href=\"$entry->{url}\" "
		    	."title=\"$title $entry->{scaled_dimstring}\">\n" ;
		    print IXW "        <img src=\"$entry->{thumb_url}\" "
			."style=\"width: $entry->{thumb_xdim}px; height: $entry->{thumb_ydim}px;\" "
			."alt=\"$entry->{linktext} $entry->{thumb_dimstring}\" />\n" ;
		    print IXW "      </a>\n" ;
		}
		print IXW "    </td>\n" ;
	    } else {
		# not IMG, without thumbnail
		print IXW "    <td class=\"text-thumb\" style=\"width: ", $width, "px; height: ", $height, "px;\">\n" ;
		if ($type == $TYPE_TXT) {
		    # thumbnail linking to the slide
		    print IXW "      <a href=\"$entry->{slide_url}\" title=\"$title\">$entry->{linktext}</a>\n" ;
		} else {
		    # thumbnail directly linking to the target
		    print IXW "      <a href=\"$entry->{url}\" title=\"$title $entry->{dimstring}\">$entry->{linktext}</a>\n" ;
		}
		print IXW "    </td>\n" ;
	    }

	    print_percentage ($i+$j+1, scalar @entries) ;
	}

	# Row footer
	print IXW "    <td class=\"thumb\">&nbsp;</td>\n"
	    unless $opts->{show_no_film_effect} ;
	print IXW "  </tr>\n" ;
	print IXW "  <tr><td class=\"tiled\" colspan=\"", $num+2, "\"><img src=\"$local_llgal_dir/$opts->{filmtile_filename}\" /></td></tr>\n"
	    unless $opts->{show_no_film_effect} ;

	# Dimensions and filesizes
	if ($opts->{show_dimensions} or $opts->{show_size}) {
	    print IXW "  <tr>\n" ;
	    print IXW "    <td>&nbsp;</td>\n"
		unless $opts->{show_no_film_effect} ;
	    for (my $j = 0; $j < $num; $j++) {
		my $entry = $entries[$i+$j] ;
		print IXW "    <td class=\"thumb-dim\">$entry->{scaled_dimstring}</td>\n" ;
	    }
	    print IXW "    <td>&nbsp;</td>\n"
		unless $opts->{show_no_film_effect} ;
	    print IXW "  </tr>\n" ;
	}

	# Write image captions under images if option -u is given
	if ($opts->{show_caption_under_thumbnails}) {
	    print IXW "  <tr>\n" ;
	    print IXW "<td>&nbsp;</td>\n"
		unless $opts->{show_no_film_effect} ;
	    for (my $j = 0; $j < $num; $j++) {
		my $entry = $entries[$i+$j] ;
		print IXW "    <td class=\"thumb-caption\">$entry->{caption}</td>\n" ;
	    }
	    print IXW "  </tr>\n" ;
	}

	# Table footer
	print IXW "</table>\n" ;

	$i += $num ;
    }

    # search next <!-- ********** -->
    while (defined($line = <IXR>)) {
	last if $line =~ m/\*{10}/ ;
    }
    print IXW "\n";

    # footers
    while (defined ($line = <IXR>)) {
	if ($line =~ m/<!--FOOTERS-->/) {
	    foreach my $footer (@footers) {
		print IXW "    <div class=\"footer\">" . $footer . "</div>\n" ;
	    }
	} else {
	    $line =~ s/<!--TITLE-->/$opts->{index_title}/g ;
	    $line =~ s/<!--CREDITS-->/$opts->{credits_text}/g ;
	    print IXW "$line" ;
	}
    }
    close IXW ;
    close IXR ;

    end_percentage () ;
    show_warnings ;

    immediate_warning "Row width max ($opts->{pixels_per_row}) too low for one single thumbnail. "
	. "Forced $forced_width_warning time". ($forced_width_warning>1?"s":"") ."."
	if $forced_width_warning ;
}

#######################################################################
# Get llgal files

sub get_files {
    # Get the film tile for the index
    if ($opts->{show_no_film_effect}) {
	indprint "Omitting film effect.\n" ;
    } elsif ($opts->{filmtile_location}) {
	indprint "Using the film tile that is available on $opts->{filmtile_location}.\n" ;
    } else {
	get_template_file ($opts->{filmtile_filename}) ;
    }

    # Get link images
    if ($opts->{index_link_image}) {
	if ($opts->{index_link_image_location}) {
	    indprint "Using the index link image that is available on $opts->{index_link_image_location}.\n" ;
	} else {
	    get_template_file ($opts->{index_link_image_filename}) ;
	}
    }
    if ($opts->{prev_slide_link_image} and ! $opts->{prev_slide_link_preview}) {
	if ($opts->{prev_slide_link_image_location}) {
	    indprint "Using the prev slide link image that is available on $opts->{prev_slide_link_image_location}.\n" ;
	} else {
	    get_template_file ($opts->{prev_slide_link_image_filename}) ;
	}
    }
    if ($opts->{next_slide_link_image} and ! $opts->{next_slide_link_preview}) {
	if ($opts->{next_slide_link_image_location}) {
	    indprint "Using the next slide link image that is available on $opts->{next_slide_link_image_location}.\n" ;
	} else {
	    get_template_file ($opts->{next_slide_link_image_filename}) ;
	}
    }

    # Get the css
    if ($opts->{css_location}) {
	indprint "Using the CSS that is available on $opts->{css_location}.\n" ;
    } else {
	get_template_file ($opts->{css_filename}) ;
    }
}

#######################################################################
# Chmod

sub make_readable {
    my $file = shift ;
    my ($status, @output) = system_with_output ("make world readable",
						"chmod", "a+r", $file) ;
    add_external_warnings @output
	if $status ;
}

sub make_readable_and_traversable {
    my $file = shift ;
    my ($status, @output) = system_with_output ("make world readable and traversable",
						"chmod", "a+rx", $file) ;
    add_external_warnings @output
	if $status ;
}

# If --www was invoked make all files world-readable at the END
sub make_www_rights {
    my $gallery = shift ;
    my $opts = shift ;
    my @entries = @{$gallery->{entries}} ;

    indprint "Making all llgal files world-readable for WWW publishing.\n" ;

    # index
    make_readable "$destination_dir$opts->{index_filename}.$opts->{www_extension}" ;
    # .llgal
    make_readable_and_traversable "$destination_dir$local_llgal_dir" ;
    # css
    make_readable "$destination_dir$local_llgal_dir/$opts->{css_filename}" ;
    # filmtile
    make_readable "$destination_dir$local_llgal_dir/$opts->{filmtile_filename}"
	if ! $opts->{show_no_film_effect} ;
    # index link image
    make_readable "$destination_dir$local_llgal_dir/$opts->{index_link_image_filename}"
 	if $opts->{index_link_image} ;
    # prev slide link image
    make_readable "$destination_dir$local_llgal_dir/$opts->{prev_slide_link_image_filename}"
 	if $opts->{prev_slide_link_image} and ! $opts->{prev_slide_link_preview};
    # next slide link image
    make_readable "$destination_dir$local_llgal_dir/$opts->{next_slide_link_image_filename}"
 	if $opts->{next_slide_link_image} and ! $opts->{next_slide_link_preview} ;

    # entries that have a slide
    foreach my $entry (@entries) {
	my $type = $entry->{type} ;

	# target
	if ($type == $TYPE_DIR) {
	    make_readable_and_traversable "$destination_dir$entry->{filename}" ;
	} elsif ($type == $TYPE_MVI or $type == $TYPE_FIL) {
	    make_readable "$destination_dir$entry->{filename}" ;
	}

	# slide
	make_readable "$destination_dir$entry->{slide_filename}"
	    if ! $opts->{make_no_slides} and ! defined $entry->{no_slide} ;

	# thumbnail
	make_readable "$destination_dir$entry->{thumb_filename}"
	    if ($type == $TYPE_IMG or $entry->{thumb_url}) and !defined $entry->{no_slide} ;

	# scaled image
	make_readable "$destination_dir$entry->{scaled_filename}"
	    if ($type == $TYPE_IMG or $entry->{scaled_url})
	    and ($opts->{slide_width_max} > 0 or $opts->{slide_height_max} > 0) and !$opts->{make_no_slides} ;
    }

    show_warnings ;
}

#######################################################################
# If --gencfg was invoked, generate a configuration file

sub generate_config {
    my $file = shift ;
    my $opts = shift ;

    indprint "Generating config file '$file'.\n" ;
    if (-e "$file") {
	my $old_file = "$file.save.". (strftime('%Y-%m-%d_%H:%M:%S' ,localtime)) ;
	immediate_warning "Renaming old configuration file '$file' as '$old_file'" ;
	rename "$file", "$old_file" ;
    }

    open NEWCFG, ">$file"
	or die "Cannot open $file ($!).\n" ;

    print NEWCFG "# This is a llgal configuration file.\n" ;
    print NEWCFG "# It was automatically generated on ". (scalar localtime) .".\n" ;
    print NEWCFG "# You may modify and reuse it as you want.\n" ;
    print NEWCFG "\n" ;

    for my $optname (sort (keys %{$normal_opts_type}, keys %{$special_opts_with_output}, keys %{$special_nonopts_with_output})) {

	if (defined $special_nonopts_with_output->{$optname}) {

	    if ($optname eq "local_llgal_dir") {
		print NEWCFG "local_llgal_dir = \"$local_llgal_dir\"\n" ;

	    } else {
		die "Unknown non-options $optname to output.\n" ;
	    }

	} elsif (defined $special_opts_with_output->{$optname}) {
	    next if not defined $opts->{$optname} ;
	    # special options that need special output

	    if ($optname eq "convert_options") {
		print NEWCFG "convert_options = \"". (join_convert_options (@{$opts->{convert_options}})) ."\"\n" ;

	    } elsif ($optname eq "scaled_convert_options") {
		print NEWCFG "scaled_convert_options = \"". (join_convert_options (@{$opts->{scaled_convert_options}})) ."\"\n" ;

	    } elsif ($optname eq "thumbnail_convert_options") {
		print NEWCFG "thumbnail_convert_options = \"". (join_convert_options (@{$opts->{thumbnail_convert_options}})) ."\"\n" ;

	    } elsif ($optname eq "template_dirs") {
		if (@{$opts->{template_dirs}}) {
		    map {
			print NEWCFG "additional_template_dir = \"$_\"\n" ;
		    } @{$opts->{template_dirs}} ;
		}

	    } elsif ($optname eq "excludes") {
		if (@{$opts->{excludes}}) {
		    map {
			print NEWCFG ($_->{excluded} ? "exclude" : "include"). " = \"". $_->{filter} ."\"\n" ;
		    } @{$opts->{excludes}} ;
		}

	    } else {
		die "Unknown special internal option $optname to output.\n" ;
	    }

	} else {
	    next if not defined $opts->{$optname} ;
	    # normal options

	    my $type = $normal_opts_type->{$optname} ;
	    if (defined $type) {

		if ($type == $OPT_IS_NUMERIC) {
		    print NEWCFG "$optname = $opts->{$optname}\n" ;
		} elsif ($type == $OPT_IS_STRING or $type == $OPT_IS_NONEMPTY_STRING) {
		    print NEWCFG "$optname = \"$opts->{$optname}\"\n" ;
		} else {
		    die "Unknown normal option type $type.\n" ;
		}

	    } else {
		die "Unknown ge option $optname to output.\n" ;
	    }
	}
    }

    print NEWCFG "\n" ;
    close NEWCFG ;
}

#######################################################################
# Main code

# evaluate generic configuration files
my $generic_opts = {} ;
# system-wide configuration file
merge_opts $generic_opts, parse_generic_config_file "${llgal_config_dir}/${generic_configuration_filename}" ;
# user-wide configuration file
merge_opts $generic_opts, parse_generic_config_file "${user_share_dir}/${generic_configuration_filename}" ;

# early configuration ends here
$early_configuration = 0 ;

# parse cmdline now but DO NOT MERGE now
my $cmdline_opts = parse_cmdline_options () ;

# basic special behaviors may be done here
die $usage
    if $help_asked ;
die "This is llgal version $version.\n"
    if $version_asked ;

# the local llgal directory name is now fixed
# we may check the destination directory
check_destination ;

# forward declaration
sub main_process ;

# recursive call, after saving globals
sub subdir_process {
    my $dir = shift ;
    my $subdir_opts = shift ;
    indprint "Entering subdirectory '$dir'...\n" ;
    # save context
    my $saved_destination_dir = $destination_dir;
    my $saved_destination_string = $destination_string;
    my $saved_opts = $opts ;
    my $saved_opts_without_defaults = $opts_without_defaults ;
    my $saved_indent = $indent ;
    # setup new gallery context
    $destination_dir .= $dir."/" ;
    @ARGV = @llgal_options ;
    $indent = "  ".$indent ;
    # recursive call
    my $subgallery = main_process $subdir_opts ;
    # restore context
    $destination_dir = $saved_destination_dir;
    $destination_string = $saved_destination_string;
    $opts = $saved_opts ;
    $opts_without_defaults = $saved_opts_without_defaults ;
    $indent = $saved_indent ;
    indprint "Leaving subdirectory '$dir'.\n" ;
    print "\n" ;
    return $subgallery ;
}

sub main_process {
    my $recursive_opts = shift ;

    # setup the destination directory
    setup_destination ;

    # add recursive specific opts first, so that they may be locally overriden
    $opts_without_defaults = merge_opts_into $generic_opts, $recursive_opts ;

    # evaluate gallery specific configuration, without modifying $generic_opts
    merge_opts $opts_without_defaults, parse_generic_config_file "${destination_dir}${local_llgal_dir}/${generic_configuration_filename}" ;

    # DO NOT MOVE THIS LINE BEFORE CONFIG FILE PARSING
    # parse command line options
    merge_opts $opts_without_defaults, $cmdline_opts ;

    # set the locale before getting the defaults
    if (defined $opts_without_defaults->{language}) {
	setlocale (LC_MESSAGES, $opts_without_defaults->{language}) ;
    } else {
	setlocale (LC_MESSAGES, "") ;
    }

    # set defaults values for all uninitialized values
    $opts = add_defaults $opts_without_defaults ;

    if ($clean_asked or $cleanall_asked or $give_templates) {
	# complex special behaviors that need full configuration, and recurse in all subdirectories

	if ($clean_asked or $cleanall_asked) {
	    # clean
	    my $cleanall = shift ;
	    clean_files $cleanall_asked ;
	    show_warnings ;

	} elsif ($give_templates) {
	    # give templates
	    my $destdir = $give_templates ;
	    $destdir = $local_llgal_dir
		if $destdir eq "local" ;
	    $destdir = $user_share_dir
		if $destdir eq "user" ;
	    give_templates $destdir ;
	    indprint "You may now edit templates in $destdir and generate new galleries.\n" ;
	    indprint "You may also remove any template that you do not want to modify.\n" ;
	}

	# recursive in ALL subdirectories
	if ($opts->{recursive}) {
	    # list subdirs
	    opendir DIR, $destination_dir ? $destination_dir : "./" ; # destination is empty for './'
	    my @dir_entries = () ;
	    while (my $dir = readdir DIR) {
		push @dir_entries, $dir
		    if $dir =~ /^[^.]/ and -d "$destination_dir$dir" ;
	    }
	    closedir DIR ;
	    # process recursively
	    print "\n" if @dir_entries ;
	    map { subdir_process $_, {} } @dir_entries ;
	}

    } elsif ($generate_captions) {
	# generate captions and recurse in entries only

	sanity_checks $opts ;

	my $gallery = generate_captions_file $opts ;
	indprint "Now edit the $destination_dir$local_llgal_dir/$opts->{captions_filename} file to your liking and run llgal\n" ;

	if ($opts->{recursive}) {
	    # list subdir entries
	    my @dir_entries = grep { $_->{type} == $TYPE_DIR } @{$gallery->{entries}} ;
	    # process recursively
	    print "\n" if @dir_entries ;
	    map { subdir_process $_->{filename}, {} } @dir_entries ;
	}

    } else {
	# main gallery creation and recurse in entries only

	sanity_checks $opts ;
	prepare_numerical_options $opts ;
	prepare_various_variables $opts ;

	my $gallery = init_gallery () ;

	if (-e "$destination_dir$local_llgal_dir/$opts->{captions_filename}") {
	    # generate the gallery using the caption file
	    read_captions_file $gallery ;
	    fill_entries $gallery ;
	    indprint "Found ". (scalar @{$gallery->{entries}}) ." files in the captions file.\n" ;
	} else {
	    # generate the gallery from scratch
	    get_entries_from_directory $gallery ;
	    fill_entries $gallery ;
	    indprint "Found ". (scalar @{$gallery->{entries}}) ." files in $destination_string\n" ;
	}

	finalize_entries $gallery, $opts ;

	add_headers_footers $gallery ;

	if ($opts->{make_no_slides}) {
	    indprint "Linking thumbnails directly to image files...  Making no html slides.\n" ;
	} else {
	    generate_slides $gallery ;
	}

	generate_index $gallery ;

	get_files ;

	make_www_rights $gallery, $opts
	    if $opts->{www_access_rights} ;

	# generate a local config for this gallery
	if (defined $generate_config and $generate_config eq "local") {
	    generate_config ("${destination_dir}${local_llgal_dir}/${generic_configuration_filename}", $opts_without_defaults) ;
	}

	if ($opts->{recursive}) {
	    # list subdir entries
	    my @entries = grep { $_->{type} == $TYPE_DIR } @{$gallery->{entries}} ;
	    # process recursively
	    print "\n" if @entries ;
	    for (my $i = 0; $i < @entries; $i++) {
	        my $entry = $entries[$i] ;
		my $dir = $entry->{filename} ;
		my $revdir = back_path $dir ;

		# additional opts to generate the subgallery
		my $subdir_opts = {} ;

		# link to the parent gallery
		$subdir_opts->{parent_gallery_link} = 1 ;

		if ($opts->{link_subgalleries} and @entries > 1) {
		    # link to the previous gallery
		    my $prev = $entries[$entry->{prev}] ;
		    if ($prev->{type} == $TYPE_DIR) {
			$subdir_opts->{prev_gallery_link_target} = "$revdir/$prev->{url}" ;
			$subdir_opts->{prev_gallery_link} = 1 ;
		    }
		    # link to the next gallery
		    my $next = $entries[$entry->{next}] ;
		    if ($next->{type} == $TYPE_DIR) {
			$subdir_opts->{next_gallery_link_target} = "$revdir/$next->{url}" ;
			$subdir_opts->{next_gallery_link} = 1 ;
		    }
		}

		my $subgallery = subdir_process $dir, $subdir_opts ;
		$entry->{gallery} = $subgallery ;
	    }
	}

	return $gallery ;
    }
}

# generate main gallery
my $root_gallery = main_process {} ;

# only generate a config once
if (defined $generate_config and not $generate_config eq "local") {
    generate_config ($generate_config, $opts_without_defaults) ;
}
