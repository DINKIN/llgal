#!/usr/bin/perl

use FileHandle ;
use Getopt::Long ;
use Image::Size ;
use Image::Info qw(image_info) ;
use POSIX qw(strftime) ;
use Time::Local ;
use URI::Escape ;
use Text::ParseWords ;
use Cwd ;

use strict ;
no strict "refs" ;

Getopt::Long::Configure('noignorecase', 'noautoabbrev', 'bundling') ;
STDOUT->autoflush("1") ;

my $version = "@VERSION@" ;

######################################################################
# store command-line options upfront to write in the index <HEAD>
my @llgal_options = @ARGV ;

######################################################################
# a few routines that are required early

# split at each space, except between quotes
sub parse_convert_options {
    my $line = shift ;
    return parse_line (' +', 0, $line) ;
}

# join with spaces, and protect spaces
sub join_convert_options {
    return join (' ', map { my $val = $_ ; $val =~ s/( +)/\'\1\'/g ; $val } @_) ;
}

######################################################################
# process general command-line options

my $destination_dir = "." ;	# look in current directory "."
my $force_regen_asked = 0 ;	# force thumbnail regeneration
my $version_asked = 0 ;		# show version
my $help_asked = 0 ;		# displays brief usage message
my $clean_asked = 0 ;		# clean up all generated files
my $cleanall_asked = 0 ;	# clean up all generated and user modified files
my $generate_config = undef ;   # generate a config file
my $generate_captions = 0 ;     # generate (or update) captions
my $give_templates = undef ;	# give templates to the given directory
my @template_dirs = () ;	# user-added directories where templates might be found
my $make_recursive = 0 ;        # do we run recursively in subdirectories ?

# process these options but kept other options in @ARGV for later
Getopt::Long::Configure('passthrough') ;
GetOptions(
	   'd=s' 	=> \$destination_dir,
	   'f'		=> \$force_regen_asked,
           'R'          => \$make_recursive,
	   'gc'         => \$generate_captions,
	   'gencfg=s'   => \$generate_config,
	   'gt:s'       => sub {
				shift ; my $value = shift ;
				$value = "local" if !$value ;
				$give_templates = $value ;
			    },
	   'templates=s'=> \@template_dirs,
	   'clean'	=> \$clean_asked,
	   'cleanall'	=> \$cleanall_asked,
	   'v|version'	=> \$version_asked,
	   'h|help'	=> \$help_asked,
	) ;

# restore default behavior: process all options and warn on error
Getopt::Long::Configure('nopassthrough') ;

# add a final /
$destination_dir .= "/"
    unless $destination_dir =~ m@/$@ ;
# remove starting ./
$destination_dir =~ s/^(\.\/+)+// ;
# factorization
my $destination_string = ($destination_dir ? "directory '$destination_dir'" : "current directory") ;

######################################################################
# configuration files

my @config_files = () ;
push (@config_files, "@SYSCONFDIR@/llgalrc") ;
push (@config_files, $ENV{HOME}."/.llgalrc") ;
push (@config_files, "${destination_dir}.llgalrc")
    if $destination_dir ;
push (@config_files, ".llgalrc") ;

my @additional_config_files = () ;

Getopt::Long::Configure('passthrough') ;
GetOptions(
	   'config=s'   => \@additional_config_files,
	) ;
Getopt::Long::Configure('nopassthrough') ;

######################################################################
# default values that will be restored if the associated option is set to -1

my $index_cellpadding_default = 3 ;
my $pixels_per_row_default = 0 ; # unlimited
my $tile_height_default = 21 ;
my $thumbnail_width_max_default = 0 ; # unlimited
my $thumbnail_height_max_default = 75 ;
my $thumbnails_per_row_default = 5 ;
my $slide_height_max_default = 0 ; # unlimited
my $slide_width_max_default = 0 ; # unlimited
my $text_slide_width_default = 400 ;
my $text_slide_height_default = 300 ;

######################################################################
# all configuration variables

# llgal directories
my $llgal_share_dir = "@DATADIR@/llgal" ;
my $user_share_dir = $ENV{HOME}."/.llgal" ;

# Name of generic llgal files
my $captions_header_filename = "captions.header" ;
my $css_filename = "llgal.css" ;
my $filmtile_filename = "tile.png" ;
my $index_link_image_filename = "index.png" ;
my $prev_slide_link_image_filename = "prev.png" ;
my $next_slide_link_image_filename = "next.png" ;
my $indextemplate_filename = "indextemplate.html" ;
my $slidetemplate_filename = "slidetemplate.html" ;

# Location and name of generated files
my $local_llgal_dir = ".llgal" ;
my $scaled_image_filenameprefix = "scaled_" ;
my $thumbnail_image_filenameprefix = "thumb_" ;

# Index
# name of the index file (-i)
my $index_filename = "index.html" ;
# cellpadding value for the thumbnail index tables (-p)
my $index_cellpadding = $index_cellpadding_default ;
# list links outside f the table (-L)
my $list_links = 0 ;
# how many pixels per row at most in index (--wx)
my $pixels_per_row = $pixels_per_row_default ;

# Film effects
# omit the film effect altogether (-r)
my $show_no_film_effect = 0 ;
# height of the tile.png tiled image (-t)
my $tile_height = $tile_height_default ;

# Thumbnails
# max height of a thumbnail (--xy or -y)
my $thumbnail_height_max = $thumbnail_height_max_default ;
# scale thumb longer dimension (--xy)
my $thumbnail_width_max = $thumbnail_width_max_default ;
# how many thumbnails per row at most in index (-w)
my $thumbnails_per_row = $thumbnails_per_row_default ;

# Slides
# make no slides, just thumbnail links to images (-s)
my $make_no_slides = 0 ;
# use image names as slide names (-n)
my $make_slide_filename_from_filename = 0 ;
# also use image extension in the slide names
my $make_slide_filename_from_extension = 0 ;
# use captions as slide titles (-k)
my $make_slide_title_from_caption = 0 ;
# omit the image slide from the caption (--nc)
my $show_no_slide_counter = 0 ;
# prefix of HTML slide filenames
my $slide_filenameprefix = "" ;
# prefix of HTML slide filenames when generated from filename
# while there's no file associated (text, link, ...)
my $slide_filenameprefix_nofile = "NOFILE" ;
# max width of the slides (--bigxy)
my $slide_width_max = $slide_width_max_default ;
# max height of the slides (--bigxy or --bigy)
my $slide_height_max = $slide_height_max_default ;
# default text slide width
my $text_slide_width = $text_slide_width_default ;
# default text slide height
my $text_slide_height = $text_slide_height_default ;
# use an image for link from a slide to the index, previous or next slide
my $index_link_image = 0 ;
my $prev_slide_link_image = 0 ;
my $next_slide_link_image = 0 ;

# Captions
my $captions_filename = "captions" ;
# this line will be placed in caption generated file
# the user may remove it to prevent llgal from removing the caption file with --clean
my $captions_removal_line = "REMOVE THIS LINE IF LLGAL SHOULD NOT REMOVE THIS FILE" ;
# use image comment as captions (--cc)
my $make_caption_from_image_comment = 0 ;
# use image timestamp as captions (--ct)
my $make_caption_from_image_timestamp = 0 ;
# preserve image names as captions (--cf)
my $make_caption_from_filename = 0 ;
# write captions under thumbnails on index page (-u)
my $show_caption_under_thumbnails = 0 ;
# to write image dimensions (-a or --ad)
my $show_dimensions = 0 ;
# to write image size (-a or --as)
my $show_size = 0 ;

# Exclude
my @excludes = () ;

# Text
# Change the text that prefixes the link text
my $MVI_default_link_text = "Open movie " ;
my $FIL_default_link_text = "Download file " ;
my $DIR_default_link_text = "Open subgallery " ;
# default alternative text for full-size images in slides
my $alt_full_text = "" ;
# default alternative text for scaled images in slides
my $alt_scaled_text = "Scaled image " ;
# default alternative text for thumbnails in the index
my $alt_thumbnail_text = "Thumbnail " ;
# default text for link from slides to index
my $index_link_text = "Index" ;
# title of the gallery (--title)
my $index_title = "Index of pictures" ;
# label of link from a slide to the next one
my $next_slide_link_text = "Next&gt;&gt;" ;
# default text that is shown when the mouse pointer is over a scaled image in a slide
my $over_scaled_text = "Click to see full size " ;
# default text that is shown when the mouse pointer is over a thumbnail
my $over_thumbnail_text = "Click to enlarge " ;
# text that is shown when linking to the parent gallery
my $parent_link_text = "Back to parent gallery" ;
# label of link from a slide to the previous one
my $prev_slide_link_text = "&lt;&lt;Prev" ;
# change kB to another unit (--asu)
my $show_size_unit = "kB" ;
# format of the timestamp in captions (--ctf)
my $timestamp_format_in_caption = "%Y-%m-%d %H:%M:%S" ;

# Recursion
# generate header and footer for link to parent gallery
my $parent_link = 0 ;
# add indentation to the begining of messages
my $indent = "" ;

# Various
# add all files, not only images and movies (-A)
my $add_all_files = 0 ;
# add subdirectories to entry list (-S)
my $add_subdirs = 0 ;
# options to be passed to convert (--con)
my @convert_options = () ;
my @scaled_convert_options = () ;
my @thumbnail_convert_options = () ;
# image and movie extensions
my $image_extensions = "jpe?g|tiff?|png|gif" ;
my $movie_extensions = "mpe?g|mov|avi" ;
# don't show prefix when generating link text
my $no_default_link_text = 0 ;
# sort criteria
my $sort_criteria = "name" ;
# makes everything world-readable (--www)
my $www_access_rights = 0 ;

######################################################################
# Create usage now to use defaults values

my $usage = << "END_OF_USAGE" ;
This is llgal $version the Loulous HTML image slide show generator.
Syntax:  llgal [-option -option ...]
Behavior Options:
          -d <dir>           operate on files in directory <dir> ($destination_dir)
          -f                 force thumbnail and scaled slide regeneration
          -R                 run recursively in subdirectories
          --gc               generate or update the captions file
          --gencfg <file>    generate the configuration file <file>
          --gt [<dir>]       give templates to the directory <dir>
          --templates <dir>  use templates in <dir>
          --clean            remove all generated files
          --cleanall         remove all generated and user modified files
          -v, --version      show version
          -h, --help         displays this brief help
Layout Options:
          -A              add all non-image non-video files to the list of slides
          -a              write image sizes under thumbnails on index page
          --ad            like -a, but write only the image dimensions
          --as            like -a, but write only the file size (in kbytes)
          --asu <s>       change file size unit ($show_size_unit)
          --bigy <n>      like -y, use it if you have very large image files
          --bigxy <n>     like --xy, use it if you have very large image files
          --cf            use file names as captions
          --cc [<s>]      use image comments as captions
          --ct            use image timestamps as captions
          --ctf <s>       timestamp format in captions (strftime format)
          --con <s>       options to pass to convert (e.g. -quality N)
          --exclude <s>   exclude matching files
          -i <file>       name of the main thumbnail index file ($index_filename)
          --include <s>   include matching files that were excluded
          -k              use the image captions for the HTML slide titles
          --li            use images for links in slides
          -L              list links outside of the table
          -n              use image file names for the HTML slide files
          --nc            omit the image count from the captions
          -p <n>          cellpadding value of thumbnail index tables ($index_cellpadding)
          --parent        add links to the parent directory
          -r              omit the film effect altogether
          -S              add subdirectories to the list of slides
          -s              make no HTML slides, link thumbnails to images
          --sort <s>      sort files with criteria <s>
          --sp <s>        sets the slide image prefix (\"$scaled_image_filenameprefix\")
          -t <n>          height of the film tiled image ($tile_height)
          --title <s>     string to substitute for TITLE in index template
          --tp <s>        sets the thumbnail image prefix (\"$thumbnail_image_filenameprefix\")
          -u              write captions under thumbnails on index page
          -w <n>          rows in thumbnail index are at most <n> images wide ($thumbnails_per_row)
          --www           make all llgal files world-readable
          --wx <n>        rows in thumbnail index are at most <n> pixels wide
          --xy <n>        scale thumbs to <n> pixels in their longer dimension
          -y <n>          scale all thumbnails to the same height <n> ($thumbnail_height_max)
          --config <s>    pass an additional configuration files
          --option <s>    pass an additional option as in configuration files
Note:     default values are given in parentheses (where applicable).
Author:  Brice Goglin
Homepage:  http://bgoglin.free.fr/llgal
Report bugs to:  <llgal-devel AT gna.org>
END_OF_USAGE

# process help and version now
die $usage
    if $help_asked ;
die "This is llgal version $version.\n"
    if $version_asked ;

######################################################################
# parse options in config files

sub process_option {
	$_ = shift ;
	chomp $_ ;
# llgal directories
    	if (/^llgal_share_dir\s*=\s*"(.+)"$/) {
	    $llgal_share_dir = $1 ;
	} elsif (/^user_share_dir\s*=\s*"(\/.+)"$/) {
	    $user_share_dir = $1 ;
	} elsif (/^user_share_dir\s*=\s*"(.+)"$/) {
	    $user_share_dir = $ENV{HOME}."/".$1 ;
	} elsif (/^template_dir\s*=\s*"(.+)"$/) {
	    push (@template_dirs, $1) ;
# Name of generic llgal files
	} elsif (/^captions_header_filename\s*=\s*"(.+)"$/) {
	    $captions_header_filename = $1 ;
	} elsif (/^css_filename\s*=\s*"(.+)"$/) {
	    $css_filename = $1 ;
	} elsif (/^filmtile_filename\s*=\s*"(.+)"$/) {
	    $filmtile_filename = $1 ;
	} elsif (/^index_link_image_filename\s*=\s*"(.+)"$/) {
	    $index_link_image_filename = $1 ;
	} elsif (/^prev_slide_link_image_filename\s*=\s*"(.+)"$/) {
	    $prev_slide_link_image_filename = $1 ;
	} elsif (/^next_slide_link_image_filename\s*=\s*"(.+)"$/) {
	    $next_slide_link_image_filename = $1 ;
	} elsif (/^indextemplate_filename\s*=\s*"(.+)"$/) {
	    $indextemplate_filename = $1 ;
	} elsif (/^slidetemplate_filename\s*=\s*"(.+)"$/) {
	    $slidetemplate_filename = $1 ;
# Location and name of generated files
	} elsif (/^local_llgal_dir\s*=\s*"(.+)"$/) {
	    $local_llgal_dir = $1 ;
	} elsif (/^scaled_image_filenameprefix\s*=\s*"(.+)"$/) {
	    $scaled_image_filenameprefix = $1 ;
	} elsif (/^thumbnail_image_filenameprefix\s*=\s*"(.+)"$/) {
	    $thumbnail_image_filenameprefix = $1 ;
# Index
	} elsif (/^index_filename\s*=\s*"(.+)"$/) {
	    $index_filename = $1 ;
	} elsif (/^index_cellpadding\s*=\s*(.+)$/) { # >= 0, -1 for default
	    $index_cellpadding = $1 ;
	} elsif (/^list_links\s*=\s*(.+)$/) {
	    $list_links = $1 ;
	} elsif (/^pixels_per_row\s*=\s*(.+)$/) { # > 0, 0 for unlimited, -1 for default
	    $pixels_per_row = $1 ;
# Film effect
	} elsif (/^show_no_film_effect\s*=\s*(.+)$/) {
	    $show_no_film_effect = $1 ;
	} elsif (/^tile_height\s*=\s*(.+)$/) { # >= 0, -1 for default
	    $tile_height = $1 ;
# Thumbnails
	} elsif (/^thumbnail_height_max\s*=\s*(.+)$/) { # > 0, -1 for default
	    $thumbnail_height_max = $1 ;
	} elsif (/^thumbnail_width_max\s*=\s*(.+)$/) { # > 0, 0 for unlimited, -1 for default
	    $thumbnail_width_max = $1 ;
	} elsif (/^thumbnails_per_row\s*=\s*(.+)$/) { # > 0, 0 for unlimited, -1 for default
	    $thumbnails_per_row = $1 ;
# Slides
	} elsif (/^make_no_slides\s*=\s*(.+)$/) {
	    $make_no_slides = $1 ;
	} elsif (/^make_slide_filename_from_filename\s*=\s*(.+)$/) {
	    $make_slide_filename_from_filename = $1 ;
	} elsif (/^make_slide_filename_from_extension\s*=\s*(.+)$/) {
	    $make_slide_filename_from_extension = $1 ;
	} elsif (/^make_slide_title_from_caption\s*=\s*(.+)$/) {
	    $make_slide_title_from_caption = $1 ;
	} elsif (/^show_no_slide_counter\s*=\s*(.+)$/) {
	    $show_no_slide_counter = $1 ;
	} elsif (/^slide_filenameprefix\s*=\s*"(.*)"$/) {
	    $slide_filenameprefix = $1 ;
	} elsif (/^slide_filenameprefix_nofile\s*=\s*"(.+)"$/) {
	    $slide_filenameprefix_nofile = $1 ;
	} elsif (/^slide_width_max\s*=\s*(.+)$/) { # > 0, 0 for unlimited, -1 for default
	    $slide_width_max = $1 ;
	} elsif (/^slide_height_max\s*=\s*(.+)$/) { # > 0, 0 for unlimited, -1 for default
	    $slide_height_max = $1 ;
	} elsif (/^text_slide_width\s*=\s*(.+)$/) { # > 0, -1 for default
	    $text_slide_width = $1 ;
	} elsif (/^text_slide_height\s*=\s*(.+)$/) { # > 0, -1 for default
	    $text_slide_height = $1 ;
	} elsif (/^index_link_image\s*=\s*(.+)$/) {
	    $index_link_image = $1 ;
	} elsif (/^next_slide_link_image\s*=\s*(.+)$/) {
	    $next_slide_link_image = $1 ;
	} elsif (/^prev_slide_link_image\s*=\s*(.+)$/) {
	    $prev_slide_link_image = $1 ;
# Captions
	} elsif (/^captions_filename\s*=\s*"(.+)"$/) {
	    $captions_filename = $1 ;
	} elsif (/^captions_removal_line\s*=\s*"(.+)"$/) {
	    $captions_removal_line = $1 ;
	} elsif (/^make_caption_from_image_comment\s*=\s*"(.*)"$/) {
	    $make_caption_from_image_comment = $1 ;
	} elsif (/^make_caption_from_image_timestamp\s*=\s*(.+)$/) {
	    $make_caption_from_image_timestamp = $1 ;
	} elsif (/^make_caption_from_filename\s*=\s*(.+)$/) {
	    $make_caption_from_filename = $1 ;
	} elsif (/^show_caption_under_thumbnails\s*=\s*(.+)$/) {
	    $show_caption_under_thumbnails = $1 ;
	} elsif (/^show_dimensions\s*=\s*(.+)$/) {
	    $show_dimensions = $1 ;
	} elsif (/^show_size\s*=\s*(.+)$/) {
	    $show_size = $1 ;
# Exclude
	} elsif (/^exclude\s*=\s*"(.+)"$/) {
	    my $entry ;
	    $entry->{excluded} = 1 ;
	    $entry->{filter} = $1 ;
	    push (@excludes, $entry) ;
	} elsif (/^include\s*=\s*"(.+)"$/) {
	    my $entry ;
	    $entry->{excluded} = 0 ;
	    $entry->{filter} = $1 ;
	    push (@excludes, $entry) ;
# Text
	} elsif (/^MVI_default_link_text\s*=\s*"(.*)"$/) {
	    $MVI_default_link_text = $1 ;
	} elsif (/^FIL_default_link_text\s*=\s*"(.*)"$/) {
	    $FIL_default_link_text = $1 ;
	} elsif (/^DIR_default_link_text\s*=\s*"(.*)"$/) {
	    $DIR_default_link_text = $1 ;
	} elsif (/^alt_full_text\s*=\s*"(.*)"$/) {
	    $alt_full_text = $1 ;
	} elsif (/^alt_scaled_text\s*=\s*"(.*)"$/) {
	    $alt_scaled_text = $1 ;
	} elsif (/^alt_thumbnail_text\s*=\s*"(.*)"$/) {
	    $alt_thumbnail_text = $1 ;
	} elsif (/^index_link_text\s*=\s*"(.+)"$/) {
	    $index_link_text = $1 ;
	} elsif (/^index_title\s*=\s*"(.*)"$/) {
	    $index_title = $1 ;
	} elsif (/^next_slide_link_text\s*=\s*"(.+)"$/) {
	    $next_slide_link_text = $1 ;
	} elsif (/^over_scaled_text\s*=\s*"(.*)"$/) {
	    $over_scaled_text = $1 ;
	} elsif (/^over_thumbnail_text\s*=\s*"(.*)"$/) {
	    $over_thumbnail_text = $1 ;
	} elsif (/^parent_link_text\s*=\s*"(.+)"$/) {
	    $parent_link_text = $1 ;
	} elsif (/^prev_slide_link_text\s*=\s*"(.+)"$/) {
	    $prev_slide_link_text = $1 ;
	} elsif (/^show_size_unit\s*=\s*"(.*)"$/) {
	    $show_size_unit = $1 ;
	} elsif (/^timestamp_format_in_caption\s*=\s*"(.+)"$/) {
	    $timestamp_format_in_caption = $1 ;
# Recursion
	} elsif (/^make_recursive\s*=\s*(.+)$/) {
	    $make_recursive = $1 ;
	} elsif (/^parent_link\s*=\s*(.+)$/) {
	    $parent_link = $1 ;
# Various
	} elsif (/^add_all_files\s*=\s*(.+)$/) {
	    $add_all_files = $1 ;
	} elsif (/^add_subdirs\s*=\s*(.+)$/) {
	    $add_subdirs = $1 ;
	} elsif (/^additional_configuration_file\s*=\s*"(.+)"$/) {
	    push (@additional_config_files, parse_convert_options ($1)) ;
	} elsif (/^convert_options\s*=\s*"(.*)"$/) {
	    push (@convert_options, parse_convert_options ($1)) ;
	} elsif (/^scaled_convert_options\s*=\s*"(.*)"$/) {
	    push (@scaled_convert_options, parse_convert_options ($1)) ;
	} elsif (/^thumbnail_convert_options\s*=\s*"(.*)"$/) {
	    push (@thumbnail_convert_options, $1) ;
	} elsif (/^image_extensions\s*=\s*"(.*)"$/) {
	    $image_extensions = $1 ;
	} elsif (/^movie_extensions\s*=\s*"(.*)"$/) {
	    $movie_extensions = $1 ;
	} elsif (/^no_default_link_text\s*=\s*(.+)$/) {
	    $no_default_link_text = $1 ;
	} elsif (/^sort_criteria\s*=\s*"(.+)"$/) {
	    $sort_criteria = $1 ;
	} elsif (/^www_access_rights\s*=\s*(.+)$/) {
	    $www_access_rights = $1 ;
# Error
	} elsif (/^[^#]/ && !/^(\s*)$/) {
	    die "Unrecognized option line #$.: \"$_\"\n" ;
	}
}

# parse config files
foreach my $conf ( @config_files ) {
    open CONF, $conf ;
    while (<CONF>) {
	process_option $_ ;
    }
   close CONF ;
}

foreach my $conf ( @additional_config_files ) {
    open CONF, $conf
	or die "Failed to open additional configuration file '$conf' ($!).\n" ;
    while (<CONF>) {
	process_option $_ ;
    }
   close CONF ;
}

######################################################################
# process command-line arguments (overriding defaults above)

GetOptions(
           'A'          => \$add_all_files,
	   'a'		=> sub { $show_dimensions = $show_size = 1 ; },
	   'ad'		=> \$show_dimensions,
	   'as'		=> \$show_size,
	   'asu=s'	=> \$show_size_unit,
	   'cf'		=> \$make_caption_from_filename,
	   'cc:s'	=> sub { shift ; my $value = shift ;
				 if ($value eq "") { $make_caption_from_image_comment = "std,exif" ; }
				 elsif ($value eq "0") { $make_caption_from_image_comment = "" ; }
				 else { $make_caption_from_image_comment = $value ; }
			     },
	   'ct'		=> \$make_caption_from_image_timestamp,
	   'ctf=s'      => \$timestamp_format_in_caption,
	   'i=s'	=> \$index_filename,
	   'indent=s'   => \$indent,
	   'k'		=> \$make_slide_title_from_caption,
	   'L'          => \$list_links,
	   'li'		=> sub { $index_link_image = 1 ; $prev_slide_link_image = 1 ; $next_slide_link_image = 1 ; },
	   'n'		=> \$make_slide_filename_from_filename,
	   'nc'		=> \$show_no_slide_counter,
	   'p=i'	=> \$index_cellpadding,
	   'parent'     => \$parent_link,
           'r'		=> \$show_no_film_effect,
           'S'          => \$add_subdirs,
	   's'		=> \$make_no_slides,
	   't=i'	=> \$tile_height,
	   'u'		=> \$show_caption_under_thumbnails,
	   'w=i'	=> \$thumbnails_per_row,
	   'y=i'	=> \$thumbnail_height_max,
	   'bigy=i'	=> \$slide_height_max,
	   'bigxy=i'    => sub { shift ; $slide_width_max = $slide_height_max = shift ; },
           'con=s'	=> sub { shift ; push (@convert_options, parse_convert_options (shift)) ; },
           'sort=s'     => \$sort_criteria,
	   'sp=s'	=> \$scaled_image_filenameprefix,
	   'title=s'	=> \$index_title,
           'tp=s'	=> \$thumbnail_image_filenameprefix,
	   'www'	=> \$www_access_rights,
	   'wx=i'	=> \$pixels_per_row,
	   'xy=i'	=> sub { shift ; $thumbnail_width_max = $thumbnail_height_max = shift ; },
	   'option=s'	=> sub { shift ; process_option (shift) ; },
           'exclude=s'  => sub { shift ; my $entry ; $entry->{filter} = shift ; $entry->{excluded} = 1 ; push @excludes, $entry ; },
           'include=s'  => sub { shift ; my $entry ; $entry->{filter} = shift ; $entry->{excluded} = 0 ; push @excludes, $entry ; },
	) or die $usage ;

######################################################################
# a few routines

# Print messages with indentation according to recursion level

sub indprint {
    print $indent ;
    print @_ ;
}

# Warnings are shown after each step of processing to avoid
# breaking precentage progressions and so

my $tmp_warning = "" ;

sub add_warning {
    $tmp_warning .= "!! ".(shift)."\n" ;
}

sub add_external_warnings {
    while (@_) {
	my $line = shift ;
	chomp $line ;
	add_warning "# $line" ;
    }
}

sub show_warnings {
    print $tmp_warning ;
    $tmp_warning = "" ;
}

sub immediate_warning {
    print "!! ".(shift)."\n" ;
}

sub immediate_external_warnings {
    while (@_) {
	my $line = shift ;
	chomp $line ;
	immediate_warning "# $line" ;
    }
}

# Print percentage

sub init_percentage {
    print "  0%" ;
}

sub print_percentage {
    my ($i,$n) = (shift,shift) ;
    my $val = int($i*100/$n) ;
    print "\b\b\b\b" ;
    if ($val == 100) {
	print "100%" ;
    } elsif ($val >= 10) {
	print " ".$val."%" ;
    } else {
	print "  ".$val."%" ;
    }
}

sub end_percentage {
    print "\b\b\b\b100%\n" ;
}

# system routine which:
# - takes a description followed by cmdline arguments
# - returns a table composed of the status followed by STDERR and STDOUT lines

sub system_with_output {
    my $descr = shift ;
    pipe (my $pipe_out, my $pipe_in) ;
    my $pid = fork() ;
    if ($pid < 0) {
	close $pipe_in ;
	close $pipe_out ;
	return ( -1, "Fork failed while trying to $descr\n" ) ;
    } elsif ($pid > 0) {
	close $pipe_in ;
	waitpid ($pid, 0) ;
	my $status = $? >> 8 ;
	$status = -1
	    if $status == 255 ;
	my @lines = <$pipe_out> ;
	close $pipe_out ;
	return ( $status , @lines ) ;
    } else {
	close $pipe_out ;
	open STDERR, ">&", $pipe_in ;
	open STDOUT, ">&", $pipe_in ;
	{ exec @_ } ;
	print $pipe_in "Exec of @_[0] failed while trying to $descr\n" ;
	close $pipe_in ;
	exit -1 ;
    }
}

# check whether an argument is an integer

sub is_integer {
    my $s = shift ;
    return $s eq int($s) ;
}

# copy a file
sub copy_file {
    my $filename = shift ;
    my $srcdir = shift ;
    my $destdir = shift ;
    my ($status, @output) = system_with_output
	("copy '$filename' from '$srcdir'",
	"cp", "-f", "$srcdir/$filename", "$destdir/$filename") ;
    if ($status) {
	# die on whatever error
	immediate_external_warnings @output ;
	die "Failed to get generic '$filename' file.\n" ;
    }
}

# find path to the template file in generic directories
sub find_generic_template_file {
    my ($filename, $check) = (shift, shift) ;
    foreach my $dir (@template_dirs) {
	return $dir
	    if -e "$dir/$filename" ;
    }
    return $user_share_dir
	if -e "$user_share_dir/$filename" ;
    die "File '$llgal_share_dir/$filename' does not exist.\nPlease install llgal properly.\n"
	unless -e "$llgal_share_dir/$filename" || !$check ;
    return $llgal_share_dir ;
}

# find path to the template, using the local one if it exists
sub find_template_file {
    my ($filename, $check) = (shift, shift) ;
    return $local_llgal_dir
	if -e "$local_llgal_dir/$filename" ;
    return find_generic_template_file ($filename, $check) ;
}

# get a template file from generic directories and save it to local directory
sub get_template_file {
    my $filename = shift ;
    if (-e "$destination_dir$local_llgal_dir/$filename") {
	indprint "Found $filename in $destination_dir$local_llgal_dir/, using it.\n" ;
    } else {
	my $srcdir = find_generic_template_file ($filename, 1) ;
	indprint "No $filename in $destination_dir$local_llgal_dir/, getting a copy from $srcdir\n" ;
	copy_file ($filename, $srcdir, "$destination_dir$local_llgal_dir" ) ;
    }
}

######################################################################
# sanity checks and restore defaults of numerical options

# Are we in .llgal ? just check the last part of the path by concatening
# pwd and destination_dir even if destination_dir is an absolute path
my $path = getcwd."/".$destination_dir ;
if ($path =~ m@/*(?:[^/]+/+)*([^/]+)/+$@) {
    if ($1 eq $local_llgal_dir) {
	immediate_warning "!! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !!" ;
	immediate_warning "Your working directory looks like a .llgal directory. !!" ;
	immediate_warning "This might not be what you really want to do.         !!" ;
	immediate_warning "!! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !!" ;
    }
}

# thumbnail_width_max must be > 0 or 0 for unlimited
die "Please give an integer value for thumbnail width max\n"
    unless is_integer ($thumbnail_width_max) ;
if ($thumbnail_width_max < 0) {
    indprint "Thumbnail width max value < 0, restoring to default (".
	($thumbnail_width_max_default?$thumbnail_width_max_default:"unlimited") .")\n" ;
    $thumbnail_width_max = $thumbnail_width_max_default ;
}
die "Please give a positive thumbnail width max value (or 0 for unlimited)\n"
    unless $thumbnail_width_max >= 0 ;

# thumbnail_height_max must be > 0
die "Please give an integer value for thumbnail height max\n"
    unless is_integer ($thumbnail_height_max) ;
if ($thumbnail_height_max < 0) {
    indprint "Thumbnail height max value < 0, restoring to default ($thumbnail_height_max_default)\n" ;
    $thumbnail_height_max = $thumbnail_height_max_default ;
}
die "Please give a positive thumbnail height max value\n"
    unless $thumbnail_height_max > 0 ;

# thumbnails_per_row must be > 0 or 0 for unlimited
die "Please give an integer value for thumbnails per row\n"
    unless is_integer ($thumbnails_per_row) ;
if ($thumbnails_per_row < 0) {
    indprint "Thumbnails per row value < 0, restoring to default (".
	($thumbnails_per_row_default?$thumbnails_per_row_default:"unlimited") .")\n" ;
    $thumbnails_per_row = $thumbnails_per_row_default ;
}
die "Please give a positive thumbnails per row value (or 0 for unlimited)\n"
    unless $thumbnails_per_row >= 0 ;

# pixels_per_row must be > 0 or 0 for unlimited
die "Please give an integer value for pixels per row\n"
    unless is_integer ($pixels_per_row) ;
if ($pixels_per_row < 0) {
    indprint "Pixels per row value < 0, restoring to default (".
	($pixels_per_row_default?$pixels_per_row_default:"unlimited") .")\n" ;
    $pixels_per_row = $pixels_per_row_default ;
}
die "Please give a positive pixels per row value (or 0 for unlimited)\n"
    unless $pixels_per_row >= 0 ;

# index_cellpadding must be >= 0
die "Please give an integer value for index cellpadding\n"
    unless is_integer ($index_cellpadding) ;
if ($index_cellpadding < 0) {
    indprint "Index cellpadding value < 0, restoring to default ($index_cellpadding_default)\n" ;
    $index_cellpadding = $index_cellpadding_default ;
}
die "Please give a positive or null index cellpadding value\n"
    unless $index_cellpadding >= 0 ;

# tile_height must be >= 0
die "Please give an integer value for tile height\n"
    unless is_integer ($tile_height) ;
if ($tile_height < 0) {
    indprint "Tile height value < 0, restoring to default value ($tile_height_default)\n" ;
    $tile_height = $tile_height_default ;
}
die "Please give a positive or null tile height value\n"
    unless $tile_height >= 0 ;

# text_slide_width must be > 0
die "Please give an integer value for text slide width\n"
    unless is_integer ($text_slide_width) ;
if ($text_slide_width < 0) {
    indprint "Text slide width value < 0, restoring to default ($text_slide_width_default)\n" ;
    $text_slide_width = $text_slide_width_default ;
}
die "Please give a positive text slide width value\n"
    unless $text_slide_width > 0 ;

# text_slide_height must be > 0
die "Please give an integer value for text slide height\n"
    unless is_integer ($text_slide_height) ;
if ($text_slide_height < 0) {
    indprint "Text slide height value < 0, restoring to default ($text_slide_height_default)\n" ;
    $text_slide_height = $text_slide_height_default ;
}
die "Please give a positive text slide height value\n"
    unless $text_slide_height > 0 ;

# slide_width_max must be > 0, 0 for unlimited
die "Please give an integer value for slide width max\n"
    unless is_integer ($slide_width_max) ;
if ($slide_width_max < 0) {
    indprint "Slide width max value < 0, restoring to default (".
	($slide_width_max_default?$slide_width_max_default:"unlimited") .")\n" ;
    $slide_width_max = $slide_width_max_default ;
}
die "Please give a positive slide width max value (or 0 for unlimited)\n"
    unless $slide_width_max >= 0 ;

# slide_height_max must be > 0, 0 for unlimited
die "Please give an integer value for slide height max\n"
    unless is_integer ($slide_height_max) ;
if ($slide_height_max < 0) {
    indprint "Slide height max value < 0, restoring to default (".
	($slide_height_max_default?$slide_height_max_default:"unlimited") .")\n" ;
    $slide_height_max = $slide_height_max_default ;
}
die "Please give a positive slide height max value (or 0 for unlimited)\n"
    unless $slide_height_max >= 0 ;

# either pixels or thumbnails per row must be limited
die "Please limit pixels or thumbnails per row\n"
    unless $pixels_per_row > 0 or $thumbnails_per_row > 0 ;

######################################################################
# other sanity check

# cannot have --bigy/xy and -s
die "Please choose between --bigy/xy and -s\n"
    if ($slide_height_max or $slide_width_max) && $make_no_slides ;

# check a few string that have to be non-empty
die "Please give a non-empty llgal share directory\n"
    if $llgal_share_dir eq "" ;
die "Please give a non-empty user share directory\n"
    if $user_share_dir eq "" ;
die "Please give a non-empty CSS filename\n"
    if $css_filename eq "" ;
die "Please give a non-empty film tile filename\n"
    if $filmtile_filename eq "" ;
die "Please give a non-empty index link image filename\n"
    if $index_link_image_filename eq "" ;
die "Please give a non-empty previous slide link image filename\n"
    if $prev_slide_link_image_filename eq "" ;
die "Please give a non-empty next slide link image filename\n"
    if $next_slide_link_image_filename eq "" ;
die "Please give a non-empty index template filename\n"
    if $indextemplate_filename eq "" ;
die "Please give a non-empty slide template filename\n"
    if $slidetemplate_filename eq "" ;
die "Please give a non-empty local llgal directory\n"
    if $local_llgal_dir eq "" ;
die "Please give a non-empty slide filename prefix\n"
    if $scaled_image_filenameprefix eq "" ;
die "Please give a non-empty thumbnail filename prefix\n"
    if $thumbnail_image_filenameprefix eq "" ;
die "Please give a non-empty index filename\n"
    if $index_filename eq "" ;
die "Please give a non-empty caption filename\n"
    if $captions_filename eq "" ;
die "Please give a non-empty caption removal line\n"
    if $captions_removal_line eq "" ;

######################################################################
# prepare a few globals for later

# adapt text slide width and height in case of --bigxy or --bigy
if ($slide_height_max > 0) {
    $text_slide_width = $text_slide_width / $text_slide_height * $slide_height_max ;
    $text_slide_height = $slide_height_max ;
}
if ($slide_width_max > 0 and $text_slide_width > $slide_width_max) {
    $text_slide_height = $text_slide_height / $text_slide_width * $slide_width_max ;
    $text_slide_width = $slide_width_max ;
}

# thumbnail default size (for text and link slide especially)
my ($default_thumb_xdim, $default_thumb_ydim) ;
if ($thumbnail_width_max > 0) {
    ($default_thumb_xdim, $default_thumb_ydim) = ($thumbnail_width_max, $thumbnail_height_max) ;
} else {
    ($default_thumb_xdim, $default_thumb_ydim) = ($thumbnail_height_max * 4/3, $thumbnail_height_max) ;
}

# convert options for thumbnails
my @thumbnail_scale_options ;
if ($thumbnail_width_max > 0) {
    @thumbnail_scale_options = ("-scale", $thumbnail_width_max."x".$thumbnail_height_max.">") ;
} else {
    @thumbnail_scale_options = ("-scale", "x".$thumbnail_height_max) ;
}
my @thumbnail_create_command = ("convert", "+profile", "*", @convert_options, @thumbnail_convert_options, @thumbnail_scale_options) ;

# convert options for slides
my @slide_create_command = ("convert", "+profile", "*", @convert_options, @scaled_convert_options ) ;
if ($slide_height_max > 0) {
    if ($slide_width_max > 0) {
	push (@slide_create_command, ("-scale", "${slide_width_max}x$slide_height_max")) ;
    } else {
	push (@slide_create_command, ("-scale", "x$slide_height_max")) ;
    }
} else {
    if ($slide_width_max > 0) {
	push (@slide_create_command, ("-scale", "${slide_width_max}x")) ;
    }
}
my @slide_copy_command = ("cp", "-f") ;

######################################################################
# --clean and --cleanall option

sub clean_files {
    my $cleanall = shift ;
    my $notdeleted = 0 ;

    opendir DIR, "$destination_dir$local_llgal_dir"
	or die "Can't open directory $destination_dir$local_llgal_dir ($!)\n" ;
    while ($_ = readdir DIR) {
	if (/^$thumbnail_image_filenameprefix/ or /^$scaled_image_filenameprefix/) {
	    unlink "$destination_dir$local_llgal_dir/$_" ;
	} elsif (/^$filmtile_filename$/ or /^$index_link_image_filename$/
		 or /^$prev_slide_link_image_filename$/ or /^$next_slide_link_image_filename$/
		 or /^$css_filename$/) {
	    my $original = (find_generic_template_file $_, 0)."/".$_ ;
	    my $diff = 0 ;
	    my @output ;
	    # default is cleanall, which removes everything, as if file were not changed
	    if (!$cleanall) {
		($diff, @output) = system_with_output
		    ("compare $_ with its original",
		     "cmp", "-s", "$destination_dir$local_llgal_dir/$_", "$original") ;
		if ($diff == -1) {
		    immediate_external_warnings @output ;
		    die "Failed to execute 'cmp' to check whether '$destination_dir$local_llgal_dir/$_' has been modified ($!).\n" ;
		}
		add_external_warnings @output ;
		# on other errors, assume files are different ($diff != 0)
	    }
	    if ($diff) {
		add_warning "Preserved '$destination_dir$local_llgal_dir/$_' since it seems to be modified." ;
		$notdeleted++ ;
	    } else {
		if (!unlink "$destination_dir$local_llgal_dir/$_" and ! $!{ENOENT}) {
		    add_warning "Failed to remove file '$destination_dir$local_llgal_dir/$_'." ;
		}
	    }
	} elsif (/^$captions_filename$/) {
	    my $grep = 0 ;
	    my @output ;
	    # default is cleanall, which removes everything, as if the removal line was here
	    if (!$cleanall) {
		($grep, @output) = system_with_output
		    ("check for caption removal line",
		     "grep", "-q", "$captions_removal_line", "$destination_dir$local_llgal_dir/$_") ;
		if ($grep == -1) {
		    immediate_external_warnings @output ;
		    die "Failed to execute 'grep' to check whether '$destination_dir$local_llgal_dir/$_' has been modified ($!).\n" ;
		}
		add_external_warnings @output ;
		# on other errors, assume file doesn't contain the caption removal line ($grep != 0)
	    }
	    if ($grep) {
		add_warning "Preserved '$destination_dir$local_llgal_dir/$_' since it seems to be modified." ;
		$notdeleted++ ;
	    } else {
		if (!unlink "$destination_dir$local_llgal_dir/$_" and ! $!{ENOENT}) {
		    add_warning "Failed to remove file '$destination_dir$local_llgal_dir/$_'." ;
		}
	    }
	} else {
	    $notdeleted++ ;
	}
    }
    closedir DIR ;
    if ($notdeleted <= 2 && $cleanall) {
	if (!rmdir "$destination_dir$local_llgal_dir"  and ! $!{ENOENT}) {
	    add_warning "Failed to remove directory '$destination_dir$local_llgal_dir' ($!)." ;
	}
    }

    opendir DIR, "./$destination_dir" ; # destination is empty for './'
    while ($_ = readdir DIR ) {
	if (/.html$/) {
	    unlink "$destination_dir$_" ;
	}
    }
    closedir DIR ;
}

if ($clean_asked) {
    indprint "Removing all non-modified llgal files...\n" ;
    clean_files 0 ;
    show_warnings ;

    if ($make_recursive) {
	opendir DIR, "./$destination_dir" ; # destination is empty for './'
	while (my $dir = readdir DIR) {
	    if ($dir =~ /^[^.]/ && -d "$destination_dir$dir") {
		print "\n" ;
		indprint "Entering subdirectory '$dir'...\n" ;
		system ( $0, @llgal_options, "-d", "$destination_dir$dir", "--indent", $indent."  " ) ;
		die "Failed to call $0 for subdirectory $destination_dir$dir ($!).\n"
		    if $? == -1 ;
		immediate_warning "$0 failed for subdirectory $destination_dir$dir."
		    if $? ;
		indprint "Leaving subdirectory '$dir'.\n" ;
	    }
	}
    }
    closedir DIR ;
    exit 0 ;
}

if ($cleanall_asked) {
    indprint "Removing all llgal files...\n" ;
    clean_files 1 ;
    show_warnings ;

    if ($make_recursive) {
	opendir DIR, "./$destination_dir" ; # destination is empty for './'
	while (my $dir = readdir DIR) {
	    if ($dir =~ /^[^.]/ && -d "$destination_dir$dir") {
		print "\n" ;
		indprint "Entering subdirectory '$dir'...\n" ;
		system ( $0, @llgal_options, "-d", "$destination_dir$dir", "--indent", $indent."  " ) ;
		die "Failed to call $0 for subdirectory $destination_dir$dir ($!).\n"
		    if $? == -1 ;
		immediate_warning "$0 failed for subdirectory $destination_dir$dir."
		    if $? ;
		indprint "Leaving subdirectory '$dir'.\n" ;
	    }
	}
    }
    closedir DIR ;
    exit 0 ;
}

#####################################################################
# give templates to the given directory

if ($give_templates) {
    my $destdir = $give_templates ;
    $destdir = $local_llgal_dir
	if $destdir eq "local" ;
    $destdir = $user_share_dir
	if $destdir eq "user" ;

    if ( ! -e $destdir ) {
	indprint "Creating template directory $destdir...\n" ;
	mkdir $destdir
	    or die "Failed to create $destdir ($!)" ;
    }

    foreach my $filename
	( $css_filename, $filmtile_filename, $index_link_image_filename,
	  $prev_slide_link_image_filename, $next_slide_link_image_filename,
	  $indextemplate_filename, $slidetemplate_filename ) {
	if ( -e "$destdir/$filename" ) {
	    indprint "$filename already exists in $destdir.\n" ;
	} else {
	    my $srcdir = find_generic_template_file ($filename, 1) ;
	    indprint "$filename does not exist in $destdir, getting a copy from $srcdir...\n" ;
	    copy_file ($filename, $srcdir, $destdir ) ;
	}
    }

    indprint "You may now edit templates in $destdir and generate new galleries.\n" ;
    indprint "You may also remove any template that you do not want to modify.\n" ;

    exit 0 ;
}

#####################################################################
# Main variables

# The whole entry list
my @entries ;
# Entries are hashed composed of
# - type: see below
# - filename (original filename with extension)
# - url (url of the filename)
# - linktext (an associated text that may be used in a link, www-safe)
# - caption (the caption of the slide, www-safe)
# - title (title, www-safe)

# - xdim, ydim, kbytes (details about the image or movie)
# - dimstring (string containing dimensions and/or size that were requested)

# - slide_filename (name of the HTML slide filename)
# - slide_url (url of the HTML slide filename)

# - thumb_xdim, thumb_ydim (details about the thumbnail image)
# - thumb_dimstring (string containing dimensions)
# - thumb_filename (name of the thumbnail image file)
# - thumb_url (url of the thumbnail image file)

# - scaled_xdim, scaled_ydim, scaled_kbytes (details about the scaled image)
# - scaled_dimstring (string containing dimensions and/or size that were requested)
# - scaled_filename (name of the scaled image file)
# - scaled_url (url of the scaled image file)

# types
my $TYPE_TXT = 0 ;
my $TYPE_LNK = 1 ;
my $TYPE_IMG = 2 ;
my $TYPE_MVI = 3 ;
my $TYPE_FIL = 4 ;
my $TYPE_DIR = 5 ;

# number of entries that don't have any file associated with them
my $nofiles = 0 ;

# headers and footers
my @headers = () ;
my @footers = () ;

# list of entries which are shown as simple links
my @listed_links = () ;

###################################################################################
# generating safe url

sub make_safe_url_nowarn {
    my $file = shift ;
    my $safe = uri_escape ($file) ;
    return $safe ;
}

sub make_safe_url {
    my $file = shift ;
    my $safe = uri_escape ($file) ;

    add_warning "Non-ascii characters were escaped in filename '$file'."
	if $safe ne $file and $file =~ /[\x80-\xFF]/ ;

    return $safe ;
}

# Create the url of the local llgal directory
my $local_llgal_url = make_safe_url_nowarn ($local_llgal_dir) ;

###################################################################################
# checking files

my $nexcludes = @excludes ;

sub check_file {
    my $filename = shift ;

    if (! -e $filename) {
	add_warning "Cannot find file '$filename', skipping it." ;
	return -1 ;
    }

    my $excluded = 0 ;
    for(my $i = 0; $i < $nexcludes; $i++) {
	my $entry = @excludes[$i] ;
	if ($filename =~ /^(.*\/)*$entry->{filter}$/) {
	    $excluded = $entry->{excluded}
	}
    }
    return -1
	if $excluded ;

    return 0 ;
}

sub check_image {
    my $filename = shift ;
    my ($status, @output) = system_with_output
	( "check \"$filename\" validity",
	  "identify", $filename ) ;
    if ($status == -1) {
	immediate_external_warnings @output ;
	die "Failed to check \"$filename\" validity\n" ;
    } elsif ($status) {
	# do not show external warnings
	add_warning "Bad image file '$filename', skipping it." ;
	return -1 ;
    }
    return 0 ;
}

sub check_movie {
    # TODO
    return 0 ;
}

###################################################################################
# extract caption from image infos

# Standard comment such as JFIF or GIF
sub std_comment {
    my $filename = shift ;
    my $infos = shift ;
    my $comment = $infos->{Comment} ;
    if (ref($comment) eq 'ARRAY' ) {
	# concat string array
	$comment = join(' ', @{$comment}) ;
    }
    # remove \000
    $comment =~ s/\000//g ;
    return $comment ;
}

# Exif comment
sub exif_comment {
    my $filename = shift ;
    my $infos = shift ;
    my $comment = $infos->{UserComment} ;
    # Remove trailing spaces
    $comment =~ s/\s*$// ;
    if ($comment =~ /^ASCII\0\0\0(.*)$/) {
	# ASCII Exif Comment
	return  $1 ;
    } elsif (substr ($comment,0,8) ne "\0\0\0\0\0\0\0\0") {
	add_warning "Unrecognized Exif UserComment '$comment' length ".(length $comment)." in image '$filename'\n" ;
    }
    return "" ;
}

# Image comment
sub generate_caption_from_image_comment {
    my $filename = shift ;
    my $infos = shift ;
    my @texts = () ;
    # Loop until a non-empty comment list is found
    foreach my $types (split (/,/, $make_caption_from_image_comment)) {
	# types is a + separated string of types
	foreach my $type (split (/\+/, $types)) {
	    if ($type =~ /^std$/i) {
		my $comment = std_comment ($filename, $infos) ;
		push (@texts, $comment)
		    if $comment ;
	    } elsif ($type =~ /^exif$/i) {
		my $comment = exif_comment ($filename, $infos) ;
		push (@texts, $comment)
		    if $comment ;
	    } else {
		die "Unrecognized image comment type '$type'\n" ;
	    }
	}
	return @texts
	    if @texts ;
    }
    return () ;
}

# Image timestamp
sub generate_caption_from_image_timestamp {
    my $filename = shift ;
    my $infos = shift ;
    my $imagetime = $infos->{DateTimeOriginal} ;
    if ($imagetime ne "") {
	my @timearray = split (/[: ]/, $imagetime) ;
	my @gmtime = ($timearray[5], $timearray[4], $timearray[3], $timearray[2], $timearray[1]-1, $timearray[0]-1900, 0, 0) ;
	return strftime ($timestamp_format_in_caption, @gmtime) ;
    }
    return "" ;
}

# Image infos
sub generate_caption_from_image_infos {
     my $filename = shift ;
     my $infos = image_info ("$destination_dir$filename") ;
     my @texts = () ;
     if ($make_caption_from_image_comment) {
	 my @comments = generate_caption_from_image_comment ($filename, $infos) ;
	 push (@texts, @comments) ;
     }
     if ($make_caption_from_image_timestamp) {
	 my $timestamp = generate_caption_from_image_timestamp ($filename, $infos) ;
	 push (@texts, $timestamp) ;
     }
     return @texts ;
 }

###################################################################################
# generate entries

sub create_entry {
    my $entry ;
    my $type = shift ;
    my $filename = shift ;
    my $url = shift ;
    my $linktext = shift ;
    my $caption = shift ;

    # check files
    if ($type == $TYPE_IMG or $type == $TYPE_MVI or $type == $TYPE_FIL or $type == $TYPE_DIR) {
	return undef
	    if check_file ("$destination_dir$filename") < 0 ;
	if ($type == $TYPE_IMG) {
	    return undef
		if check_image ("$destination_dir$filename") < 0 ;
	} elsif ($type == $TYPE_MVI) {
	    return undef
		if check_movie ("$destination_dir$filename") < 0 ;
	}
    }

    # set the type
    $entry->{type} = $type ;

    # set the filename
    if (not defined $filename) {
	$filename = $slide_filenameprefix_nofile.($nofiles++) ;
    }
    $entry->{filename} = $filename ;

    # keep real filename for later
    my $real_filename = "$destination_dir$filename" ;

    # make a safe url
    if (not defined $url) {
	$url = $filename ;
    }
    $entry->{url} = make_safe_url ($url) ;

    # the link text (will be HTML-safe after caption file generation)
    if (not defined $linktext) {
	if (!$no_default_link_text) {
	    if ($type == $TYPE_MVI) {
		$linktext = $MVI_default_link_text.$filename ;
	    } elsif ($type == $TYPE_FIL) {
		$linktext = $FIL_default_link_text.$filename ;
	    } elsif ($type == $TYPE_DIR) {
		$linktext = $DIR_default_link_text.$filename ;
	    }
	} else {
	    $linktext = $filename ;
	}
	$linktext =~ s/&/&amp;/g ;
#       $linktext =~ s/"/&\#34;/g ;
    }
    $entry->{linktext} = $linktext ;

    # the caption (will be HTML-safe after caption file generation)
    if (not defined $caption) {
	my @texts = () ;
	push (@texts, $filename)
	    if $make_caption_from_filename ;
	push (@texts, generate_caption_from_image_infos ($filename))
	    if $type == $TYPE_IMG ;
	$caption = join (' - ', grep {$_} @texts) ;
	$caption =~ s/&/&amp;/g ;
#	$caption =~ s/"/&\#34;/g ;
    }
    chomp $caption ;
    $entry->{caption} = $caption ;

    # title is based on the filename
    my $title = $filename ;
    $title =~ s/&/&amp;/g ;
#    $title =~ s/"/&\#34;/g ;
    
    # add caption to the title if asked
    $title .= ": ". $caption
	if $make_slide_title_from_caption ;

    $entry->{title} = $title ;

    # do not generate more if we are only generating captions
    return $entry
	if $generate_captions ;

    # xdim, ydim, kbytes of the image or movie
    if ($type == $TYPE_IMG) {
	my ($x,$y) = imgsize ("$destination_dir$filename") ;
	$entry->{xdim} = $x ;
	$entry->{ydim} = $y ;
	# initialize here so that we can use it even when scaled are not used
	$entry->{scaled_xdim} = $x ;
	$entry->{scaled_ydim} = $y ;
    }
    if ($type == $TYPE_IMG or $type == $TYPE_MVI or $type == $TYPE_FIL) {
	my $kbytes = (-s "$destination_dir$filename") >> 10 ;
	$entry->{kbytes} = $kbytes ;
	# initialize here so that we can use it even when scaled are not used
	$entry->{scaled_kbytes} = $kbytes ;
    }

    # dimstring
    if ($type == $TYPE_IMG) {
	if ($show_dimensions && $show_size) {
	    $entry->{dimstring} = "($entry->{xdim}x$entry->{ydim}, $entry->{kbytes}$show_size_unit)" ;
	} elsif ($show_size) {
	    $entry->{dimstring} = "($entry->{kbytes}$show_size_unit)" ;
	} elsif ($show_dimensions) {
	    $entry->{dimstring} = "($entry->{xdim}x$entry->{ydim})" ;
	} else {
	    $entry->{dimstring} = "" ;
	}
    } elsif ($type == $TYPE_MVI or $type == $TYPE_FIL) {
	if ($show_size) {
	    $entry->{dimstring} = "($entry->{kbytes}$show_size_unit)" ;
	} else {
	    $entry->{dimstring} = "" ;
	}
    } else {
	$entry->{dimstring} = "" ;
    }

    # thumbnail, its url and dimensions
    if ($type == $TYPE_IMG) {
	# filename and url
	my $thumbnail_filename = "$thumbnail_image_filenameprefix$filename" ;
	$entry->{thumb_filename} = "$local_llgal_dir/$thumbnail_filename" ;
	$entry->{thumb_url} = "$local_llgal_url/". make_safe_url_nowarn ($thumbnail_filename) ;

	# thumbnails dimensions
	my $real_thumb_filename = "$destination_dir$entry->{thumb_filename}" ;
	if ((! -e "$real_thumb_filename") or $force_regen_asked) {
	    my ($status, @output) = system_with_output
		( "create '$real_filename' thumbnail",
		  @thumbnail_create_command, "$real_filename", "$real_thumb_filename" ) ;
	    if ($status == -1) {
		immediate_external_warnings @output ;
		die "Failed to create '$real_filename' thumbnail\n" ;
	    } elsif ($status) {
		add_warning "Failed to create '$real_filename' thumbnail" ;
		add_external_warnings @output ;
		return undef ;
	    }
	}
	($entry->{thumb_xdim},$entry->{thumb_ydim}) = imgsize ("$real_thumb_filename") ;

	# dimstring
	if ($show_dimensions) {
	    $entry->{thumb_dimstring} = "($entry->{thumb_xdim}x$entry->{thumb_ydim})" ;
	} else {
	    $entry->{thumb_dimstring} = "" ;
	}

    } else {
	# default thumbnail dimensions
	$entry->{thumb_xdim} = $default_thumb_xdim ;
	$entry->{thumb_ydim} = $default_thumb_ydim ;

	# dimstring is empty
        $entry->{thumb_dimstring} = "" ;
    }

    if (!$make_no_slides) {
	# scaled image, its url and dimensions
	if ($type == $TYPE_IMG and ($slide_width_max > 0 or $slide_height_max > 0)) {
	    # filename and url
	    my $scaled_filename = "$scaled_image_filenameprefix$filename" ;
	    $entry->{scaled_filename} = "$local_llgal_dir/$scaled_filename" ;
	    $entry->{scaled_url} = "$local_llgal_url/". make_safe_url_nowarn ($scaled_filename) ;

	    # scaled image dimensions
	    my $real_scaled_filename = "$destination_dir$entry->{scaled_filename}" ;
	    my ($x,$y) ;
	    if ((! -e "$real_scaled_filename") or $force_regen_asked) {
		# only scale down, never up.
		($x,$y) = imgsize ("$real_filename") ;
		my ($status, @output) ;
		if ($x <= $slide_width_max and $y <= $slide_height_max) {
		    ($status, @output) = system_with_output
			( "copy '$real_filename' scaled image",
			  @slide_copy_command, "$real_filename", "$real_scaled_filename" ) ;
		} else {
		    ($status, @output) = system_with_output
			( "create '$real_filename' scaled image",
			  @slide_create_command, "$real_filename", "$real_scaled_filename" ) ;
		}
		if ($status == -1) {
		    immediate_external_warnings @output ;
		    die "Failed to create '$real_filename' scaled image\n" ;
		} elsif ($status) {
		    add_warning "Failed to create '$real_filename' scaled image" ;
		    add_external_warnings @output ;
		    return undef ;
		}
	    }
	    ($x,$y) = imgsize ("$real_scaled_filename") ;
	    $entry->{scaled_xdim} = $x ;
	    $entry->{scaled_ydim} = $y ;
	    $entry->{scaled_kbytes} = (-s "$real_scaled_filename") >> 10 ;

	    # dimstring
	    if ($show_dimensions && $show_size) {
		$entry->{scaled_dimstring} = "($entry->{scaled_xdim}x$entry->{scaled_ydim}, $entry->{scaled_kbytes}$show_size_unit)" ;
	    } elsif ($show_size) {
		$entry->{scaled_dimstring} = "($entry->{scaled_kbytes}$show_size_unit)" ;
	    } elsif ($show_dimensions) {
		$entry->{scaled_dimstring} = "($entry->{scaled_xdim}x$entry->{scaled_ydim})" ;
	    } else {
		$entry->{scaled_dimstring} = "" ;
	    }

	} else {
	    $entry->{scaled_dimstring} = $entry->{dimstring} ;
	}
    }
    return $entry ;
}

# generate slide number, filename and url only when the order of entries is fixed
sub generate_slidename {
    my $entry = shift ;
    my $number = shift ;
    my $filename = $entry->{filename} ;

    # HTML slide and its url
    if (!$make_no_slides) {
	my $slide_filename ;
	if ($make_slide_filename_from_filename) {
	    if ($make_slide_filename_from_extension) {
		$slide_filename = $filename .".html" ;
	    } else {
		my @parts = split (/\./, $filename) ;
		pop @parts ;
		my $basename = join ('.', @parts) ;
		$slide_filename = $basename .".html" ;
	    }
	} else {
	    $slide_filename = "$slide_filenameprefix$number.html" ;
	}
	$entry->{slide_filename} = $slide_filename ;
	$entry->{slide_url} = make_safe_url_nowarn ($slide_filename) ;
    }
}

# generating entry table from files in target directory
sub get_entries_from_directory {

    opendir DIR, "./$destination_dir" # destination is empty for './'
	or die "Can't open $destination_string ($!)\n" ;
    # get all files, except dot-starting ones and .html ending ones
    my @filenames = grep ((!/\.html$/i and !/^\./), readdir DIR) ;
    closedir DIR ;

    # sort now so that slide numbering doesn't become wrong later
    if ($sort_criteria eq "name") {
	@filenames = sort @filenames ;
    } elsif ($sort_criteria eq "revname") {
	@filenames = sort { $b cmp $a } @filenames ;

    } elsif ($sort_criteria eq "iname") {
	@filenames = sort { uc($a) cmp uc($b) } @filenames ;
    } elsif ($sort_criteria eq "reviname") {
	@filenames = sort { uc($b) cmp uc($a) } @filenames ;

    } elsif ($sort_criteria eq "date" or $sort_criteria eq "time") {
	@filenames = sort { (-M $a) <=> (-M $b) } @filenames ;
    } elsif ($sort_criteria eq "revdate" or $sort_criteria eq "revtime") {
	@filenames = sort { (-M $b) <=> (-M $a) } @filenames ;

    } elsif ($sort_criteria eq "size") {
	@filenames = sort { (-s $a) <=> (-s $b) } @filenames ;
    } elsif ($sort_criteria eq "revsize") {
	@filenames = sort { (-s $b) <=> (-s $a) } @filenames ;

    } elsif ($sort_criteria eq "none" or $sort_criteria eq "") {
	# do not sort
    } else {
	die "Unknown sort criteria '$sort_criteria'.\n" ;
    }

    indprint "Preparing entries: " ;
    init_percentage () ;

    for(my $i = 0; $i < @filenames; $i++) {
	my $filename = @filenames[$i] ;
	if (-d "$destination_dir$filename") {
	    # directory
	    if ($add_subdirs) {
		my $entry = create_entry ($TYPE_DIR, $filename, undef, undef, undef) ;
		push @entries, $entry
		    if defined $entry ;
	    }

	} else {
	    # file
	    my $entry = undef ;

	    if ($filename =~ /($image_extensions)$/i) {
		# image
		my $entry = create_entry ($TYPE_IMG, $filename, undef, undef, undef) ;
		goto JUST_A_FILE
		    if not defined $entry ;
		push @entries, $entry ;

	    } elsif ($filename =~ /($movie_extensions)$/i) {
		# movie
		my $entry = create_entry ($TYPE_MVI, $filename, undef, undef, undef) ;
		goto JUST_A_FILE
		    if not defined $entry ;
		push @entries, $entry ;

	    } else {
	      JUST_A_FILE:
		if ($add_all_files) {
		    # not an image, not a movie, just a file
		    my $entry = create_entry ($TYPE_FIL, $filename, undef, undef, undef) ;
		    push @entries, $entry
			if defined $entry ;
		}
	    }
	}

	print_percentage ($i+1, scalar @filenames) ;
    }
    end_percentage () ;
    show_warnings ;
}

#######################################################################
# Check acces rights and create local subdirectory to place all llgal files

die "Destination $destination_string does not exist.\n"
    if ! -e "./$destination_dir" ; # destination is empty for './'
die "Destination $destination_string is not a directory.\n"
    if ! -d "./$destination_dir" ; # destination is empty for './'

# temporary check, to be removed soon
if ($local_llgal_dir ne ".llgal.files" and -e "${destination_dir}.llgal.files") {
  immediate_warning "!! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !!" ;
  immediate_warning "llgal now uses '.llgal' instead '.llgal.files'. !!" ;
  immediate_warning "You should probably update it.                  !!" ;
  immediate_warning "!! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !!" ;
}

if (! -e "$destination_dir$local_llgal_dir") {
    mkdir "$destination_dir$local_llgal_dir"
	or die "Failed to create $destination_dir$local_llgal_dir directory ($!)" ;
}
die "Local llgal '$destination_dir$local_llgal_dir' is not a directory.\n"
    if ! -d "$destination_dir$local_llgal_dir" ;

#######################################################################
# Generate captions if asked

if ($generate_captions) {
    # create and fill $captions_filename file if it doesn't exist
    get_entries_from_directory ;

    indprint "Found ". (scalar @entries) ." files in $destination_string\n" ;

    if (-e "$destination_dir$local_llgal_dir/$captions_filename") {
	indprint "Reading existing captions from $captions_filename.\n" ;
	open (CAP, "$destination_dir$local_llgal_dir/$captions_filename")
	    or die "Can't open $destination_dir$local_llgal_dir/$captions_filename for reading\n" ;
	my @captions = <CAP> ;
	close CAP ;

	indprint "Appending new captions to $captions_filename: " ;
	open (CAP, ">>$destination_dir$local_llgal_dir/$captions_filename")
	    or die "Can't open $destination_dir$local_llgal_dir/$captions_filename file to append\n" ;

	init_percentage () ;

	print CAP "\n" ;
	print CAP "# Appended new captions (", scalar localtime, ").\n" ;
	print CAP "\n" ;
	# it's not easy to count chars in an append-only file
	# so we don't count them when computing the percentage

	for (my $i = 0; $i < @entries; $i++) {
	    my $entry = $entries[$i] ;
	    my $type = $entry->{type} ;
	    if ($type == $TYPE_IMG) {
		print CAP "IMG: ". $entry->{filename}
		." ---- ". $entry->{caption} ."\n"
		    unless grep { $captions[$_] =~ m/^(\s*IMG:)?\s*$entry->{filename}\s+----\s/ } ( 0 .. $#captions ) ;
	    } elsif ($type == $TYPE_MVI) {
		print CAP "MVI: " . $entry->{filename}
		." ---- ". $entry->{linktext}
		." ---- ". $entry->{caption} ."\n"
		    unless grep { $captions[$_] =~ m/^\s*MVI:\s*$entry->{filename}\s+----\s/ } ( 0 .. $#captions ) ;
	    } elsif ($type == $TYPE_FIL) {
		print CAP "FIL: " . $entry->{filename}
		." ---- ". $entry->{linktext}
		." ---- ". $entry->{caption} ."\n"
		    unless grep { $captions[$_] =~ m/^\s*FIL:\s*$entry->{filename}\s+----\s/ } ( 0 .. $#captions ) ;
	    } elsif ($type == $TYPE_DIR) {
		print CAP "DIR: " . $entry->{filename}
		." ---- ". $entry->{linktext}
		." ---- ". $entry->{caption} ."\n"
		    unless grep { $captions[$_] =~ m/^\s*DIR:\s*$entry->{filename}\s+----\s/ } ( 0 .. $#captions ) ;
	    }
	    print_percentage ($i+1, scalar @entries) ;
	}
	end_percentage () ;
    } else {
	indprint "Creating the $captions_filename file: " ;
	open (CAP, ">$destination_dir$local_llgal_dir/$captions_filename")
	    or die "Can't create $destination_dir$local_llgal_dir/$captions_filename file\n" ;

	init_percentage () ;
	print CAP "# This is llgal's $captions_filename file, first generated ", scalar localtime, ".\n" ;
	if (open CAPHEADER, "$llgal_share_dir/$captions_header_filename") {
	    while (my $line = <CAPHEADER>) { print CAP $line ; }
	    close CAPHEADER ;
	} else {
	    add_warning "Failed to open $captions_header_filename\n" ;
	}
	print CAP "# $captions_removal_line\n" ;
	print CAP "\n" ;

	for (my $i = 0; $i < @entries; $i++) {
	    my $entry = $entries[$i] ;
	    my $type = $entry->{type} ;
	    if ($type == $TYPE_IMG) {
		print CAP "IMG: ". $entry->{filename}
		." ---- ". $entry->{caption} ."\n" ;
	    } elsif ($type == $TYPE_MVI) {
		print CAP "MVI: " . $entry->{filename}
		." ---- ". $entry->{linktext}
		." ---- ". $entry->{caption} ."\n" ;
	    } elsif ($type == $TYPE_FIL) {
		print CAP "FIL: " . $entry->{filename}
		." ---- ". $entry->{linktext}
		." ---- ". $entry->{caption} ."\n" ;
	    } elsif ($type == $TYPE_DIR) {
		print CAP "DIR: " . $entry->{filename}
		." ---- ". $entry->{linktext}
		." ---- ". $entry->{caption} ."\n" ;
	    }
	    print_percentage ($i+1, @entries) ;
	}
	end_percentage () ;
    }
    close CAP ;
    show_warnings ;

    if ($make_recursive) {
	my @dir_entries = grep { $_->{type} == $TYPE_DIR } @entries ;
	print "\n"
	    if @dir_entries ;
	foreach my $entry (@dir_entries) {
	    my $dir = $entry->{filename} ;
	    indprint "Entering subdirectory '$dir'...\n" ;
	    system ( $0, @llgal_options, "-d", "$destination_dir$dir", "--indent", "  ".$indent ) ;
	    die "Failed to call $0 for subdirectory $destination_dir$dir ($!).\n"
		if $? == -1 ;
	    immediate_warning "$0 failed for subdirectory $destination_dir$dir."
		if $? ;
	    indprint "Leaving subdirectory '$dir'.\n" ;
	    print "\n" ;
	}
    }

    indprint "Now edit the $destination_dir$local_llgal_dir/$captions_filename file to your liking and run llgal\n" ;
    exit 0 ;

}

#######################################################################
# Use captions file if it exists

if (-e "$destination_dir$local_llgal_dir/$captions_filename") {
    # read in files specified in the captions file since it exists
    indprint "Reading the $captions_filename file and preparing entries: " ;
    init_percentage () ;

    open(CAP,"$destination_dir$local_llgal_dir/$captions_filename")
	or die "Can't open $destination_dir$local_llgal_dir/$captions_filename file\n" ;

    my $size = (-s CAP) ;
    my $line ;
    while (defined ($line = <CAP>)) {
	chomp $line ;
	$line =~ s/^\s*// ;
	$line =~ s/\s\(\s*\)$/\1/ ;
	# only lines that don't start with # and are not empty
	if (!($line =~ m/^\#/) && !($line =~ /^$/)) {
	    if ($line =~ m/TITLE:\s*(.*)\s*/) {
		# title
		$index_title = $1 ;

	    } elsif ($line =~ m/^INDEXHEAD:\s+(.*)\s*$/) {
		# header for the index
		push @headers, $1 ;

	    } elsif ($line =~ m/^INDEXFOOT:\s+(.*)\s*$/) {
		# footer for the index
		push @footers, $1 ;

	    } else {
		# that's a slide, create its entry
		my $entry ;
		# flexibility:
		# - the last \s might be omitted when there's no caption
		# - \s is facultative after TYP: at the begining
		if ($line =~ m/^TXT:\s*(.+)\s+----\s*(?:\s(.*))?\s*$/) {
		    # text slide
		    $entry = create_entry ($TYPE_TXT, undef, undef, $1, $2) ;

		} elsif ($line =~ m/^LNK:\s*(.+)\s+----\s+(.+)\s+----\s*(?:\s(.*))?\s*$/) {
		    # link slide
		    $entry = create_entry ($TYPE_LNK, undef, $1, $2, $3) ;

		} elsif ($line =~ m/^DIR:\s*(.+)\s+----\s+(.+)\s+----\s*(?:\s(.*))?\s*$/) {
		    # directory slide
		    $entry = create_entry ($TYPE_DIR, $1, undef, $2, $3) ;

		} elsif ($line =~ m/^MVI:\s*(.+)\s+----\s+(.+)\s+----\s*(?:\s(.*))?\s*$/) {
		    # movie slide
		    $entry = create_entry ($TYPE_MVI, $1, undef, $2, $3) ;

		} elsif ($line =~ m/^FIL:\s*(.+)\s+----\s+(.+)\s+----\s*(?:\s(.*))?\s*$/) {
		    # movie slide
		    $entry = create_entry ($TYPE_FIL, $1, undef, $2, $3) ;

		} elsif ($line =~ m/^IMG:\s*(.+)\s+----\s*(?:\s(.*))?\s*$/
			 or $line =~ m/^(.+)\s+----\s*(?:\s(.*))?\s*$/) {
		    # image slide (default)
		    $entry = create_entry ($TYPE_IMG, $1, undef, undef, $2) ;

		} else {
		    die "Unrecognized line #$. in captions file: \"$line\"\n" ;
		}

		# really add this entry
		push @entries, $entry
		    if defined $entry ;
	    }
	}
	print_percentage (tell CAP, $size) ;
    }
    close CAP ;
    end_percentage () ;
    show_warnings ;
    indprint "Found ". (scalar @entries) ." files in the captions file.\n" ;

} else {
    # generate the gallery without captions file
    get_entries_from_directory ;

    show_warnings ;
    indprint "Found ". (scalar @entries) ." files in $destination_string\n" ;
}

# extract entries from the table
if ($list_links) {
    my @table_entries = () ;
    while (@entries) {
	my $entry = shift @entries ;
	my $type = $entry->{type} ;
	if ($type == $TYPE_LNK or $type == $TYPE_DIR or $type == $TYPE_MVI or $type == $TYPE_FIL) {
	    push @listed_links, $entry ;
	} else {
	    push @table_entries, $entry ;
	}
    }
    @entries = @table_entries ;
}

for(my $i=0; $i < @entries; $i++) {
    generate_slidename ($entries[$i], $i+1) ;
}

#######################################################################
# Add recursion header and footer

if ($parent_link) {
    unshift @headers, "<a href=\"..\">". $parent_link_text ."</a>" ;
    push @footers, "<a href=\"..\">". $parent_link_text ."</a>" ;
}

#######################################################################
# Create the individual slide show files

if ($make_no_slides) {
    indprint "Linking thumbnails directly to image files...  Making no html slides.\n" ;
} else {
    # remove old .html files
    system ("rm -f ${destination_dir}*.html") ;
    die "Failed to remove existing HTML slides.\n"
	if $? ;

    # find the slidetemplate
    my $slidetemplate = find_template_file ($slidetemplate_filename, 1) . "/$slidetemplate_filename" ;
    indprint "Using '$slidetemplate' as HTML slide template.\n" ;

    # keep the slidetemplate in memory instead of always reopening it
    my @slidetemplate_text ;
    open(SR,"$slidetemplate")
	or die "Can't open the slide template file '$slidetemplate'\n" ;
    @slidetemplate_text = <SR> ;
    close SR ;

    # create slides
    indprint "Creating individual slides: " ;
    init_percentage () ;
    for (my $i = 0; $i < @entries; $i++) {
	open(SW, ">$destination_dir$entries[$i]->{slide_filename}")
	    or die "Can't create slide file\n" ;
	my $entry = $entries[$i] ;
	my $type = $entry->{type} ;
	my $title = $entry->{title} ;

	my @slidetemplate_text_copy = @slidetemplate_text ; # don't touch the original template
        for my $line (@slidetemplate_text_copy) {
	    $line =~ s/<!--SLIDE-TITLE-->/$title/g ;
	    $line =~ s/<!--TITLE-->/$index_title/g ;
	    $line =~ s/<!--CSS-->/$local_llgal_dir\/$css_filename/g ;

	    # set the style
	    if ($line =~ m/<!--THIS-SLIDE-STYLE-->/g) {
		if ($type == $TYPE_IMG) {
		    $line =~ s/<!--THIS-SLIDE-STYLE-->/image-slide/ ;
		} else {
		    $line =~ s/<!--THIS-SLIDE-STYLE-->/text-slide" style="width: ${text_slide_width}px; height: ${text_slide_height}px;/ ;
		}
	    }

	    # fill the main part
	    if ($line =~ m/<!--THIS-SLIDE-->/g) {
		if ($type == $TYPE_IMG) {
		    # image slide

		    if (defined $entry->{scaled_filename}) {
			# scaled image with link to the real image
			$line =~ s/<!--THIS-SLIDE-->/<a href="$entry->{url}" title="$over_scaled_text$title $entry->{dimstring}"><img src="$entry->{scaled_url}" alt="$alt_scaled_text$title $entry->{scaled_dimstring}" \/><\/a>/ ;

		    } else {
			# real image
			$line =~ s/<!--THIS-SLIDE-->/<img src="$entry->{url}" alt="$alt_full_text$title $entry->{dimstring}" title="$title $entry->{dimstring}" \/>/g ;

		    }
		} elsif ($type == $TYPE_TXT) {
		    # text slide
		    $line =~ s/<!--THIS-SLIDE-->/$entry->{linktext}/ ;
		} else {
		    # link-style slide
		    $line =~ s/<!--THIS-SLIDE-->/<a href="$entry->{url}" title="$title $entry->{dimstring}">$entry->{linktext}<\/a>/ ;
		}
	    }

	    # add the caption, with the image counter unless --nc is specified
	    my $imagecaption ;
	    if ($show_no_slide_counter) {
		$imagecaption = $entry->{caption} ;
	    } else{
		$imagecaption = $entry->{caption} . "&nbsp;&nbsp;&nbsp;(" . ($i+1) ."/". (scalar @entries) .")" ;
	    }

	    # add dimensions and size to the caption
	    $imagecaption .= "&nbsp;&nbsp;&nbsp;$entry->{dimstring}" ;

	    $line =~ s/<!--IMAGE-CAPTION-->/$imagecaption/g ;
	    $line =~ s/<!--THIS-SLIDE-->/$entry->{slide_url}/g ;

	    # process INDEX-FILE
	    my $index_link = $index_link_text ;
	    $index_link = "<img src=\"$local_llgal_dir/". (make_safe_url $index_link_image_filename)
		."\" alt=\"$index_link_text\" class=\"image-link\" />"
		if $index_link_image ;
	    $line =~ s/<!--INDEX-LINK-TEXT-->/$index_link/g ;

	    $line =~ s/<!--INDEX-FILE-->/$index_filename/g ;

	    # process PREV-SLIDE
	    my $prev_slide_link = $prev_slide_link_text ;
	    $prev_slide_link = "<img src=\"$local_llgal_dir/". (make_safe_url $prev_slide_link_image_filename)
		."\" alt=\"$prev_slide_link_text\" class=\"image-link\" />"
		if $prev_slide_link_image ;
	    $line =~ s/<!--PREV-SLIDE-LINK-TEXT-->/$prev_slide_link/g ;

	    my $prev = $entries[$i-1] ;
	    $line =~ s/<!--PREV-SLIDE-->/$prev->{slide_url}\" title=\"$prev->{title}/g ;

	    # process NEXT-SLIDE
	    my $next_slide_link = $next_slide_link_text ;
	    $next_slide_link = "<img src=\"$local_llgal_dir/". (make_safe_url $next_slide_link_image_filename)
		."\" alt=\"$next_slide_link_text\" class=\"image-link\" />"
		if $next_slide_link_image ;
	    $line =~ s/<!--NEXT-SLIDE-LINK-TEXT-->/$next_slide_link/g ;

	    my $next = $entries[$i==@entries-1 ? 0 : $i+1] ;
	    $line =~ s/<!--NEXT-SLIDE-->/$next->{slide_url}\" title=\"$next->{title}/g ;

	    # output the line
	    print SW "$line" ;
	}
	close SW ;
	print_percentage ($i+1, scalar @entries) ;
    }
    end_percentage () ;
}
show_warnings ;

#######################################################################
# Creating the index file

# find the indextemplate
my $indextemplate = find_template_file ($indextemplate_filename, 1) . "/$indextemplate_filename" ;
indprint "Using '$indextemplate' as HTML index template.\n" ;

# open the template and the destination
indprint "Creating the $index_filename file: " ;
open(IXR, "$indextemplate")
    or die "Can't open the index template file '$indextemplate'\n" ;
open(IXW, ">$destination_dir$index_filename")
    or die "Can't create main $index_filename file\n" ;

# headers
my $line ;
while (defined($line = <IXR>)) {
    if ($line =~ m/<!--HEADERS-->/) {
	foreach my $header (@headers) {
	    print IXW "    <div class=\"header\">" . $header . "</div>\n" ;
	}
    } else {
	$line =~ s/LLGAL-OPTIONS/@llgal_options/g ;
        $line =~ s/<!--TITLE-->/$index_title/g ;
	$line =~ s/<!--CSS-->/$local_llgal_dir\/$css_filename/g ;
	print IXW "$line" ;
# stop at <!-- ********** -->
	last if $line =~ m/\*{10}/ ;
    }
}

# for each row
my $num ;
my $forced_width_warning = 0 ;
init_percentage () ;
for (my $i = 0; $i < @entries; $i += $num) {
    $num = 0 ;

# figure out how many to put in next row.
    my $width = 0 ;
    while ( ($i+$num < @entries)
	    && (!$thumbnails_per_row or $num < $thumbnails_per_row)
	    && (!$pixels_per_row or $width < $pixels_per_row) ) {
	$width += $entries[$num+$i]->{thumb_xdim} ;
	$num++ ;
	# add cellpadding
	$width += $index_cellpadding ;
    }
    if ($pixels_per_row > 0 && $width > $pixels_per_row) {
	if ($num >= 2) {
	    $num-- ;
	} else {
	    $forced_width_warning++ ;
	}
    }

# Table header
    if ($show_no_film_effect) {
	print IXW "<table class=\"index\" style=\"border-spacing: ", $index_cellpadding, "px 0px;\">\n" ;
    } else {
	print IXW "<table class=\"index with-tile\" style=\"border-spacing: ", $index_cellpadding, "px 0px;\">\n" ;
    }

# Row header
    print IXW "  <tr><td class=\"tiled\" colspan=\"", ($show_no_film_effect?$num:$num+2), "\">&nbsp;</td></tr>\n"
	unless $show_no_film_effect ;
    print IXW "  <tr>\n" ;
    print IXW "    <td class=\"thumb\">&nbsp;</td>\n"
	unless $show_no_film_effect ;

# Actual row of thumbnails
    for (my $j = 0; $j < $num; $j++) {
	my $entry = $entries[$i+$j] ;
	my $type = $entry->{type} ;
	my $width = $entry->{thumb_xdim} ;
	my $height = $entry->{thumb_ydim} ;

	if ($type == $TYPE_TXT or $type == $TYPE_LNK or $type == $TYPE_MVI or $type == $TYPE_FIL or $type == $TYPE_DIR) {
	    print IXW "    <td class=\"text-thumb\" style=\"width: ", $width, "px; height: ", $height, "px;\">\n" ;
            print IXW "      " ;
	    if ($type == $TYPE_TXT) {
		print IXW "<a href=\"$entry->{slide_url}\" title=\"$entry->{title}\">$entry->{linktext}</a>" ;
	    } else {
		# directly open links from the index
		print IXW "<a href=\"$entry->{url}\" title=\"$entry->{title} $entry->{dimstring}\">$entry->{linktext}</a>" ;
	    }
	    print IXW "</td>\n" ;
	} elsif ($type == $TYPE_IMG) {
	    my $altname = $entry->{title} ;
	    print IXW "    <td class=\"thumb\" style=\"width: ${width}px; height: ${height}px;\">\n" ;
	    if ($make_no_slides) {
		print IXW "      <a href=\"$entry->{url}\"" ;
	    } else {
		print IXW "      <a href=\"$entry->{slide_url}\"" ;
	    }
	    print IXW " title=\"$over_thumbnail_text$altname $entry->{scaled_dimstring}\">" ;
	    print IXW "<img src=\"$entry->{thumb_url}\" alt=\"$alt_thumbnail_text$altname $entry->{thumb_dimstring}\" />" ;
	    print IXW "</a></td>\n" ;
	} else {
	    die "Unknown type $type.\n" ;
	}
	print_percentage ($i+$j+1, scalar @entries) ;
    }

# Row footer
    print IXW "    <td class=\"thumb\">&nbsp;</td>\n"
	unless $show_no_film_effect ;
    print IXW "  </tr>\n" ;
    print IXW "  <tr><td class=\"tiled\" colspan=\"", $num+2, "\">&nbsp;</td></tr>\n"
	unless $show_no_film_effect ;

# Dimensions and filesizes
    if ($show_dimensions or $show_size) {
	print IXW "  <tr>\n" ;
	print IXW "    <td>&nbsp;</td>\n"
	    unless $show_no_film_effect ;
	for (my $j = 0; $j < $num; $j++) {
	    my $entry = $entries[$i+$j] ;
	    print IXW "    <td class=\"thumb-dim\">$entry->{scaled_dimstring}</td>\n" ;
	}
	print IXW "    <td>&nbsp;</td>\n"
	    unless $show_no_film_effect ;
	print IXW "  </tr>\n" ;
    }

# Write image captions under images if option -u is given
    if ($show_caption_under_thumbnails) {
	print IXW "  <tr>\n" ;
	print IXW "<td>&nbsp;</td>\n"
	    unless $show_no_film_effect ;
	for (my $j = 0; $j < $num; $j++) {
	    my $entry = $entries[$i+$j] ;
	    print IXW "    <td class=\"thumb-caption\">$entry->{caption}</td>\n" ;
	}
	print IXW "  </tr>\n" ;
    }

# Table footer
    print IXW "</table>\n<br />\n" ;
}

# list links
if ($list_links) {
    foreach my $entry (@listed_links) {
	my $type = $entry->{type} ;
	print IXW "<div class=\"header\">" ;
	if ($type == $TYPE_TXT) {
	    print IXW $entry->{linktext} ;
	} else {
	    # directly open links from the index
	    print IXW "<a href=\"$entry->{url}\" title=\"$entry->{title} $entry->{dimstring}\">$entry->{linktext}</a>" ;
	}
	print IXW "</div>\n" ;
    }
}

# search next <!-- ********** -->
while (defined($line = <IXR>)) {
    last if $line =~ m/\*{10}/ ;
}

# footers
while (defined ($line = <IXR>)) {
    if ($line =~ m/<!--FOOTERS-->/) {
	foreach my $footer (@footers) {
	    print IXW "    <div class=\"footer\">" . $footer . "</div>\n" ;
	}
    } else {
	$line =~ s/<!--TITLE-->/$index_title/g ;
	print IXW "$line" ;
    }
}
close IXW ;
close IXR ;

end_percentage () ;
show_warnings ;

immediate_warning "Row width max ($pixels_per_row) too low for one single thumbnail. "
    . "Forced $forced_width_warning time". ($forced_width_warning>1?"s":"") ."."
    if $forced_width_warning ;

#######################################################################

# Get the film tile for the index
if ($show_no_film_effect) {
    indprint "Omitting film effect.\n" ;
} else {
    get_template_file ($filmtile_filename) ;
    # rescale the tiled image if needed
    my $tileh = (imgsize ("$destination_dir$local_llgal_dir/$filmtile_filename"))[1] ;
    if ($tile_height != $tileh) {
	my ($status, @output) = system_with_output
	    ( "reduce film tile",
	      "mogrify", "-scale", "x$tile_height", "$destination_dir$local_llgal_dir/$filmtile_filename" ) ;
	if ($status) {
	    # die on whatever error
	    immediate_external_warnings @output ;
	    die "Failed to execute 'mogrify' to reduce the film tile.\n" ;
	}
    }
}

# Get link images
get_template_file ($index_link_image_filename)
    if $index_link_image ;
get_template_file ($prev_slide_link_image_filename)
    if $prev_slide_link_image ;
get_template_file ($next_slide_link_image_filename)
    if $next_slide_link_image ;

# Get the css
get_template_file ($css_filename) ;

#######################################################################
# Chmod

sub make_readable {
    my $file = shift ;
    my ($status, @output) = system_with_output ("make world readable",
						"chmod", "a+r", $file) ;
    add_external_warnings @output
	if $status ;
}   

sub make_readable_and_traversable {
    my $file = shift ;
    my ($status, @output) = system_with_output ("make world readable and traversable",
						"chmod", "a+rx", $file) ;
    add_external_warnings @output
	if $status ;
}   

# If --www was invoked make all files world-readable at the END
if ($www_access_rights) {
    indprint "Making all llgal files world-readable for WWW publishing.\n" ;
    
    # index
    make_readable "$destination_dir$index_filename" ;
    # .llgal
    make_readable_and_traversable "$destination_dir$local_llgal_dir" ;
    # css
    make_readable "$destination_dir$local_llgal_dir/$css_filename" ;
    # filmtile
    make_readable "$destination_dir$local_llgal_dir/$filmtile_filename"
	if ! $show_no_film_effect ;
    # index link image
    make_readable "$destination_dir$local_llgal_dir/$index_link_image_filename"
 	if ! $index_link_image ;
    # next slide link image
    make_readable "$destination_dir$local_llgal_dir/$next_slide_link_image_filename"
 	if ! $next_slide_link_image ;
    # prev slide link image
    make_readable "$destination_dir$local_llgal_dir/$prev_slide_link_image_filename"
 	if ! $prev_slide_link_image ;
    
    # entries that have a slide
    foreach my $entry (@entries) {
	my $type = $entry->{type} ;
	
	# target
	my $file = "$destination_dir$entry->{filename}" ;
	if ($type == $TYPE_DIR) {
	    make_readable_and_traversable $file ;
	} else {
	    make_readable $file ;
	}
	
	# slide
	make_readable "$destination_dir$entry->{slide_filename}"
	    if ! $make_no_slides ;
	
	if ($type == $TYPE_IMG) {
	    # thumbnail
	    make_readable "$destination_dir$entry->{thumb_filename}" ;
	    # scaled image
	    make_readable "$destination_dir$entry->{scaled_filename}"
		if ($slide_width_max > 0 or $slide_height_max > 0) and !$make_no_slides ;
	}
	
    }

    # entries that are just listed
    foreach my $entry (@listed_links) {
	my $type = $entry->{type} ;
	
	# target
	my $file = "$destination_dir$entry->{filename}" ;
	if ($type == $TYPE_DIR) {
	    make_readable_and_traversable $file ;
	} else {
	    make_readable $file ;
	}	
    }
    
    show_warnings ;
}

#######################################################################
# If --gencfg was invoked, generate a configuration file

if (defined $generate_config) {
    die "Cannot generate $generate_config which already exists."
	if -e "$generate_config" ;
    open NEWCFG, ">$generate_config"
	or die "Cannot open $generate_config configuration file ($!).\n" ;

    print NEWCFG "# This is a llgal configuration file.\n" ;
    print NEWCFG "# It was automatically generated.\n" ;
    print NEWCFG "# You may modify and reuse it as you want.\n" ;
    print NEWCFG "\n" ;
    print NEWCFG "# llgal directories:\n" ;
    print NEWCFG "llgal_share_dir = \"$llgal_share_dir\"\n" ;
    print NEWCFG "user_share_dir = \"$user_share_dir\"\n" ;
    map { print NEWCFG "template_dir = \"$_\"\n" ; } @template_dirs ;
    print NEWCFG "# Name of generic llgal files:\n" ;
    print NEWCFG "captions_header_filename = \"$captions_header_filename\"\n" ;
    print NEWCFG "css_filename = \"$css_filename\"\n" ;
    print NEWCFG "filmtile_filename = \"$filmtile_filename\"\n" ;
    print NEWCFG "index_link_image_filename = \"$index_link_image_filename\"\n" ;
    print NEWCFG "prev_slide_link_image_filename = \"$prev_slide_link_image_filename\"\n" ;
    print NEWCFG "next_slide_link_image_filename = \"$next_slide_link_image_filename\"\n" ;
    print NEWCFG "indextemplate_filename = \"$indextemplate_filename\"\n" ;
    print NEWCFG "slidetemplate_filename = \"$slidetemplate_filename\"\n" ;
    print NEWCFG "# Location and name of generated files:\n" ;
    print NEWCFG "local_llgal_dir = \"$local_llgal_dir\"\n" ;
    print NEWCFG "scaled_image_filenameprefix = \"$scaled_image_filenameprefix\"\n" ;
    print NEWCFG "thumbnail_image_filenameprefix = \"$thumbnail_image_filenameprefix\"\n" ;
    print NEWCFG "# Index:\n" ;
    print NEWCFG "index_filename = \"$index_filename\"\n" ;
    print NEWCFG "index_cellpadding = $index_cellpadding\n" ;
    print NEWCFG "list_links = $list_links\n" ;
    print NEWCFG "pixels_per_row = $pixels_per_row\n" ;
    print NEWCFG "# Film effects:\n" ;
    print NEWCFG "show_no_film_effect = $show_no_film_effect\n" ;
    print NEWCFG "tile_height = $tile_height\n" ;
    print NEWCFG "# Thumbnails:\n" ;
    print NEWCFG "thumbnail_width_max = $thumbnail_width_max\n" ;
    print NEWCFG "thumbnail_height_max = $thumbnail_height_max\n" ;
    print NEWCFG "thumbnails_per_row = $thumbnails_per_row\n" ;
    print NEWCFG "# Slides:\n" ;
    print NEWCFG "make_no_slides = $make_no_slides\n" ;
    print NEWCFG "make_slide_filename_from_filename = $make_slide_filename_from_filename\n" ;
    print NEWCFG "make_slide_filename_from_extension = $make_slide_filename_from_extension\n" ;
    print NEWCFG "make_slide_title_from_caption = $make_slide_title_from_caption\n" ;
    print NEWCFG "show_no_slide_counter = $show_no_slide_counter\n" ;
    print NEWCFG "slide_filenameprefix = \"$slide_filenameprefix\"\n" ;
    print NEWCFG "slide_filenameprefix_nofile = \"$slide_filenameprefix_nofile\"\n" ;
    print NEWCFG "slide_width_max = $slide_width_max\n" ;
    print NEWCFG "slide_height_max = $slide_height_max\n" ;
    print NEWCFG "text_slide_width = $text_slide_width\n" ;
    print NEWCFG "text_slide_height = $text_slide_height\n" ;
    print NEWCFG "index_link_image = $index_link_image\n" ;
    print NEWCFG "next_slide_link_image = $next_slide_link_image\n" ;
    print NEWCFG "prev_slide_link_image = $prev_slide_link_image\n" ;
    print NEWCFG "# Captions:\n" ;
    print NEWCFG "captions_filename = \"$captions_filename\"\n" ;
    print NEWCFG "captions_removal_line = \"$captions_removal_line\"\n" ;
    print NEWCFG "make_caption_from_image_comment = \"$make_caption_from_image_comment\"\n" ;
    print NEWCFG "make_caption_from_image_timestamp = $make_caption_from_image_timestamp\n" ;
    print NEWCFG "make_caption_from_filename = $make_caption_from_filename\n" ;
    print NEWCFG "show_caption_under_thumbnails = $show_caption_under_thumbnails\n" ;
    print NEWCFG "show_dimensions = $show_dimensions\n" ;
    print NEWCFG "show_size = $show_size\n" ;
    print NEWCFG "# Exclude:\n" ;
    map {
	print NEWCFG ($_->{excluded} ? "exclude" : "include"). " = \"". $_->{filter} ."\"\n" ;
    } @excludes ;
    print NEWCFG "# Text:\n" ;
    print NEWCFG "MVI_default_link_text = \"$MVI_default_link_text\"\n" ;
    print NEWCFG "FIL_default_link_text = \"$FIL_default_link_text\"\n" ;
    print NEWCFG "DIR_default_link_text = \"$DIR_default_link_text\"\n" ;
    print NEWCFG "alt_full_text = \"$alt_full_text\"\n" ;
    print NEWCFG "alt_scaled_text = \"$alt_scaled_text\"\n" ;
    print NEWCFG "alt_thumbnail_text = \"$alt_thumbnail_text\"\n" ;
    print NEWCFG "index_link_text = \"$index_link_text\"\n" ;
    print NEWCFG "index_title = \"$index_title\"\n" ;
    print NEWCFG "next_slide_link_text = \"$next_slide_link_text\"\n" ;
    print NEWCFG "over_scaled_text = \"$over_scaled_text\"\n" ;
    print NEWCFG "over_thumbnail_text = \"$over_thumbnail_text\"\n" ;
    print NEWCFG "parent_link_text = \"$parent_link_text\"\n" ;
    print NEWCFG "prev_slide_link_text = \"$prev_slide_link_text\"\n" ;
    print NEWCFG "show_size_unit = \"$show_size_unit\"\n" ;
    print NEWCFG "timestamp_format_in_caption = \"$timestamp_format_in_caption\"\n" ;
    print NEWCFG "# Recursion:\n" ;
    print NEWCFG "make_recursive = $make_recursive\n" ;
    print NEWCFG "parent_link = $parent_link\n" ;
    print NEWCFG "# Various:\n" ;
    print NEWCFG "add_all_files = $add_all_files\n" ;
    print NEWCFG "add_subdirs = $add_subdirs\n" ;
    print NEWCFG "convert_options = \"". (join_convert_options (@convert_options)) ."\"\n" ;
    print NEWCFG "scaled_convert_options = \"". (join_convert_options (@scaled_convert_options)) ."\"\n" ;
    print NEWCFG "thumbnail_convert_options = \"". (join_convert_options (@thumbnail_convert_options)) ."\"\n" ;
    print NEWCFG "image_extensions = \"$image_extensions\"\n" ;
    print NEWCFG "movie_extensions = \"$movie_extensions\"\n" ;
    print NEWCFG "no_default_link_text = $no_default_link_text\n" ;
    print NEWCFG "sort_criteria = \"$sort_criteria\"\n" ;
    print NEWCFG "www_access_rights = $www_access_rights\n" ;

    close NEWCFG ;
}

#######################################################################
# Process subdirectories

if ($make_recursive) {
    my @dir_entries = grep { $_->{type} == $TYPE_DIR } @entries ;
    foreach my $entry (@dir_entries) {
	my $dir = $entry->{filename} ;
	print "\n" ;
	indprint "Entering subdirectory '$dir'...\n" ;
	system ( $0, @llgal_options, "-d", "$destination_dir$dir", "--parent", "--indent", $indent."  " ) ;
	die "Failed to call $0 for subdirectory $destination_dir$dir ($!).\n"
	    if $? == -1 ;
	immediate_warning "$0 failed for subdirectory $destination_dir$dir."
	    if $? ;
	indprint "Leaving subdirectory '$dir'.\n" ;
    }
}
